{"version":3,"sources":["webpack:///typescript-logging.bundle.min.js","webpack:///webpack/bootstrap aebdd958c8e658740c81","webpack:///./dist/commonjs/typescript-logging.js","webpack:///./dist/commonjs/Logger.js","webpack:///./dist/commonjs/LoggerImpl.js","webpack:///./dist/commonjs/LoggerFactoryService.js","webpack:///./~/stacktrace-js/stacktrace.js","webpack:///./~/error-stack-parser/error-stack-parser.js","webpack:///./~/stackframe/stackframe.js","webpack:///./~/stack-generator/stack-generator.js","webpack:///./~/stacktrace-gps/stacktrace-gps.js","webpack:///./~/source-map/source-map.js","webpack:///./~/source-map/lib/source-map-generator.js","webpack:///./~/source-map/lib/base64-vlq.js","webpack:///./~/source-map/lib/base64.js","webpack:///./~/source-map/lib/util.js","webpack:///./~/source-map/lib/array-set.js","webpack:///./~/source-map/lib/mapping-list.js","webpack:///./~/source-map/lib/source-map-consumer.js","webpack:///./~/source-map/lib/binary-search.js","webpack:///./~/source-map/lib/quick-sort.js","webpack:///./~/source-map/lib/source-node.js"],"names":["TSL","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__export","hasOwnProperty","LogLevel","LoggerType","__extends","this","d","b","__","constructor","prototype","Object","create","Logger_1","LoggerFactoryService_1","ST","Message","ready","message","_ready","_message","defineProperty","get","set","value","enumerable","configurable","LinkedNode","_previous","_next","_value","LinkedList","head","size","addHead","createHeadIfNeeded","nextNode","next","newHeadNode","previous","addTail","oldTailNode","getTailNode","newTailNode","clear","getHead","removeHead","oldHead","getTail","node","removeTail","previousNode","getSize","AbstractLogger","name","rule","open","_allMessages","level","trace","msg","error","log","Trace","debug","Debug","info","Info","warn","Warn","Error","fatal","Fatal","tracec","logc","debugc","infoc","warnc","errorc","fatalc","isTraceEnabled","isDebugEnabled","isInfoEnabled","isWarnEnabled","isErrorEnabled","isFatalEnabled","getLogLevel","createMessage","Date","processMessages","undefined","isOpen","close","date","_this","lpad","chars","padWith","howMany","length","res","i","fullYear","getFullYear","toString","month","getMonth","day","getDate","hours","getHours","minutes","getMinutes","seconds","getSeconds","millis","getMilliseconds","result","logFormat","showTimeStamp","dateSeparator","dateFormat","ds","formatEnum","DateFormatEnum","Default","YearMonthDayTime","YearDayMonthWithFullTime","YearDayMonthTime","toUpperCase","showLoggerName","message_1","fromError","offline","then","frames","stackStr","map","frame","join","msgs","doLog","ConsoleLoggerImpl","_super","console","MessageBufferLoggerImpl","messages","push","getMessages","LoggerImpl_1","DateFormat","_formatEnum","_dateSeparator","LogFormat","_showTimeStamp","_showLoggerName","_dateFormat","LogGroupRule","regExp","loggerType","callBackLogger","Console","_regExp","_level","_logFormat","_loggerType","_callBackLogger","LoggerFactoryOptions","_logGroupRules","_enabled","addLogGroupRule","setEnabled","enabled","LoggerFactoryImpl","options","loggers","configure","closeLoggers","getLogger","named","logger","loadLogger","isEnabled","key","logGroupRules","logGroupRule","test","MessageBuffer","Custom","LFService","createLoggerFactory","factory","createDefaultOptions","_loggerFactories","RegExp","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","apply","ErrorStackParser","StackGenerator","StackTraceGPS","_merge","first","second","target","forEach","obj","prop","_isShapedLikeParsableError","err","stack","_filtered","stackframes","filter","_options","stackframe","functionName","indexOf","sourceCache","_generateError","opts","generateArtificially","getSync","parse","backtrace","gps","Promise","resolve","all","sf","resolveOriginal","pinpoint","bind","stackFrames","instrument","fn","callback","errback","thisArg","__stacktraceOriginalFn","instrumented","arguments","e","deinstrument","report","url","errorMsg","reject","req","XMLHttpRequest","onerror","onreadystatechange","readyState","status","responseText","setRequestHeader","reportPayload","send","JSON","stringify","StackFrame","_map","array","Array","output","_filter","_indexOf","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stacktrace","parseOpera","match","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","parts","exec","replace","filtered","split","line","tokens","slice","locationParts","pop","fileName","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","len","argsRaw","functionCall","shift","args","_isNumber","n","isNaN","parseFloat","isFinite","lineNumber","columnNumber","source","setFunctionName","setArgs","setFileName","setLineNumber","setColumnNumber","setSource","getFunctionName","v","String","getArgs","TypeError","getFileName","getLineNumber","Number","getColumnNumber","getSource","maxStackSize","curr","callee","$1","caller","SourceMap","_xdr","_atob","b64str","window","atob","_parseJson","string","_findFunctionName","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","code","maxLines","Math","min","commentPos","substr","_ensureSupportedEnvironment","_ensureStackFrameIsLegit","_findSourceMappingURL","_extractLocationInfoFromSourceMap","rawSourceMap","mapConsumer","SourceMapConsumer","loc","originalPositionFor","column","mappedSource","sourceContentFor","ajax","_get","location","isDataUrl","supportedEncodingRegexp","sourceMapStart","encodedSource","xhrPromise","method","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","sourceMappingURL","base","substring","lastIndexOf","sourceMap","sourceRoot","SourceMapGenerator","SourceNode","aArgs","_file","util","getArg","_sourceRoot","_skipValidation","_sources","ArraySet","_names","_mappings","MappingList","_sourcesContents","base64VLQ","_version","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","generatedLine","generatedColumn","relative","original","originalLine","originalColumn","addMapping","sources","sourceFile","content","setSourceContent","_validateMapping","has","add","aSourceFile","aSourceContent","toSetString","keys","applySourceMap","aSourceMapPath","newSources","newNames","unsortedForEach","aGenerated","aOriginal","aSource","aName","_serializeMappings","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","toArray","compareByGeneratedPositionsInflated","encode","_generateSourcesContent","aSources","aSourceRoot","toJSON","version","names","sourcesContent","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","digit","encoded","vlq","decode","aStr","aIndex","aOutParam","continuation","strLen","charCodeAt","charAt","rest","intToCharMap","number","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","aDefaultValue","urlParse","aUrl","urlRegexp","scheme","auth","host","port","path","urlGenerate","aParsedUrl","normalize","aPath","part","isAbsolute","up","splice","aRoot","aPathUrl","aRootUrl","dataUrlRegexp","joined","index","identity","s","isProtoString","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","compareByGeneratedPositionsDeflated","onlyCompareGenerated","strcmp","aStr1","aStr2","supportsNullProto","_array","_set","fromArray","aArray","aAllowDuplicates","getOwnPropertyNames","sStr","isDuplicate","idx","at","aIdx","generatedPositionAfter","lineA","lineB","columnA","columnB","_sorted","_last","aCallback","aThisArg","aMapping","sort","aSourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","Mapping","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","binarySearch","quickSort","__generatedMappings","_parseMappings","__originalMappings","_charIsMappingSeparator","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","aContext","aOrder","context","order","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findMapping","lastColumn","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","str","segment","end","cachedSegments","temp","originalMappings","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","some","sc","nullOnMissing","fileUriAbsPath","generatedPositionFor","j","sectionIndex","section","bias","every","generatedPosition","ret","sectionMappings","adjustedMapping","recursiveSearch","aLow","aHigh","aHaystack","aCompare","mid","floor","swap","ary","x","y","randomIntInRange","low","high","round","random","doQuickSort","comparator","r","pivotIndex","pivot","q","aLine","aColumn","aChunks","children","sourceContents","isSourceNode","REGEX_NEWLINE","NEWLINE_CODE","fromStringWithSourceMap","aGeneratedCode","aRelativePath","addMappingWithCode","remainingLines","shiftNextLine","lineContents","newLine","lastGeneratedLine","lastMapping","nextLine","aChunk","isArray","chunk","prepend","unshift","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent"],"mappings":"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","file":"typescript-logging.bundle.min.js","sourcesContent":["var TSL =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\t__export(__webpack_require__(1));\n\t__export(__webpack_require__(2));\n\t__export(__webpack_require__(3));\n\t//# sourceMappingURL=typescript-logging.js.map\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Log level for a logger.\n\t */\n\t(function (LogLevel) {\n\t    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n\t    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n\t    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n\t    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n\t    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n\t    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n\t})(exports.LogLevel || (exports.LogLevel = {}));\n\tvar LogLevel = exports.LogLevel;\n\t/**\n\t * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)\n\t * where this comes into play.\n\t */\n\t(function (LoggerType) {\n\t    LoggerType[LoggerType[\"Console\"] = 0] = \"Console\";\n\t    LoggerType[LoggerType[\"MessageBuffer\"] = 1] = \"MessageBuffer\";\n\t    LoggerType[LoggerType[\"Custom\"] = 2] = \"Custom\";\n\t})(exports.LoggerType || (exports.LoggerType = {}));\n\tvar LoggerType = exports.LoggerType;\n\t//# sourceMappingURL=Logger.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Logger_1 = __webpack_require__(1);\n\tvar LoggerFactoryService_1 = __webpack_require__(3);\n\tvar ST = __webpack_require__(4);\n\tvar Message = (function () {\n\t    function Message(ready, message) {\n\t        this._ready = ready;\n\t        this._message = message;\n\t    }\n\t    Object.defineProperty(Message.prototype, \"ready\", {\n\t        get: function () {\n\t            return this._ready;\n\t        },\n\t        set: function (value) {\n\t            this._ready = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Message.prototype, \"message\", {\n\t        get: function () {\n\t            return this._message;\n\t        },\n\t        set: function (value) {\n\t            this._message = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return Message;\n\t}());\n\tvar LinkedNode = (function () {\n\t    function LinkedNode(value) {\n\t        this._previous = null;\n\t        this._next = null;\n\t        this._value = value;\n\t    }\n\t    Object.defineProperty(LinkedNode.prototype, \"previous\", {\n\t        get: function () {\n\t            return this._previous;\n\t        },\n\t        set: function (value) {\n\t            this._previous = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LinkedNode.prototype, \"next\", {\n\t        get: function () {\n\t            return this._next;\n\t        },\n\t        set: function (value) {\n\t            this._next = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LinkedNode.prototype, \"value\", {\n\t        get: function () {\n\t            return this._value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LinkedNode;\n\t}());\n\tvar LinkedList = (function () {\n\t    function LinkedList() {\n\t        this.head = null;\n\t        this.size = 0;\n\t    }\n\t    LinkedList.prototype.addHead = function (value) {\n\t        if (!this.createHeadIfNeeded(value)) {\n\t            var nextNode = this.head.next;\n\t            var newHeadNode = new LinkedNode(value);\n\t            if (nextNode != null) {\n\t                nextNode.previous = newHeadNode;\n\t                newHeadNode.next = nextNode;\n\t            }\n\t            this.head = newHeadNode;\n\t        }\n\t        this.size++;\n\t    };\n\t    LinkedList.prototype.addTail = function (value) {\n\t        if (!this.createHeadIfNeeded(value)) {\n\t            var oldTailNode = this.getTailNode();\n\t            var newTailNode = new LinkedNode(value);\n\t            oldTailNode.next = newTailNode;\n\t            newTailNode.previous = oldTailNode;\n\t        }\n\t        this.size++;\n\t    };\n\t    LinkedList.prototype.clear = function () {\n\t        this.head = null;\n\t        this.size = 0;\n\t    };\n\t    LinkedList.prototype.getHead = function () {\n\t        if (this.head != null) {\n\t            return this.head.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.removeHead = function () {\n\t        if (this.head != null) {\n\t            var oldHead = this.head;\n\t            var value = oldHead.value;\n\t            this.head = oldHead.next;\n\t            this.size--;\n\t            return value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.getTail = function () {\n\t        var node = this.getTailNode();\n\t        if (node != null) {\n\t            return node.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.removeTail = function () {\n\t        var node = this.getTailNode();\n\t        if (node != null) {\n\t            if (node === this.head) {\n\t                this.head = null;\n\t            }\n\t            else {\n\t                var previousNode = node.previous;\n\t                previousNode.next = null;\n\t            }\n\t            this.size--;\n\t            return node.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.getSize = function () {\n\t        return this.size;\n\t    };\n\t    LinkedList.prototype.createHeadIfNeeded = function (value) {\n\t        if (this.head == null) {\n\t            this.head = new LinkedNode(value);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    LinkedList.prototype.getTailNode = function () {\n\t        if (this.head == null) {\n\t            return null;\n\t        }\n\t        var node = this.head;\n\t        while (node.next != null) {\n\t            node = node.next;\n\t        }\n\t        return node;\n\t    };\n\t    return LinkedList;\n\t}());\n\t/**\n\t * Abstract base logger, extend to easily implement a custom logger that\n\t * logs wherever you want. You only need to implement doLog(msg: string) and\n\t * log that somewhere (it will contain format and everything else).\n\t */\n\tvar AbstractLogger = (function () {\n\t    function AbstractLogger(name, rule) {\n\t        this.open = true;\n\t        this._allMessages = new LinkedList();\n\t        this.name = name;\n\t        this.rule = rule;\n\t        this.level = rule.level;\n\t    }\n\t    AbstractLogger.prototype.trace = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Trace, msg, error);\n\t    };\n\t    AbstractLogger.prototype.debug = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Debug, msg, error);\n\t    };\n\t    AbstractLogger.prototype.info = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Info, msg, error);\n\t    };\n\t    AbstractLogger.prototype.warn = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Warn, msg, error);\n\t    };\n\t    AbstractLogger.prototype.error = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Error, msg, error);\n\t    };\n\t    AbstractLogger.prototype.fatal = function (msg, error) {\n\t        this.log(Logger_1.LogLevel.Fatal, msg, error);\n\t    };\n\t    AbstractLogger.prototype.tracec = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Trace, msg, error);\n\t    };\n\t    AbstractLogger.prototype.debugc = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Debug, msg, error);\n\t    };\n\t    AbstractLogger.prototype.infoc = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Info, msg, error);\n\t    };\n\t    AbstractLogger.prototype.warnc = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Warn, msg, error);\n\t    };\n\t    AbstractLogger.prototype.errorc = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Error, msg, error);\n\t    };\n\t    AbstractLogger.prototype.fatalc = function (msg, error) {\n\t        this.logc(Logger_1.LogLevel.Fatal, msg, error);\n\t    };\n\t    AbstractLogger.prototype.isTraceEnabled = function () {\n\t        return this.level == Logger_1.LogLevel.Trace;\n\t    };\n\t    AbstractLogger.prototype.isDebugEnabled = function () {\n\t        return this.level <= Logger_1.LogLevel.Debug;\n\t    };\n\t    AbstractLogger.prototype.isInfoEnabled = function () {\n\t        return this.level <= Logger_1.LogLevel.Info;\n\t    };\n\t    AbstractLogger.prototype.isWarnEnabled = function () {\n\t        return this.level <= Logger_1.LogLevel.Warn;\n\t    };\n\t    AbstractLogger.prototype.isErrorEnabled = function () {\n\t        return this.level <= Logger_1.LogLevel.Error;\n\t    };\n\t    AbstractLogger.prototype.isFatalEnabled = function () {\n\t        return this.level <= Logger_1.LogLevel.Fatal;\n\t    };\n\t    AbstractLogger.prototype.getLogLevel = function () {\n\t        return this.level;\n\t    };\n\t    AbstractLogger.prototype.log = function (level, msg, error) {\n\t        if (this.open && this.level <= level) {\n\t            this._allMessages.addTail(this.createMessage(level, msg, new Date(), error));\n\t            this.processMessages();\n\t        }\n\t    };\n\t    AbstractLogger.prototype.logc = function (level, msg, error) {\n\t        if (this.open && this.level <= level) {\n\t            this._allMessages.addTail(this.createMessage(level, msg(), new Date(), error !== undefined ? error() : undefined));\n\t            this.processMessages();\n\t        }\n\t    };\n\t    AbstractLogger.prototype.isOpen = function () {\n\t        return this.open;\n\t    };\n\t    AbstractLogger.prototype.close = function () {\n\t        this.open = false;\n\t        this._allMessages.clear();\n\t    };\n\t    AbstractLogger.prototype.createMessage = function (level, msg, date, error) {\n\t        var _this = this;\n\t        var lpad = function (value, chars, padWith) {\n\t            var howMany = chars - value.length;\n\t            if (howMany > 0) {\n\t                var res = '';\n\t                for (var i = 0; i < howMany; i++) {\n\t                    res += padWith;\n\t                }\n\t                res += value;\n\t                return res;\n\t            }\n\t            return value;\n\t        };\n\t        var fullYear = function (date) {\n\t            return lpad(date.getFullYear().toString(), 4, '0');\n\t        };\n\t        var month = function (date) {\n\t            return lpad((date.getMonth() + 1).toString(), 2, '0');\n\t        };\n\t        var day = function (date) {\n\t            return lpad(date.getDate().toString(), 2, '0');\n\t        };\n\t        var hours = function (date) {\n\t            return lpad(date.getHours().toString(), 2, '0');\n\t        };\n\t        var minutes = function (date) {\n\t            return lpad(date.getMinutes().toString(), 2, '0');\n\t        };\n\t        var seconds = function (date) {\n\t            return lpad(date.getSeconds().toString(), 2, '0');\n\t        };\n\t        var millis = function (date) {\n\t            return date.getMilliseconds().toString();\n\t        };\n\t        var result = \"\";\n\t        if (this.rule.logFormat.showTimeStamp) {\n\t            var dateSeparator = this.rule.logFormat.dateFormat.dateSeparator;\n\t            var ds = '';\n\t            switch (this.rule.logFormat.dateFormat.formatEnum) {\n\t                case LoggerFactoryService_1.DateFormatEnum.Default:\n\t                    // yyyy-mm-dd hh:mm:ss,m\n\t                    ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + ' ' +\n\t                        hours(date) + ':' + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n\t                    break;\n\t                case LoggerFactoryService_1.DateFormatEnum.YearMonthDayTime:\n\t                    ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + ' ' +\n\t                        hours(date) + ':' + minutes(date) + \":\" + seconds(date);\n\t                    break;\n\t                case LoggerFactoryService_1.DateFormatEnum.YearDayMonthWithFullTime:\n\t                    ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + ' ' +\n\t                        hours(date) + ':' + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n\t                    break;\n\t                case LoggerFactoryService_1.DateFormatEnum.YearDayMonthTime:\n\t                    ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + ' ' +\n\t                        hours(date) + ':' + minutes(date) + \":\" + seconds(date);\n\t                    break;\n\t                default:\n\t                    throw new Error(\"Unsupported date format enum: \" + this.rule.logFormat.dateFormat.formatEnum);\n\t            }\n\t            result += ds + \" \";\n\t        }\n\t        result += Logger_1.LogLevel[level].toUpperCase() + \" \";\n\t        if (this.rule.logFormat.showLoggerName) {\n\t            result += \"[\" + this.name + \"]\";\n\t        }\n\t        result += ' ' + msg;\n\t        if (error !== undefined) {\n\t            var message_1 = new Message(false);\n\t            result += '\\n' + error.name + \": \" + error.message + \"\\n@\";\n\t            ST.fromError(error, { offline: true }).then(function (frames) {\n\t                var stackStr = (frames.map(function (frame) {\n\t                    return frame.toString();\n\t                })).join('\\n  ');\n\t                result += '\\n' + stackStr;\n\t                message_1.message = result;\n\t                message_1.ready = true;\n\t                _this.processMessages();\n\t            });\n\t            return message_1;\n\t        }\n\t        else {\n\t            return new Message(true, result);\n\t        }\n\t    };\n\t    AbstractLogger.prototype.processMessages = function () {\n\t        // Basically we wait until errors are resolved (those messages\n\t        // may not be ready).\n\t        var msgs = this._allMessages;\n\t        if (msgs.getSize() > 0) {\n\t            do {\n\t                var msg = msgs.getHead();\n\t                if (msg != null) {\n\t                    if (!msg.ready) {\n\t                        break;\n\t                    }\n\t                    msgs.removeHead();\n\t                    this.doLog(msg.message);\n\t                }\n\t            } while (msgs.getSize() > 0);\n\t        }\n\t    };\n\t    return AbstractLogger;\n\t}());\n\texports.AbstractLogger = AbstractLogger;\n\t/**\n\t * Simple logger, that logs to the console. If the console is unavailable will throw exception.\n\t */\n\tvar ConsoleLoggerImpl = (function (_super) {\n\t    __extends(ConsoleLoggerImpl, _super);\n\t    function ConsoleLoggerImpl(name, rule) {\n\t        _super.call(this, name, rule);\n\t    }\n\t    ConsoleLoggerImpl.prototype.doLog = function (msg) {\n\t        if (console !== undefined) {\n\t            console.log(msg);\n\t        }\n\t        else {\n\t            throw new Error(\"Console is not defined, cannot log msg: \" + msg);\n\t        }\n\t    };\n\t    return ConsoleLoggerImpl;\n\t}(AbstractLogger));\n\texports.ConsoleLoggerImpl = ConsoleLoggerImpl;\n\t/**\n\t * Logger which buffers all messages, use with care due to possible high memory footprint.\n\t * Can be convenient in some cases. Call toString() for full output, or cast to this class\n\t * and call getMessages() to do something with it yourself.\n\t */\n\tvar MessageBufferLoggerImpl = (function (_super) {\n\t    __extends(MessageBufferLoggerImpl, _super);\n\t    function MessageBufferLoggerImpl(name, rule) {\n\t        _super.call(this, name, rule);\n\t        this.messages = [];\n\t    }\n\t    MessageBufferLoggerImpl.prototype.doLog = function (msg) {\n\t        this.messages.push(msg);\n\t    };\n\t    MessageBufferLoggerImpl.prototype.close = function () {\n\t        this.messages = [];\n\t        _super.prototype.close.call(this);\n\t    };\n\t    MessageBufferLoggerImpl.prototype.getMessages = function () {\n\t        return this.messages;\n\t    };\n\t    MessageBufferLoggerImpl.prototype.toString = function () {\n\t        return this.messages.map(function (msg) {\n\t            return msg;\n\t        }).join(\"\\n\");\n\t    };\n\t    return MessageBufferLoggerImpl;\n\t}(AbstractLogger));\n\texports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;\n\t//# sourceMappingURL=LoggerImpl.js.map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Logger_1 = __webpack_require__(1);\n\tvar LoggerImpl_1 = __webpack_require__(2);\n\t/**\n\t * Defines several date enums used for formatting a date.\n\t */\n\t(function (DateFormatEnum) {\n\t    /**\n\t     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"Default\"] = 0] = \"Default\";\n\t    /**\n\t     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearMonthDayTime\"] = 1] = \"YearMonthDayTime\";\n\t    /**\n\t     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearDayMonthWithFullTime\"] = 2] = \"YearDayMonthWithFullTime\";\n\t    /**\n\t     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearDayMonthTime\"] = 3] = \"YearDayMonthTime\";\n\t})(exports.DateFormatEnum || (exports.DateFormatEnum = {}));\n\tvar DateFormatEnum = exports.DateFormatEnum;\n\t/**\n\t * DateFormat class, stores data on how to format a date.\n\t */\n\tvar DateFormat = (function () {\n\t    /**\n\t     * Constructor, can be called empty as it uses defaults.\n\t     * @param formatEnum DateFormatEnum\n\t     * @param dateSeparator Separator used between dates\n\t     */\n\t    function DateFormat(formatEnum, dateSeparator) {\n\t        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }\n\t        if (dateSeparator === void 0) { dateSeparator = '-'; }\n\t        this._formatEnum = formatEnum;\n\t        this._dateSeparator = dateSeparator;\n\t    }\n\t    Object.defineProperty(DateFormat.prototype, \"formatEnum\", {\n\t        get: function () {\n\t            return this._formatEnum;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(DateFormat.prototype, \"dateSeparator\", {\n\t        get: function () {\n\t            return this._dateSeparator;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return DateFormat;\n\t}());\n\texports.DateFormat = DateFormat;\n\t/**\n\t * Information about the log format, what will a log line look like?\n\t */\n\tvar LogFormat = (function () {\n\t    /**\n\t     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.\n\t     * @param dateFormat DateFormat (what needs the date look like in the log line)\n\t     * @param showTimeStamp Show date timestamp at all?\n\t     * @param showLoggerName Show the logger name?\n\t     */\n\t    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {\n\t        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n\t        if (showTimeStamp === void 0) { showTimeStamp = true; }\n\t        if (showLoggerName === void 0) { showLoggerName = true; }\n\t        this._showTimeStamp = true;\n\t        this._showLoggerName = true;\n\t        this._dateFormat = dateFormat;\n\t        this._showTimeStamp = showTimeStamp;\n\t        this._showLoggerName = showLoggerName;\n\t    }\n\t    Object.defineProperty(LogFormat.prototype, \"dateFormat\", {\n\t        get: function () {\n\t            return this._dateFormat;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogFormat.prototype, \"showTimeStamp\", {\n\t        get: function () {\n\t            return this._showTimeStamp;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogFormat.prototype, \"showLoggerName\", {\n\t        get: function () {\n\t            return this._showLoggerName;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LogFormat;\n\t}());\n\texports.LogFormat = LogFormat;\n\t/**\n\t * Defines a LogGroupRule, this allows you to either have everything configured the same way\n\t * or for example loggers that start with name model. It allows you to group loggers together\n\t * to have a certain loglevel and other settings. You can configure this when creating the\n\t * LoggerFactory (which accepts multiple LogGroupRules).\n\t */\n\tvar LogGroupRule = (function () {\n\t    /**\n\t     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n\t     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n\t     * @param regExp Regular expression, what matches for your logger names for this group\n\t     * @param level LogLevel\n\t     * @param logFormat LogFormat\n\t     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n\t     * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n\t     */\n\t    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n\t        if (logFormat === void 0) { logFormat = new LogFormat(); }\n\t        if (loggerType === void 0) { loggerType = Logger_1.LoggerType.Console; }\n\t        this._regExp = regExp;\n\t        this._level = level;\n\t        this._logFormat = logFormat;\n\t        this._loggerType = loggerType;\n\t        this._callBackLogger = callBackLogger;\n\t    }\n\t    Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n\t        get: function () {\n\t            return this._regExp;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"level\", {\n\t        get: function () {\n\t            return this._level;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n\t        get: function () {\n\t            return this._loggerType;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n\t        get: function () {\n\t            return this._logFormat;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n\t        get: function () {\n\t            return this._callBackLogger;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LogGroupRule;\n\t}());\n\texports.LogGroupRule = LogGroupRule;\n\t/**\n\t * Options object you can use to configure the LoggerFactory you create at LFService.\n\t */\n\tvar LoggerFactoryOptions = (function () {\n\t    function LoggerFactoryOptions() {\n\t        this._logGroupRules = [];\n\t        this._enabled = true;\n\t    }\n\t    /**\n\t     * Add LogGroupRule, see {LogGroupRule) for details\n\t     * @param rule Rule to add\n\t     * @returns {LoggerFactoryOptions} returns itself\n\t     */\n\t    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {\n\t        this._logGroupRules.push(rule);\n\t        return this;\n\t    };\n\t    /**\n\t     * Enable or disable logging completely for the LoggerFactory.\n\t     * @param enabled True for enabled (default)\n\t     * @returns {LoggerFactoryOptions} returns itself\n\t     */\n\t    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {\n\t        this._enabled = enabled;\n\t        return this;\n\t    };\n\t    Object.defineProperty(LoggerFactoryOptions.prototype, \"logGroupRules\", {\n\t        get: function () {\n\t            return this._logGroupRules;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LoggerFactoryOptions.prototype, \"enabled\", {\n\t        get: function () {\n\t            return this._enabled;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LoggerFactoryOptions;\n\t}());\n\texports.LoggerFactoryOptions = LoggerFactoryOptions;\n\tvar LoggerFactoryImpl = (function () {\n\t    function LoggerFactoryImpl(options) {\n\t        this.loggers = {};\n\t        this.configure(options);\n\t    }\n\t    LoggerFactoryImpl.prototype.configure = function (options) {\n\t        this.options = options;\n\t        // Close any current open loggers.\n\t        this.closeLoggers();\n\t    };\n\t    LoggerFactoryImpl.prototype.getLogger = function (named) {\n\t        if (!this.options.enabled) {\n\t            throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n\t        }\n\t        var logger = this.loggers[named];\n\t        if (logger !== undefined) {\n\t            return logger;\n\t        }\n\t        // Initialize logger with appropriate level\n\t        logger = this.loadLogger(named);\n\t        this.loggers[named] = logger;\n\t        return logger;\n\t    };\n\t    LoggerFactoryImpl.prototype.isEnabled = function () {\n\t        return this.options.enabled;\n\t    };\n\t    LoggerFactoryImpl.prototype.closeLoggers = function () {\n\t        for (var key in this.loggers) {\n\t            this.loggers[key].close();\n\t        }\n\t        this.loggers = {};\n\t    };\n\t    LoggerFactoryImpl.prototype.loadLogger = function (named) {\n\t        var logGroupRules = this.options.logGroupRules;\n\t        for (var i = 0; i < logGroupRules.length; i++) {\n\t            var logGroupRule = logGroupRules[i];\n\t            if (logGroupRule.regExp.test(named)) {\n\t                switch (logGroupRule.loggerType) {\n\t                    case Logger_1.LoggerType.Console:\n\t                        return new LoggerImpl_1.ConsoleLoggerImpl(named, logGroupRule);\n\t                    case Logger_1.LoggerType.MessageBuffer:\n\t                        return new LoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRule);\n\t                    case Logger_1.LoggerType.Custom:\n\t                        return logGroupRule.callBackLogger(named, logGroupRule);\n\t                    default:\n\t                        throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n\t                }\n\t            }\n\t        }\n\t        throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n\t    };\n\t    return LoggerFactoryImpl;\n\t}());\n\t/**\n\t * Create and configure your LoggerFactory from here.\n\t */\n\tvar LFService = (function () {\n\t    function LFService() {\n\t    }\n\t    /**\n\t     * Create a new LoggerFactory with given options (if any). If no options\n\t     * are specified, the LoggerFactory, will accept any named logger and will\n\t     * log on info level by default for, to the console.\n\t     * @param options Options, optional.\n\t     * @returns {LoggerFactory}\n\t     */\n\t    LFService.createLoggerFactory = function (options) {\n\t        var factory;\n\t        if (options !== undefined) {\n\t            factory = new LoggerFactoryImpl(options);\n\t        }\n\t        else {\n\t            factory = new LoggerFactoryImpl(this.createDefaultOptions());\n\t        }\n\t        return factory;\n\t    };\n\t    /**\n\t     * Closes all Loggers for LoggerFactories that were created.\n\t     * After this call, all previously fetched Loggers (from their\n\t     * factories) are unusable. The factories remain as they were.\n\t     */\n\t    LFService.closeLoggers = function () {\n\t        for (var i = 0; i < this._loggerFactories.length; i++) {\n\t            this._loggerFactories[i].closeLoggers();\n\t        }\n\t        this._loggerFactories = [];\n\t    };\n\t    LFService.createDefaultOptions = function () {\n\t        return new LoggerFactoryOptions().addLogGroupRule(new LogGroupRule(new RegExp(\".+\"), Logger_1.LogLevel.Info));\n\t    };\n\t    LFService._loggerFactories = [];\n\t    return LFService;\n\t}());\n\texports.LFService = LFService;\n\t//# sourceMappingURL=LoggerFactoryService.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5), __webpack_require__(7), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n\t    } else {\n\t        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n\t    }\n\t}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n\t    var _options = {\n\t        filter: function(stackframe) {\n\t            // Filter out stackframes for this library by default\n\t            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n\t        },\n\t        sourceCache: {}\n\t    };\n\t\n\t    var _generateError = function StackTrace$$GenerateError() {\n\t        try {\n\t            // Error must be thrown to get stack in IE\n\t            throw new Error();\n\t        } catch (err) {\n\t            return err;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Merge 2 given Objects. If a conflict occurs the second object wins.\n\t     * Does not do deep merges.\n\t     *\n\t     * @param {Object} first base object\n\t     * @param {Object} second overrides\n\t     * @returns {Object} merged first and second\n\t     * @private\n\t     */\n\t    function _merge(first, second) {\n\t        var target = {};\n\t\n\t        [first, second].forEach(function(obj) {\n\t            for (var prop in obj) {\n\t                if (obj.hasOwnProperty(prop)) {\n\t                    target[prop] = obj[prop];\n\t                }\n\t            }\n\t            return target;\n\t        });\n\t\n\t        return target;\n\t    }\n\t\n\t    function _isShapedLikeParsableError(err) {\n\t        return err.stack || err['opera#sourceloc'];\n\t    }\n\t\n\t    function _filtered(stackframes, filter) {\n\t        if (typeof filter === 'function') {\n\t            return stackframes.filter(filter);\n\t        }\n\t        return stackframes;\n\t    }\n\t\n\t    return {\n\t        /**\n\t         * Get a backtrace from invocation point.\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Array} of StackFrame\n\t         */\n\t        get: function StackTrace$$get(opts) {\n\t            var err = _generateError();\n\t            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n\t        },\n\t\n\t        /**\n\t         * Get a backtrace from invocation point.\n\t         * IMPORTANT: Does not handle source maps or guess function names!\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Array} of StackFrame\n\t         */\n\t        getSync: function StackTrace$$getSync(opts) {\n\t            opts = _merge(_options, opts);\n\t            var err = _generateError();\n\t            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n\t            return _filtered(stack, opts.filter);\n\t        },\n\t\n\t        /**\n\t         * Given an error object, parse it.\n\t         *\n\t         * @param {Error} error object\n\t         * @param {Object} opts\n\t         * @returns {Promise} for Array[StackFrame}\n\t         */\n\t        fromError: function StackTrace$$fromError(error, opts) {\n\t            opts = _merge(_options, opts);\n\t            var gps = new StackTraceGPS(opts);\n\t            return new Promise(function(resolve) {\n\t                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n\t                resolve(Promise.all(stackframes.map(function(sf) {\n\t                    return new Promise(function(resolve) {\n\t                        function resolveOriginal() {\n\t                            resolve(sf);\n\t                        }\n\t\n\t                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n\t                    });\n\t                })));\n\t            }.bind(this));\n\t        },\n\t\n\t        /**\n\t         * Use StackGenerator to generate a backtrace.\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Promise} of Array[StackFrame]\n\t         */\n\t        generateArtificially: function StackTrace$$generateArtificially(opts) {\n\t            opts = _merge(_options, opts);\n\t            var stackFrames = StackGenerator.backtrace(opts);\n\t            if (typeof opts.filter === 'function') {\n\t                stackFrames = stackFrames.filter(opts.filter);\n\t            }\n\t            return Promise.resolve(stackFrames);\n\t        },\n\t\n\t        /**\n\t         * Given a function, wrap it such that invocations trigger a callback that\n\t         * is called with a stack trace.\n\t         *\n\t         * @param {Function} fn to be instrumented\n\t         * @param {Function} callback function to call with a stack trace on invocation\n\t         * @param {Function} errback optional function to call with error if unable to get stack trace.\n\t         * @param {Object} thisArg optional context object (e.g. window)\n\t         */\n\t        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n\t            if (typeof fn !== 'function') {\n\t                throw new Error('Cannot instrument non-function object');\n\t            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n\t                // Already instrumented, return given Function\n\t                return fn;\n\t            }\n\t\n\t            var instrumented = function StackTrace$$instrumented() {\n\t                try {\n\t                    this.get().then(callback, errback)['catch'](errback);\n\t                    return fn.apply(thisArg || this, arguments);\n\t                } catch (e) {\n\t                    if (_isShapedLikeParsableError(e)) {\n\t                        this.fromError(e).then(callback, errback)['catch'](errback);\n\t                    }\n\t                    throw e;\n\t                }\n\t            }.bind(this);\n\t            instrumented.__stacktraceOriginalFn = fn;\n\t\n\t            return instrumented;\n\t        },\n\t\n\t        /**\n\t         * Given a function that has been instrumented,\n\t         * revert the function to it's original (non-instrumented) state.\n\t         *\n\t         * @param {Function} fn to de-instrument\n\t         */\n\t        deinstrument: function StackTrace$$deinstrument(fn) {\n\t            if (typeof fn !== 'function') {\n\t                throw new Error('Cannot de-instrument non-function object');\n\t            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n\t                return fn.__stacktraceOriginalFn;\n\t            } else {\n\t                // Function not instrumented, return original\n\t                return fn;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n\t         *\n\t         * @param {Array} stackframes\n\t         * @param {String} url\n\t         * @param {String} errorMsg\n\t         */\n\t        report: function StackTrace$$report(stackframes, url, errorMsg) {\n\t            return new Promise(function(resolve, reject) {\n\t                var req = new XMLHttpRequest();\n\t                req.onerror = reject;\n\t                req.onreadystatechange = function onreadystatechange() {\n\t                    if (req.readyState === 4) {\n\t                        if (req.status >= 200 && req.status < 400) {\n\t                            resolve(req.responseText);\n\t                        } else {\n\t                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n\t                        }\n\t                    }\n\t                };\n\t                req.open('post', url);\n\t                req.setRequestHeader('Content-Type', 'application/json');\n\t\n\t                var reportPayload = {stack: stackframes};\n\t                if (errorMsg !== undefined) {\n\t                    reportPayload.message = errorMsg;\n\t                }\n\t\n\t                req.send(JSON.stringify(reportPayload));\n\t            });\n\t        }\n\t    };\n\t}));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.ErrorStackParser = factory(root.StackFrame);\n\t    }\n\t}(this, function ErrorStackParser(StackFrame) {\n\t    'use strict';\n\t\n\t    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n\t    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n\t    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\t\n\t    function _map(array, fn, thisArg) {\n\t        if (typeof Array.prototype.map === 'function') {\n\t            return array.map(fn, thisArg);\n\t        } else {\n\t            var output = new Array(array.length);\n\t            for (var i = 0; i < array.length; i++) {\n\t                output[i] = fn.call(thisArg, array[i]);\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    function _filter(array, fn, thisArg) {\n\t        if (typeof Array.prototype.filter === 'function') {\n\t            return array.filter(fn, thisArg);\n\t        } else {\n\t            var output = [];\n\t            for (var i = 0; i < array.length; i++) {\n\t                if (fn.call(thisArg, array[i])) {\n\t                    output.push(array[i]);\n\t                }\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    function _indexOf(array, target) {\n\t        if (typeof Array.prototype.indexOf === 'function') {\n\t            return array.indexOf(target);\n\t        } else {\n\t            for (var i = 0; i < array.length; i++) {\n\t                if (array[i] === target) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    return {\n\t        /**\n\t         * Given an Error object, extract the most information from it.\n\t         *\n\t         * @param {Error} error object\n\t         * @return {Array} of StackFrames\n\t         */\n\t        parse: function ErrorStackParser$$parse(error) {\n\t            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n\t                return this.parseOpera(error);\n\t            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n\t                return this.parseV8OrIE(error);\n\t            } else if (error.stack) {\n\t                return this.parseFFOrSafari(error);\n\t            } else {\n\t                throw new Error('Cannot parse given Error object');\n\t            }\n\t        },\n\t\n\t        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n\t        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n\t            // Fail-fast but return locations like \"(native)\"\n\t            if (urlLike.indexOf(':') === -1) {\n\t                return [urlLike];\n\t            }\n\t\n\t            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n\t            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n\t            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n\t        },\n\t\n\t        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !!line.match(CHROME_IE_STACK_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                if (line.indexOf('(eval ') > -1) {\n\t                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n\t                }\n\t                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionName = tokens.join(' ') || undefined;\n\t                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\t\n\t                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n\t            }, this);\n\t        },\n\t\n\t        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                if (line.indexOf(' > eval') > -1) {\n\t                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n\t                }\n\t\n\t                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n\t                    // Safari eval frames only have function names and nothing else\n\t                    return new StackFrame(line);\n\t                } else {\n\t                    var tokens = line.split('@');\n\t                    var locationParts = this.extractLocation(tokens.pop());\n\t                    var functionName = tokens.join('@') || undefined;\n\t                    return new StackFrame(functionName,\n\t                        undefined,\n\t                        locationParts[0],\n\t                        locationParts[1],\n\t                        locationParts[2],\n\t                        line);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        parseOpera: function ErrorStackParser$$parseOpera(e) {\n\t            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n\t                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n\t                return this.parseOpera9(e);\n\t            } else if (!e.stack) {\n\t                return this.parseOpera10(e);\n\t            } else {\n\t                return this.parseOpera11(e);\n\t            }\n\t        },\n\t\n\t        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(\n\t                        new StackFrame(\n\t                            match[3] || undefined,\n\t                            undefined,\n\t                            match[2],\n\t                            match[1],\n\t                            undefined,\n\t                            lines[i]\n\t                        )\n\t                    );\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 10.65+ Error.stack very similar to FF/Safari\n\t        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                var tokens = line.split('@');\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionCall = (tokens.shift() || '');\n\t                var functionName = functionCall\n\t                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n\t                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n\t                var argsRaw;\n\t                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n\t                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n\t                }\n\t                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n\t                    undefined : argsRaw.split(',');\n\t                return new StackFrame(\n\t                    functionName,\n\t                    args,\n\t                    locationParts[0],\n\t                    locationParts[1],\n\t                    locationParts[2],\n\t                    line);\n\t            }, this);\n\t        }\n\t    };\n\t}));\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n\t        if (functionName !== undefined) {\n\t            this.setFunctionName(functionName);\n\t        }\n\t        if (args !== undefined) {\n\t            this.setArgs(args);\n\t        }\n\t        if (fileName !== undefined) {\n\t            this.setFileName(fileName);\n\t        }\n\t        if (lineNumber !== undefined) {\n\t            this.setLineNumber(lineNumber);\n\t        }\n\t        if (columnNumber !== undefined) {\n\t            this.setColumnNumber(columnNumber);\n\t        }\n\t        if (source !== undefined) {\n\t            this.setSource(source);\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getFunctionName: function () {\n\t            return this.functionName;\n\t        },\n\t        setFunctionName: function (v) {\n\t            this.functionName = String(v);\n\t        },\n\t\n\t        getArgs: function () {\n\t            return this.args;\n\t        },\n\t        setArgs: function (v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        // NOTE: Property name may be misleading as it includes the path,\n\t        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n\t        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n\t        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n\t        getFileName: function () {\n\t            return this.fileName;\n\t        },\n\t        setFileName: function (v) {\n\t            this.fileName = String(v);\n\t        },\n\t\n\t        getLineNumber: function () {\n\t            return this.lineNumber;\n\t        },\n\t        setLineNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Line Number must be a Number');\n\t            }\n\t            this.lineNumber = Number(v);\n\t        },\n\t\n\t        getColumnNumber: function () {\n\t            return this.columnNumber;\n\t        },\n\t        setColumnNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Column Number must be a Number');\n\t            }\n\t            this.columnNumber = Number(v);\n\t        },\n\t\n\t        getSource: function () {\n\t            return this.source;\n\t        },\n\t        setSource: function (v) {\n\t            this.source = String(v);\n\t        },\n\t\n\t        toString: function() {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.StackGenerator = factory(root.StackFrame);\n\t    }\n\t}(this, function (StackFrame) {\n\t    return {\n\t        backtrace: function StackGenerator$$backtrace(opts) {\n\t            var stack = [];\n\t            var maxStackSize = 10;\n\t\n\t            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n\t                maxStackSize = opts.maxStackSize;\n\t            }\n\t\n\t            var curr = arguments.callee;\n\t            while (curr && stack.length < maxStackSize) {\n\t                // Allow V8 optimizations\n\t                var args = new Array(curr['arguments'].length);\n\t                for(var i = 0; i < args.length; ++i) {\n\t                    args[i] = curr['arguments'][i];\n\t                }\n\t                if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n\t                    stack.push(new StackFrame(RegExp.$1 || undefined, args));\n\t                } else {\n\t                    stack.push(new StackFrame(undefined, args));\n\t                }\n\t\n\t                try {\n\t                    curr = curr.caller;\n\t                } catch (e) {\n\t                    break;\n\t                }\n\t            }\n\t            return stack;\n\t        }\n\t    };\n\t}));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n\t    } else {\n\t        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n\t    }\n\t}(this, function(SourceMap, StackFrame) {\n\t    'use strict';\n\t\n\t    /**\n\t     * Make a X-Domain request to url and callback.\n\t     *\n\t     * @param {String} url\n\t     * @returns {Promise} with response text if fulfilled\n\t     */\n\t    function _xdr(url) {\n\t        return new Promise(function(resolve, reject) {\n\t            var req = new XMLHttpRequest();\n\t            req.open('get', url);\n\t            req.onerror = reject;\n\t            req.onreadystatechange = function onreadystatechange() {\n\t                if (req.readyState === 4) {\n\t                    if (req.status >= 200 && req.status < 300) {\n\t                        resolve(req.responseText);\n\t                    } else {\n\t                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n\t                    }\n\t                }\n\t            };\n\t            req.send();\n\t        });\n\t\n\t    }\n\t\n\t    /**\n\t     * Convert a Base64-encoded string into its original representation.\n\t     * Used for inline sourcemaps.\n\t     *\n\t     * @param {String} b64str Base-64 encoded string\n\t     * @returns {String} original representation of the base64-encoded string.\n\t     */\n\t    function _atob(b64str) {\n\t        if (typeof window !== 'undefined' && window.atob) {\n\t            return window.atob(b64str);\n\t        } else {\n\t            throw new Error('You must supply a polyfill for window.atob in this environment');\n\t        }\n\t    }\n\t\n\t    function _parseJson(string) {\n\t        if (typeof JSON !== 'undefined' && JSON.parse) {\n\t            return JSON.parse(string);\n\t        } else {\n\t            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n\t        }\n\t    }\n\t\n\t    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n\t        // function {name}({args}) m[1]=name m[2]=args\n\t        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n\t        // {name} = function ({args}) TODO args capture\n\t        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n\t        // {name} = eval()\n\t        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n\t        var lines = source.split('\\n');\n\t\n\t        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n\t        var code = '';\n\t        var maxLines = Math.min(lineNumber, 20);\n\t        var m;\n\t        for (var i = 0; i < maxLines; ++i) {\n\t            // lineNo is 1-based, source[] is 0-based\n\t            var line = lines[lineNumber - i - 1];\n\t            var commentPos = line.indexOf('//');\n\t            if (commentPos >= 0) {\n\t                line = line.substr(0, commentPos);\n\t            }\n\t\n\t            if (line) {\n\t                code = line + code;\n\t                m = reFunctionExpression.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t                m = reFunctionDeclaration.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t                m = reFunctionEvaluation.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t            }\n\t        }\n\t        return undefined;\n\t    }\n\t\n\t    function _ensureSupportedEnvironment() {\n\t        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n\t            throw new Error('Unable to consume source maps in older browsers');\n\t        }\n\t    }\n\t\n\t    function _ensureStackFrameIsLegit(stackframe) {\n\t        if (typeof stackframe !== 'object') {\n\t            throw new TypeError('Given StackFrame is not an object');\n\t        } else if (typeof stackframe.fileName !== 'string') {\n\t            throw new TypeError('Given file name is not a String');\n\t        } else if (typeof stackframe.lineNumber !== 'number' ||\n\t            stackframe.lineNumber % 1 !== 0 ||\n\t            stackframe.lineNumber < 1) {\n\t            throw new TypeError('Given line number must be a positive integer');\n\t        } else if (typeof stackframe.columnNumber !== 'number' ||\n\t            stackframe.columnNumber % 1 !== 0 ||\n\t            stackframe.columnNumber < 0) {\n\t            throw new TypeError('Given column number must be a non-negative integer');\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function _findSourceMappingURL(source) {\n\t        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n\t        if (m && m[1]) {\n\t            return m[1];\n\t        } else {\n\t            throw new Error('sourceMappingURL not found');\n\t        }\n\t    }\n\t\n\t    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n\t        return new Promise(function(resolve, reject) {\n\t            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\t\n\t            var loc = mapConsumer.originalPositionFor({\n\t                line: stackframe.lineNumber,\n\t                column: stackframe.columnNumber\n\t            });\n\t\n\t            if (loc.source) {\n\t                var mappedSource = mapConsumer.sourceContentFor(loc.source);\n\t                if (mappedSource) {\n\t                    sourceCache[loc.source] = mappedSource;\n\t                }\n\t                resolve(\n\t                    new StackFrame(\n\t                        loc.name || stackframe.functionName,\n\t                        stackframe.args,\n\t                        loc.source,\n\t                        loc.line,\n\t                        loc.column));\n\t            } else {\n\t                reject(new Error('Could not get original source for given stackframe and source map'));\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {Object} opts\n\t     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n\t     *      opts.offline = True to prevent network requests.\n\t     *              Best effort without sources or source maps.\n\t     *      opts.ajax = Promise returning function to make X-Domain requests\n\t     */\n\t    return function StackTraceGPS(opts) {\n\t        if (!(this instanceof StackTraceGPS)) {\n\t            return new StackTraceGPS(opts);\n\t        }\n\t        opts = opts || {};\n\t\n\t        this.sourceCache = opts.sourceCache || {};\n\t\n\t        this.ajax = opts.ajax || _xdr;\n\t\n\t        this._atob = opts.atob || _atob;\n\t\n\t        this._get = function _get(location) {\n\t            return new Promise(function(resolve, reject) {\n\t                var isDataUrl = location.substr(0, 5) === 'data:';\n\t                if (this.sourceCache[location]) {\n\t                    resolve(this.sourceCache[location]);\n\t                } else if (opts.offline && !isDataUrl) {\n\t                    reject(new Error('Cannot make network requests in offline mode'));\n\t                } else {\n\t                    if (isDataUrl) {\n\t                        // data URLs can have parameters.\n\t                        // see http://tools.ietf.org/html/rfc2397\n\t                        var supportedEncodingRegexp =\n\t                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n\t                        var match = location.match(supportedEncodingRegexp);\n\t                        if (match) {\n\t                            var sourceMapStart = match[0].length;\n\t                            var encodedSource = location.substr(sourceMapStart);\n\t                            var source = this._atob(encodedSource);\n\t                            this.sourceCache[location] = source;\n\t                            resolve(source);\n\t                        } else {\n\t                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n\t                        }\n\t                    } else {\n\t                        var xhrPromise = this.ajax(location, {method: 'get'});\n\t                        // Cache the Promise to prevent duplicate in-flight requests\n\t                        this.sourceCache[location] = xhrPromise;\n\t                        xhrPromise.then(resolve, reject);\n\t                    }\n\t                }\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, enhance function name and use source maps for a\n\t         * better StackFrame.\n\t         *\n\t         * @param {StackFrame} stackframe object\n\t         * @returns {Promise} that resolves with with source-mapped StackFrame\n\t         */\n\t        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n\t                    function resolveMappedStackFrame() {\n\t                        resolve(mappedStackFrame);\n\t                    }\n\t\n\t                    this.findFunctionName(mappedStackFrame)\n\t                        .then(resolve, resolveMappedStackFrame)\n\t                        ['catch'](resolveMappedStackFrame);\n\t                }.bind(this), reject);\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, guess function name from location information.\n\t         *\n\t         * @param {StackFrame} stackframe\n\t         * @returns {Promise} that resolves with enhanced StackFrame.\n\t         */\n\t        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                _ensureStackFrameIsLegit(stackframe);\n\t                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n\t                    var lineNumber = stackframe.lineNumber;\n\t                    var columnNumber = stackframe.columnNumber;\n\t                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n\t                    // Only replace functionName if we found something\n\t                    if (guessedFunctionName) {\n\t                        resolve(new StackFrame(guessedFunctionName,\n\t                            stackframe.args,\n\t                            stackframe.fileName,\n\t                            lineNumber,\n\t                            columnNumber));\n\t                    } else {\n\t                        resolve(stackframe);\n\t                    }\n\t                }, reject)['catch'](reject);\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n\t         *\n\t         * @param {StackFrame} stackframe\n\t         * @returns {Promise} that resolves with enhanced StackFrame.\n\t         */\n\t        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                _ensureSupportedEnvironment();\n\t                _ensureStackFrameIsLegit(stackframe);\n\t\n\t                var sourceCache = this.sourceCache;\n\t                var fileName = stackframe.fileName;\n\t                this._get(fileName).then(function(source) {\n\t                    var sourceMappingURL = _findSourceMappingURL(source);\n\t                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n\t                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\t\n\t                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n\t                        sourceMappingURL = base + sourceMappingURL;\n\t                    }\n\t\n\t                    this._get(sourceMappingURL).then(function(sourceMap) {\n\t                        if (typeof sourceMap === 'string') {\n\t                            sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n\t                        }\n\t                        if (typeof sourceMap.sourceRoot === 'undefined') {\n\t                            sourceMap.sourceRoot = base;\n\t                        }\n\t\n\t                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)\n\t                            .then(resolve)['catch'](function() {\n\t                            resolve(stackframe);\n\t                        });\n\t                    }, reject)['catch'](reject);\n\t                }.bind(this), reject)['catch'](reject);\n\t            }.bind(this));\n\t        };\n\t    };\n\t}));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2009-2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE.txt or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\texports.SourceMapGenerator = __webpack_require__(10).SourceMapGenerator;\n\texports.SourceMapConsumer = __webpack_require__(16).SourceMapConsumer;\n\texports.SourceNode = __webpack_require__(19).SourceNode;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar base64VLQ = __webpack_require__(11);\n\tvar util = __webpack_require__(13);\n\tvar ArraySet = __webpack_require__(14).ArraySet;\n\tvar MappingList = __webpack_require__(15).MappingList;\n\t\n\t/**\n\t * An instance of the SourceMapGenerator represents a source map which is\n\t * being built incrementally. You may pass an object with the following\n\t * properties:\n\t *\n\t *   - file: The filename of the generated source.\n\t *   - sourceRoot: A root for all relative URLs in this source map.\n\t */\n\tfunction SourceMapGenerator(aArgs) {\n\t  if (!aArgs) {\n\t    aArgs = {};\n\t  }\n\t  this._file = util.getArg(aArgs, 'file', null);\n\t  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n\t  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t  this._mappings = new MappingList();\n\t  this._sourcesContents = null;\n\t}\n\t\n\tSourceMapGenerator.prototype._version = 3;\n\t\n\t/**\n\t * Creates a new SourceMapGenerator based on a SourceMapConsumer\n\t *\n\t * @param aSourceMapConsumer The SourceMap.\n\t */\n\tSourceMapGenerator.fromSourceMap =\n\t  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n\t    var sourceRoot = aSourceMapConsumer.sourceRoot;\n\t    var generator = new SourceMapGenerator({\n\t      file: aSourceMapConsumer.file,\n\t      sourceRoot: sourceRoot\n\t    });\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      var newMapping = {\n\t        generated: {\n\t          line: mapping.generatedLine,\n\t          column: mapping.generatedColumn\n\t        }\n\t      };\n\t\n\t      if (mapping.source != null) {\n\t        newMapping.source = mapping.source;\n\t        if (sourceRoot != null) {\n\t          newMapping.source = util.relative(sourceRoot, newMapping.source);\n\t        }\n\t\n\t        newMapping.original = {\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        };\n\t\n\t        if (mapping.name != null) {\n\t          newMapping.name = mapping.name;\n\t        }\n\t      }\n\t\n\t      generator.addMapping(newMapping);\n\t    });\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        generator.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t    return generator;\n\t  };\n\t\n\t/**\n\t * Add a single mapping from original source line and column to the generated\n\t * source's line and column for this source map being created. The mapping\n\t * object should have the following properties:\n\t *\n\t *   - generated: An object with the generated line and column positions.\n\t *   - original: An object with the original line and column positions.\n\t *   - source: The original source file (relative to the sourceRoot).\n\t *   - name: An optional original token name for this mapping.\n\t */\n\tSourceMapGenerator.prototype.addMapping =\n\t  function SourceMapGenerator_addMapping(aArgs) {\n\t    var generated = util.getArg(aArgs, 'generated');\n\t    var original = util.getArg(aArgs, 'original', null);\n\t    var source = util.getArg(aArgs, 'source', null);\n\t    var name = util.getArg(aArgs, 'name', null);\n\t\n\t    if (!this._skipValidation) {\n\t      this._validateMapping(generated, original, source, name);\n\t    }\n\t\n\t    if (source != null) {\n\t      source = String(source);\n\t      if (!this._sources.has(source)) {\n\t        this._sources.add(source);\n\t      }\n\t    }\n\t\n\t    if (name != null) {\n\t      name = String(name);\n\t      if (!this._names.has(name)) {\n\t        this._names.add(name);\n\t      }\n\t    }\n\t\n\t    this._mappings.add({\n\t      generatedLine: generated.line,\n\t      generatedColumn: generated.column,\n\t      originalLine: original != null && original.line,\n\t      originalColumn: original != null && original.column,\n\t      source: source,\n\t      name: name\n\t    });\n\t  };\n\t\n\t/**\n\t * Set the source content for a source file.\n\t */\n\tSourceMapGenerator.prototype.setSourceContent =\n\t  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n\t    var source = aSourceFile;\n\t    if (this._sourceRoot != null) {\n\t      source = util.relative(this._sourceRoot, source);\n\t    }\n\t\n\t    if (aSourceContent != null) {\n\t      // Add the source content to the _sourcesContents map.\n\t      // Create a new _sourcesContents map if the property is null.\n\t      if (!this._sourcesContents) {\n\t        this._sourcesContents = Object.create(null);\n\t      }\n\t      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n\t    } else if (this._sourcesContents) {\n\t      // Remove the source file from the _sourcesContents map.\n\t      // If the _sourcesContents map is empty, set the property to null.\n\t      delete this._sourcesContents[util.toSetString(source)];\n\t      if (Object.keys(this._sourcesContents).length === 0) {\n\t        this._sourcesContents = null;\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Applies the mappings of a sub-source-map for a specific source file to the\n\t * source map being generated. Each mapping to the supplied source file is\n\t * rewritten using the supplied source map. Note: The resolution for the\n\t * resulting mappings is the minimium of this map and the supplied map.\n\t *\n\t * @param aSourceMapConsumer The source map to be applied.\n\t * @param aSourceFile Optional. The filename of the source file.\n\t *        If omitted, SourceMapConsumer's file property will be used.\n\t * @param aSourceMapPath Optional. The dirname of the path to the source map\n\t *        to be applied. If relative, it is relative to the SourceMapConsumer.\n\t *        This parameter is needed when the two source maps aren't in the same\n\t *        directory, and the source map to be applied contains relative source\n\t *        paths. If so, those relative source paths need to be rewritten\n\t *        relative to the SourceMapGenerator.\n\t */\n\tSourceMapGenerator.prototype.applySourceMap =\n\t  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t    var sourceFile = aSourceFile;\n\t    // If aSourceFile is omitted, we will use the file property of the SourceMap\n\t    if (aSourceFile == null) {\n\t      if (aSourceMapConsumer.file == null) {\n\t        throw new Error(\n\t          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n\t          'or the source map\\'s \"file\" property. Both were omitted.'\n\t        );\n\t      }\n\t      sourceFile = aSourceMapConsumer.file;\n\t    }\n\t    var sourceRoot = this._sourceRoot;\n\t    // Make \"sourceFile\" relative if an absolute Url is passed.\n\t    if (sourceRoot != null) {\n\t      sourceFile = util.relative(sourceRoot, sourceFile);\n\t    }\n\t    // Applying the SourceMap can add and remove items from the sources and\n\t    // the names array.\n\t    var newSources = new ArraySet();\n\t    var newNames = new ArraySet();\n\t\n\t    // Find mappings for the \"sourceFile\"\n\t    this._mappings.unsortedForEach(function (mapping) {\n\t      if (mapping.source === sourceFile && mapping.originalLine != null) {\n\t        // Check if it can be mapped by the source map, then update the mapping.\n\t        var original = aSourceMapConsumer.originalPositionFor({\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        });\n\t        if (original.source != null) {\n\t          // Copy mapping\n\t          mapping.source = original.source;\n\t          if (aSourceMapPath != null) {\n\t            mapping.source = util.join(aSourceMapPath, mapping.source)\n\t          }\n\t          if (sourceRoot != null) {\n\t            mapping.source = util.relative(sourceRoot, mapping.source);\n\t          }\n\t          mapping.originalLine = original.line;\n\t          mapping.originalColumn = original.column;\n\t          if (original.name != null) {\n\t            mapping.name = original.name;\n\t          }\n\t        }\n\t      }\n\t\n\t      var source = mapping.source;\n\t      if (source != null && !newSources.has(source)) {\n\t        newSources.add(source);\n\t      }\n\t\n\t      var name = mapping.name;\n\t      if (name != null && !newNames.has(name)) {\n\t        newNames.add(name);\n\t      }\n\t\n\t    }, this);\n\t    this._sources = newSources;\n\t    this._names = newNames;\n\t\n\t    // Copy sourcesContents of applied map.\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aSourceMapPath != null) {\n\t          sourceFile = util.join(aSourceMapPath, sourceFile);\n\t        }\n\t        if (sourceRoot != null) {\n\t          sourceFile = util.relative(sourceRoot, sourceFile);\n\t        }\n\t        this.setSourceContent(sourceFile, content);\n\t      }\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * A mapping can have one of the three levels of data:\n\t *\n\t *   1. Just the generated position.\n\t *   2. The Generated position, original position, and original source.\n\t *   3. Generated and original position, original source, as well as a name\n\t *      token.\n\t *\n\t * To maintain consistency, we validate that any new mapping being added falls\n\t * in to one of these categories.\n\t */\n\tSourceMapGenerator.prototype._validateMapping =\n\t  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n\t                                              aName) {\n\t    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t        && aGenerated.line > 0 && aGenerated.column >= 0\n\t        && !aOriginal && !aSource && !aName) {\n\t      // Case 1.\n\t      return;\n\t    }\n\t    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n\t             && aGenerated.line > 0 && aGenerated.column >= 0\n\t             && aOriginal.line > 0 && aOriginal.column >= 0\n\t             && aSource) {\n\t      // Cases 2 and 3.\n\t      return;\n\t    }\n\t    else {\n\t      throw new Error('Invalid mapping: ' + JSON.stringify({\n\t        generated: aGenerated,\n\t        source: aSource,\n\t        original: aOriginal,\n\t        name: aName\n\t      }));\n\t    }\n\t  };\n\t\n\t/**\n\t * Serialize the accumulated mappings in to the stream of base 64 VLQs\n\t * specified by the source map format.\n\t */\n\tSourceMapGenerator.prototype._serializeMappings =\n\t  function SourceMapGenerator_serializeMappings() {\n\t    var previousGeneratedColumn = 0;\n\t    var previousGeneratedLine = 1;\n\t    var previousOriginalColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousName = 0;\n\t    var previousSource = 0;\n\t    var result = '';\n\t    var next;\n\t    var mapping;\n\t    var nameIdx;\n\t    var sourceIdx;\n\t\n\t    var mappings = this._mappings.toArray();\n\t    for (var i = 0, len = mappings.length; i < len; i++) {\n\t      mapping = mappings[i];\n\t      next = ''\n\t\n\t      if (mapping.generatedLine !== previousGeneratedLine) {\n\t        previousGeneratedColumn = 0;\n\t        while (mapping.generatedLine !== previousGeneratedLine) {\n\t          next += ';';\n\t          previousGeneratedLine++;\n\t        }\n\t      }\n\t      else {\n\t        if (i > 0) {\n\t          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n\t            continue;\n\t          }\n\t          next += ',';\n\t        }\n\t      }\n\t\n\t      next += base64VLQ.encode(mapping.generatedColumn\n\t                                 - previousGeneratedColumn);\n\t      previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t      if (mapping.source != null) {\n\t        sourceIdx = this._sources.indexOf(mapping.source);\n\t        next += base64VLQ.encode(sourceIdx - previousSource);\n\t        previousSource = sourceIdx;\n\t\n\t        // lines are stored 0-based in SourceMap spec version 3\n\t        next += base64VLQ.encode(mapping.originalLine - 1\n\t                                   - previousOriginalLine);\n\t        previousOriginalLine = mapping.originalLine - 1;\n\t\n\t        next += base64VLQ.encode(mapping.originalColumn\n\t                                   - previousOriginalColumn);\n\t        previousOriginalColumn = mapping.originalColumn;\n\t\n\t        if (mapping.name != null) {\n\t          nameIdx = this._names.indexOf(mapping.name);\n\t          next += base64VLQ.encode(nameIdx - previousName);\n\t          previousName = nameIdx;\n\t        }\n\t      }\n\t\n\t      result += next;\n\t    }\n\t\n\t    return result;\n\t  };\n\t\n\tSourceMapGenerator.prototype._generateSourcesContent =\n\t  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n\t    return aSources.map(function (source) {\n\t      if (!this._sourcesContents) {\n\t        return null;\n\t      }\n\t      if (aSourceRoot != null) {\n\t        source = util.relative(aSourceRoot, source);\n\t      }\n\t      var key = util.toSetString(source);\n\t      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n\t        ? this._sourcesContents[key]\n\t        : null;\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * Externalize the source map.\n\t */\n\tSourceMapGenerator.prototype.toJSON =\n\t  function SourceMapGenerator_toJSON() {\n\t    var map = {\n\t      version: this._version,\n\t      sources: this._sources.toArray(),\n\t      names: this._names.toArray(),\n\t      mappings: this._serializeMappings()\n\t    };\n\t    if (this._file != null) {\n\t      map.file = this._file;\n\t    }\n\t    if (this._sourceRoot != null) {\n\t      map.sourceRoot = this._sourceRoot;\n\t    }\n\t    if (this._sourcesContents) {\n\t      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n\t    }\n\t\n\t    return map;\n\t  };\n\t\n\t/**\n\t * Render the source map being generated to a string.\n\t */\n\tSourceMapGenerator.prototype.toString =\n\t  function SourceMapGenerator_toString() {\n\t    return JSON.stringify(this.toJSON());\n\t  };\n\t\n\texports.SourceMapGenerator = SourceMapGenerator;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tvar base64 = __webpack_require__(12);\n\t\n\t// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t// length quantities we use in the source map spec, the first bit is the sign,\n\t// the next four bits are the actual value, and the 6th bit is the\n\t// continuation bit. The continuation bit tells us whether there are more\n\t// digits in this value following this digit.\n\t//\n\t//   Continuation\n\t//   |    Sign\n\t//   |    |\n\t//   V    V\n\t//   101011\n\t\n\tvar VLQ_BASE_SHIFT = 5;\n\t\n\t// binary: 100000\n\tvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\t\n\t// binary: 011111\n\tvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\t\n\t// binary: 100000\n\tvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\t\n\t/**\n\t * Converts from a two-complement value to a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t */\n\tfunction toVLQSigned(aValue) {\n\t  return aValue < 0\n\t    ? ((-aValue) << 1) + 1\n\t    : (aValue << 1) + 0;\n\t}\n\t\n\t/**\n\t * Converts to a two-complement value from a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t */\n\tfunction fromVLQSigned(aValue) {\n\t  var isNegative = (aValue & 1) === 1;\n\t  var shifted = aValue >> 1;\n\t  return isNegative\n\t    ? -shifted\n\t    : shifted;\n\t}\n\t\n\t/**\n\t * Returns the base 64 VLQ encoded value.\n\t */\n\texports.encode = function base64VLQ_encode(aValue) {\n\t  var encoded = \"\";\n\t  var digit;\n\t\n\t  var vlq = toVLQSigned(aValue);\n\t\n\t  do {\n\t    digit = vlq & VLQ_BASE_MASK;\n\t    vlq >>>= VLQ_BASE_SHIFT;\n\t    if (vlq > 0) {\n\t      // There are still more digits in this value, so we must make sure the\n\t      // continuation bit is marked.\n\t      digit |= VLQ_CONTINUATION_BIT;\n\t    }\n\t    encoded += base64.encode(digit);\n\t  } while (vlq > 0);\n\t\n\t  return encoded;\n\t};\n\t\n\t/**\n\t * Decodes the next base 64 VLQ value from the given string and returns the\n\t * value and the rest of the string via the out parameter.\n\t */\n\texports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t  var strLen = aStr.length;\n\t  var result = 0;\n\t  var shift = 0;\n\t  var continuation, digit;\n\t\n\t  do {\n\t    if (aIndex >= strLen) {\n\t      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t    }\n\t\n\t    digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t    if (digit === -1) {\n\t      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t    }\n\t\n\t    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t    digit &= VLQ_BASE_MASK;\n\t    result = result + (digit << shift);\n\t    shift += VLQ_BASE_SHIFT;\n\t  } while (continuation);\n\t\n\t  aOutParam.value = fromVLQSigned(result);\n\t  aOutParam.rest = aIndex;\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\t\n\t/**\n\t * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t */\n\texports.encode = function (number) {\n\t  if (0 <= number && number < intToCharMap.length) {\n\t    return intToCharMap[number];\n\t  }\n\t  throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t};\n\t\n\t/**\n\t * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t * failure.\n\t */\n\texports.decode = function (charCode) {\n\t  var bigA = 65;     // 'A'\n\t  var bigZ = 90;     // 'Z'\n\t\n\t  var littleA = 97;  // 'a'\n\t  var littleZ = 122; // 'z'\n\t\n\t  var zero = 48;     // '0'\n\t  var nine = 57;     // '9'\n\t\n\t  var plus = 43;     // '+'\n\t  var slash = 47;    // '/'\n\t\n\t  var littleOffset = 26;\n\t  var numberOffset = 52;\n\t\n\t  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t  if (bigA <= charCode && charCode <= bigZ) {\n\t    return (charCode - bigA);\n\t  }\n\t\n\t  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t  if (littleA <= charCode && charCode <= littleZ) {\n\t    return (charCode - littleA + littleOffset);\n\t  }\n\t\n\t  // 52 - 61: 0123456789\n\t  if (zero <= charCode && charCode <= nine) {\n\t    return (charCode - zero + numberOffset);\n\t  }\n\t\n\t  // 62: +\n\t  if (charCode == plus) {\n\t    return 62;\n\t  }\n\t\n\t  // 63: /\n\t  if (charCode == slash) {\n\t    return 63;\n\t  }\n\t\n\t  // Invalid base64 digit.\n\t  return -1;\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t/**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */\n\tfunction getArg(aArgs, aName, aDefaultValue) {\n\t  if (aName in aArgs) {\n\t    return aArgs[aName];\n\t  } else if (arguments.length === 3) {\n\t    return aDefaultValue;\n\t  } else {\n\t    throw new Error('\"' + aName + '\" is a required argument.');\n\t  }\n\t}\n\texports.getArg = getArg;\n\t\n\tvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n\tvar dataUrlRegexp = /^data:.+\\,.+$/;\n\t\n\tfunction urlParse(aUrl) {\n\t  var match = aUrl.match(urlRegexp);\n\t  if (!match) {\n\t    return null;\n\t  }\n\t  return {\n\t    scheme: match[1],\n\t    auth: match[2],\n\t    host: match[3],\n\t    port: match[4],\n\t    path: match[5]\n\t  };\n\t}\n\texports.urlParse = urlParse;\n\t\n\tfunction urlGenerate(aParsedUrl) {\n\t  var url = '';\n\t  if (aParsedUrl.scheme) {\n\t    url += aParsedUrl.scheme + ':';\n\t  }\n\t  url += '//';\n\t  if (aParsedUrl.auth) {\n\t    url += aParsedUrl.auth + '@';\n\t  }\n\t  if (aParsedUrl.host) {\n\t    url += aParsedUrl.host;\n\t  }\n\t  if (aParsedUrl.port) {\n\t    url += \":\" + aParsedUrl.port\n\t  }\n\t  if (aParsedUrl.path) {\n\t    url += aParsedUrl.path;\n\t  }\n\t  return url;\n\t}\n\texports.urlGenerate = urlGenerate;\n\t\n\t/**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */\n\tfunction normalize(aPath) {\n\t  var path = aPath;\n\t  var url = urlParse(aPath);\n\t  if (url) {\n\t    if (!url.path) {\n\t      return aPath;\n\t    }\n\t    path = url.path;\n\t  }\n\t  var isAbsolute = exports.isAbsolute(path);\n\t\n\t  var parts = path.split(/\\/+/);\n\t  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t    part = parts[i];\n\t    if (part === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (part === '..') {\n\t      up++;\n\t    } else if (up > 0) {\n\t      if (part === '') {\n\t        // The first part is blank if the path is absolute. Trying to go\n\t        // above the root is a no-op. Therefore we can remove all '..' parts\n\t        // directly after the root.\n\t        parts.splice(i + 1, up);\n\t        up = 0;\n\t      } else {\n\t        parts.splice(i, 2);\n\t        up--;\n\t      }\n\t    }\n\t  }\n\t  path = parts.join('/');\n\t\n\t  if (path === '') {\n\t    path = isAbsolute ? '/' : '.';\n\t  }\n\t\n\t  if (url) {\n\t    url.path = path;\n\t    return urlGenerate(url);\n\t  }\n\t  return path;\n\t}\n\texports.normalize = normalize;\n\t\n\t/**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */\n\tfunction join(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t  if (aPath === \"\") {\n\t    aPath = \".\";\n\t  }\n\t  var aPathUrl = urlParse(aPath);\n\t  var aRootUrl = urlParse(aRoot);\n\t  if (aRootUrl) {\n\t    aRoot = aRootUrl.path || '/';\n\t  }\n\t\n\t  // `join(foo, '//www.example.org')`\n\t  if (aPathUrl && !aPathUrl.scheme) {\n\t    if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\t\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\t\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\t\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n\t};\n\t\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\t\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\t\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\t\n\t    ++level;\n\t  }\n\t\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\t\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\t\n\tfunction identity (s) {\n\t  return s;\n\t}\n\t\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\t\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\t\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\t\n\t  var length = s.length;\n\t\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\t\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\t\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\t\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\t\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\t\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\t\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(13);\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = Object.create(null);\n\t}\n\t\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\t\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return Object.getOwnPropertyNames(this._set).length;\n\t};\n\t\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = util.toSetString(aStr);\n\t  var isDuplicate = has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    this._set[sStr] = idx;\n\t  }\n\t};\n\t\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  return has.call(this._set, sStr);\n\t};\n\t\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  if (has.call(this._set, sStr)) {\n\t    return this._set[sStr];\n\t  }\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\t\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\t\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\t\n\texports.ArraySet = ArraySet;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2014 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(13);\n\t\n\t/**\n\t * Determine whether mappingB is after mappingA with respect to generated\n\t * position.\n\t */\n\tfunction generatedPositionAfter(mappingA, mappingB) {\n\t  // Optimized for most common case\n\t  var lineA = mappingA.generatedLine;\n\t  var lineB = mappingB.generatedLine;\n\t  var columnA = mappingA.generatedColumn;\n\t  var columnB = mappingB.generatedColumn;\n\t  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n\t         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n\t}\n\t\n\t/**\n\t * A data structure to provide a sorted view of accumulated mappings in a\n\t * performance conscious manner. It trades a neglibable overhead in general\n\t * case for a large speedup in case of mappings being added in order.\n\t */\n\tfunction MappingList() {\n\t  this._array = [];\n\t  this._sorted = true;\n\t  // Serves as infimum\n\t  this._last = {generatedLine: -1, generatedColumn: 0};\n\t}\n\t\n\t/**\n\t * Iterate through internal items. This method takes the same arguments that\n\t * `Array.prototype.forEach` takes.\n\t *\n\t * NOTE: The order of the mappings is NOT guaranteed.\n\t */\n\tMappingList.prototype.unsortedForEach =\n\t  function MappingList_forEach(aCallback, aThisArg) {\n\t    this._array.forEach(aCallback, aThisArg);\n\t  };\n\t\n\t/**\n\t * Add the given source mapping.\n\t *\n\t * @param Object aMapping\n\t */\n\tMappingList.prototype.add = function MappingList_add(aMapping) {\n\t  if (generatedPositionAfter(this._last, aMapping)) {\n\t    this._last = aMapping;\n\t    this._array.push(aMapping);\n\t  } else {\n\t    this._sorted = false;\n\t    this._array.push(aMapping);\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the flat, sorted array of mappings. The mappings are sorted by\n\t * generated position.\n\t *\n\t * WARNING: This method returns internal data without copying, for\n\t * performance. The return value must NOT be mutated, and should be treated as\n\t * an immutable borrow. If you want to take ownership, you must make your own\n\t * copy.\n\t */\n\tMappingList.prototype.toArray = function MappingList_toArray() {\n\t  if (!this._sorted) {\n\t    this._array.sort(util.compareByGeneratedPositionsInflated);\n\t    this._sorted = true;\n\t  }\n\t  return this._array;\n\t};\n\t\n\texports.MappingList = MappingList;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(13);\n\tvar binarySearch = __webpack_require__(17);\n\tvar ArraySet = __webpack_require__(14).ArraySet;\n\tvar base64VLQ = __webpack_require__(11);\n\tvar quickSort = __webpack_require__(18).quickSort;\n\t\n\tfunction SourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap)\n\t    : new BasicSourceMapConsumer(sourceMap);\n\t}\n\t\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n\t}\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\t\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\t\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__originalMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\t\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\t\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\t\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\t\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      if (source != null && sourceRoot != null) {\n\t        source = util.join(sourceRoot, source);\n\t      }\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\t\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: Optional. the column number in the original source.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tSourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t    var line = util.getArg(aArgs, 'line');\n\t\n\t    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t    // returns the index of the closest mapping less than the needle. By\n\t    // setting needle.originalColumn to 0, we thus find the last mapping for\n\t    // the given line, provided such a mapping exists.\n\t    var needle = {\n\t      source: util.getArg(aArgs, 'source'),\n\t      originalLine: line,\n\t      originalColumn: util.getArg(aArgs, 'column', 0)\n\t    };\n\t\n\t    if (this.sourceRoot != null) {\n\t      needle.source = util.relative(this.sourceRoot, needle.source);\n\t    }\n\t    if (!this._sources.has(needle.source)) {\n\t      return [];\n\t    }\n\t    needle.source = this._sources.indexOf(needle.source);\n\t\n\t    var mappings = [];\n\t\n\t    var index = this._findMapping(needle,\n\t                                  this._originalMappings,\n\t                                  \"originalLine\",\n\t                                  \"originalColumn\",\n\t                                  util.compareByOriginalPositions,\n\t                                  binarySearch.LEAST_UPPER_BOUND);\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (aArgs.column === undefined) {\n\t        var originalLine = mapping.originalLine;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we found. Since\n\t        // mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we found.\n\t        while (mapping && mapping.originalLine === originalLine) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      } else {\n\t        var originalColumn = mapping.originalColumn;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we were searching for.\n\t        // Since mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we are searching for.\n\t        while (mapping &&\n\t               mapping.originalLine === line &&\n\t               mapping.originalColumn == originalColumn) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      }\n\t    }\n\t\n\t    return mappings;\n\t  };\n\t\n\texports.SourceMapConsumer = SourceMapConsumer;\n\t\n\t/**\n\t * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t * query for information about the original file positions by giving it a file\n\t * position in the generated source.\n\t *\n\t * The only parameter is the raw source map (either as a JSON string, or\n\t * already parsed to an object). According to the spec, source maps have the\n\t * following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - sources: An array of URLs to the original source files.\n\t *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t *   - sourcesContent: Optional. An array of contents of the original source files.\n\t *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *\n\t * Here is an example source map, taken from the source map spec[0]:\n\t *\n\t *     {\n\t *       version : 3,\n\t *       file: \"out.js\",\n\t *       sourceRoot : \"\",\n\t *       sources: [\"foo.js\", \"bar.js\"],\n\t *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *       mappings: \"AA,AB;;ABCDE;\"\n\t *     }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t */\n\tfunction BasicSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sources = util.getArg(sourceMap, 'sources');\n\t  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t  // requires the array) to play nice here.\n\t  var names = util.getArg(sourceMap, 'names', []);\n\t  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t  var mappings = util.getArg(sourceMap, 'mappings');\n\t  var file = util.getArg(sourceMap, 'file', null);\n\t\n\t  // Once again, Sass deviates from the spec and supplies the version as a\n\t  // string rather than a number, so we use loose equality checking here.\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  sources = sources\n\t    .map(String)\n\t    // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t    // See bugzil.la/1090768.\n\t    .map(util.normalize)\n\t    // Always ensure that absolute sources are internally stored relative to\n\t    // the source root, if the source root is absolute. Not doing this would\n\t    // be particularly problematic when the source root is a prefix of the\n\t    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t    .map(function (source) {\n\t      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t        ? util.relative(sourceRoot, source)\n\t        : source;\n\t    });\n\t\n\t  // Pass `true` below to allow duplicate names and sources. While source maps\n\t  // are intended to be compressed and deduplicated, the TypeScript compiler\n\t  // sometimes generates source maps with duplicates in them. See Github issue\n\t  // #72 and bugzil.la/889492.\n\t  this._names = ArraySet.fromArray(names.map(String), true);\n\t  this._sources = ArraySet.fromArray(sources, true);\n\t\n\t  this.sourceRoot = sourceRoot;\n\t  this.sourcesContent = sourcesContent;\n\t  this._mappings = mappings;\n\t  this.file = file;\n\t}\n\t\n\tBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\t\n\t/**\n\t * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t *\n\t * @param SourceMapGenerator aSourceMap\n\t *        The source map that will be consumed.\n\t * @returns BasicSourceMapConsumer\n\t */\n\tBasicSourceMapConsumer.fromSourceMap =\n\t  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n\t    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\t\n\t    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t    smc.sourceRoot = aSourceMap._sourceRoot;\n\t    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                            smc.sourceRoot);\n\t    smc.file = aSourceMap._file;\n\t\n\t    // Because we are modifying the entries (by converting string sources and\n\t    // names to indices into the sources and names ArraySets), we have to make\n\t    // a copy of the entry or else bad things happen. Shared mutable state\n\t    // strikes again! See github issue #191.\n\t\n\t    var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t    var destGeneratedMappings = smc.__generatedMappings = [];\n\t    var destOriginalMappings = smc.__originalMappings = [];\n\t\n\t    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t      var srcMapping = generatedMappings[i];\n\t      var destMapping = new Mapping;\n\t      destMapping.generatedLine = srcMapping.generatedLine;\n\t      destMapping.generatedColumn = srcMapping.generatedColumn;\n\t\n\t      if (srcMapping.source) {\n\t        destMapping.source = sources.indexOf(srcMapping.source);\n\t        destMapping.originalLine = srcMapping.originalLine;\n\t        destMapping.originalColumn = srcMapping.originalColumn;\n\t\n\t        if (srcMapping.name) {\n\t          destMapping.name = names.indexOf(srcMapping.name);\n\t        }\n\t\n\t        destOriginalMappings.push(destMapping);\n\t      }\n\t\n\t      destGeneratedMappings.push(destMapping);\n\t    }\n\t\n\t    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\t\n\t    return smc;\n\t  };\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tBasicSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    return this._sources.toArray().map(function (s) {\n\t      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n\t    }, this);\n\t  }\n\t});\n\t\n\t/**\n\t * Provide the JIT with a nice shape / hidden class.\n\t */\n\tfunction Mapping() {\n\t  this.generatedLine = 0;\n\t  this.generatedColumn = 0;\n\t  this.source = null;\n\t  this.originalLine = null;\n\t  this.originalColumn = null;\n\t  this.name = null;\n\t}\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tBasicSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    var generatedLine = 1;\n\t    var previousGeneratedColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousOriginalColumn = 0;\n\t    var previousSource = 0;\n\t    var previousName = 0;\n\t    var length = aStr.length;\n\t    var index = 0;\n\t    var cachedSegments = {};\n\t    var temp = {};\n\t    var originalMappings = [];\n\t    var generatedMappings = [];\n\t    var mapping, str, segment, end, value;\n\t\n\t    while (index < length) {\n\t      if (aStr.charAt(index) === ';') {\n\t        generatedLine++;\n\t        index++;\n\t        previousGeneratedColumn = 0;\n\t      }\n\t      else if (aStr.charAt(index) === ',') {\n\t        index++;\n\t      }\n\t      else {\n\t        mapping = new Mapping();\n\t        mapping.generatedLine = generatedLine;\n\t\n\t        // Because each offset is encoded relative to the previous one,\n\t        // many segments often have the same encoding. We can exploit this\n\t        // fact by caching the parsed variable length fields of each segment,\n\t        // allowing us to avoid a second parse if we encounter the same\n\t        // segment again.\n\t        for (end = index; end < length; end++) {\n\t          if (this._charIsMappingSeparator(aStr, end)) {\n\t            break;\n\t          }\n\t        }\n\t        str = aStr.slice(index, end);\n\t\n\t        segment = cachedSegments[str];\n\t        if (segment) {\n\t          index += str.length;\n\t        } else {\n\t          segment = [];\n\t          while (index < end) {\n\t            base64VLQ.decode(aStr, index, temp);\n\t            value = temp.value;\n\t            index = temp.rest;\n\t            segment.push(value);\n\t          }\n\t\n\t          if (segment.length === 2) {\n\t            throw new Error('Found a source, but no line and column');\n\t          }\n\t\n\t          if (segment.length === 3) {\n\t            throw new Error('Found a source and line, but no column');\n\t          }\n\t\n\t          cachedSegments[str] = segment;\n\t        }\n\t\n\t        // Generated column.\n\t        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t        previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t        if (segment.length > 1) {\n\t          // Original source.\n\t          mapping.source = previousSource + segment[1];\n\t          previousSource += segment[1];\n\t\n\t          // Original line.\n\t          mapping.originalLine = previousOriginalLine + segment[2];\n\t          previousOriginalLine = mapping.originalLine;\n\t          // Lines are stored 0-based\n\t          mapping.originalLine += 1;\n\t\n\t          // Original column.\n\t          mapping.originalColumn = previousOriginalColumn + segment[3];\n\t          previousOriginalColumn = mapping.originalColumn;\n\t\n\t          if (segment.length > 4) {\n\t            // Original name.\n\t            mapping.name = previousName + segment[4];\n\t            previousName += segment[4];\n\t          }\n\t        }\n\t\n\t        generatedMappings.push(mapping);\n\t        if (typeof mapping.originalLine === 'number') {\n\t          originalMappings.push(mapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    this.__generatedMappings = generatedMappings;\n\t\n\t    quickSort(originalMappings, util.compareByOriginalPositions);\n\t    this.__originalMappings = originalMappings;\n\t  };\n\t\n\t/**\n\t * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t * we are searching for in the given \"haystack\" of mappings.\n\t */\n\tBasicSourceMapConsumer.prototype._findMapping =\n\t  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                         aColumnName, aComparator, aBias) {\n\t    // To return the position we are searching for, we must first find the\n\t    // mapping for the given position and then return the opposite position it\n\t    // points to. Because the mappings are sorted, we can use binary search to\n\t    // find the best mapping.\n\t\n\t    if (aNeedle[aLineName] <= 0) {\n\t      throw new TypeError('Line must be greater than or equal to 1, got '\n\t                          + aNeedle[aLineName]);\n\t    }\n\t    if (aNeedle[aColumnName] < 0) {\n\t      throw new TypeError('Column must be greater than or equal to 0, got '\n\t                          + aNeedle[aColumnName]);\n\t    }\n\t\n\t    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t  };\n\t\n\t/**\n\t * Compute the last column for each generated mapping. The last column is\n\t * inclusive.\n\t */\n\tBasicSourceMapConsumer.prototype.computeColumnSpans =\n\t  function SourceMapConsumer_computeColumnSpans() {\n\t    for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      // Mappings do not contain a field for the last generated columnt. We\n\t      // can come up with an optimistic estimate, however, by assuming that\n\t      // mappings are contiguous (i.e. given two consecutive mappings, the\n\t      // first mapping ends where the second one starts).\n\t      if (index + 1 < this._generatedMappings.length) {\n\t        var nextMapping = this._generatedMappings[index + 1];\n\t\n\t        if (mapping.generatedLine === nextMapping.generatedLine) {\n\t          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      // The last mapping for each line spans the entire line.\n\t      mapping.lastGeneratedColumn = Infinity;\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.originalPositionFor =\n\t  function SourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._generatedMappings,\n\t      \"generatedLine\",\n\t      \"generatedColumn\",\n\t      util.compareByGeneratedPositionsDeflated,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      if (mapping.generatedLine === needle.generatedLine) {\n\t        var source = util.getArg(mapping, 'source', null);\n\t        if (source !== null) {\n\t          source = this._sources.at(source);\n\t          if (this.sourceRoot != null) {\n\t            source = util.join(this.sourceRoot, source);\n\t          }\n\t        }\n\t        var name = util.getArg(mapping, 'name', null);\n\t        if (name !== null) {\n\t          name = this._names.at(name);\n\t        }\n\t        return {\n\t          source: source,\n\t          line: util.getArg(mapping, 'originalLine', null),\n\t          column: util.getArg(mapping, 'originalColumn', null),\n\t          name: name\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      source: null,\n\t      line: null,\n\t      column: null,\n\t      name: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t    if (!this.sourcesContent) {\n\t      return false;\n\t    }\n\t    return this.sourcesContent.length >= this._sources.size() &&\n\t      !this.sourcesContent.some(function (sc) { return sc == null; });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tBasicSourceMapConsumer.prototype.sourceContentFor =\n\t  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    if (!this.sourcesContent) {\n\t      return null;\n\t    }\n\t\n\t    if (this.sourceRoot != null) {\n\t      aSource = util.relative(this.sourceRoot, aSource);\n\t    }\n\t\n\t    if (this._sources.has(aSource)) {\n\t      return this.sourcesContent[this._sources.indexOf(aSource)];\n\t    }\n\t\n\t    var url;\n\t    if (this.sourceRoot != null\n\t        && (url = util.urlParse(this.sourceRoot))) {\n\t      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t      // many users. We can help them out when they expect file:// URIs to\n\t      // behave like it would if they were running a local HTTP server. See\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t      if (url.scheme == \"file\"\n\t          && this._sources.has(fileUriAbsPath)) {\n\t        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t      }\n\t\n\t      if ((!url.path || url.path == \"/\")\n\t          && this._sources.has(\"/\" + aSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n\t      }\n\t    }\n\t\n\t    // This function is used recursively from\n\t    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t    // don't want to throw if we can't find the source - we just want to\n\t    // return null, so we provide a flag to exit gracefully.\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.generatedPositionFor =\n\t  function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t    var source = util.getArg(aArgs, 'source');\n\t    if (this.sourceRoot != null) {\n\t      source = util.relative(this.sourceRoot, source);\n\t    }\n\t    if (!this._sources.has(source)) {\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    }\n\t    source = this._sources.indexOf(source);\n\t\n\t    var needle = {\n\t      source: source,\n\t      originalLine: util.getArg(aArgs, 'line'),\n\t      originalColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._originalMappings,\n\t      \"originalLine\",\n\t      \"originalColumn\",\n\t      util.compareByOriginalPositions,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (mapping.source === needle.source) {\n\t        return {\n\t          line: util.getArg(mapping, 'generatedLine', null),\n\t          column: util.getArg(mapping, 'generatedColumn', null),\n\t          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null,\n\t      lastColumn: null\n\t    };\n\t  };\n\t\n\texports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\t\n\t/**\n\t * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t * we can query for information. It differs from BasicSourceMapConsumer in\n\t * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t * input.\n\t *\n\t * The only parameter is a raw source map (either as a JSON string, or already\n\t * parsed to an object). According to the spec for indexed source maps, they\n\t * have the following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *   - sections: A list of section definitions.\n\t *\n\t * Each value under the \"sections\" field has two fields:\n\t *   - offset: The offset into the original specified at which this section\n\t *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t *       field.\n\t *   - map: A source map definition. This source map could also be indexed,\n\t *       but doesn't have to be.\n\t *\n\t * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t * specifying a URL to retrieve a source map from, but that's currently\n\t * unsupported.\n\t *\n\t * Here's an example source map, taken from the source map spec[0], but\n\t * modified to omit a section which uses the \"url\" field.\n\t *\n\t *  {\n\t *    version : 3,\n\t *    file: \"app.js\",\n\t *    sections: [{\n\t *      offset: {line:100, column:10},\n\t *      map: {\n\t *        version : 3,\n\t *        file: \"section.js\",\n\t *        sources: [\"foo.js\", \"bar.js\"],\n\t *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *        mappings: \"AAAA,E;;ABCDE;\"\n\t *      }\n\t *    }],\n\t *  }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t */\n\tfunction IndexedSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sections = util.getArg(sourceMap, 'sections');\n\t\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t\n\t  var lastOffset = {\n\t    line: -1,\n\t    column: 0\n\t  };\n\t  this._sections = sections.map(function (s) {\n\t    if (s.url) {\n\t      // The url field will require support for asynchronicity.\n\t      // See https://github.com/mozilla/source-map/issues/16\n\t      throw new Error('Support for url field in sections not implemented.');\n\t    }\n\t    var offset = util.getArg(s, 'offset');\n\t    var offsetLine = util.getArg(offset, 'line');\n\t    var offsetColumn = util.getArg(offset, 'column');\n\t\n\t    if (offsetLine < lastOffset.line ||\n\t        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t      throw new Error('Section offsets must be ordered and non-overlapping.');\n\t    }\n\t    lastOffset = offset;\n\t\n\t    return {\n\t      generatedOffset: {\n\t        // The offset fields are 0-based, but we use 1-based indices when\n\t        // encoding/decoding from VLQ.\n\t        generatedLine: offsetLine + 1,\n\t        generatedColumn: offsetColumn + 1\n\t      },\n\t      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n\t    }\n\t  });\n\t}\n\t\n\tIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tIndexedSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    var sources = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t        sources.push(this._sections[i].consumer.sources[j]);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\t});\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.originalPositionFor =\n\t  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    // Find the section containing the generated position we're trying to map\n\t    // to an original position.\n\t    var sectionIndex = binarySearch.search(needle, this._sections,\n\t      function(needle, section) {\n\t        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t        if (cmp) {\n\t          return cmp;\n\t        }\n\t\n\t        return (needle.generatedColumn -\n\t                section.generatedOffset.generatedColumn);\n\t      });\n\t    var section = this._sections[sectionIndex];\n\t\n\t    if (!section) {\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    }\n\t\n\t    return section.consumer.originalPositionFor({\n\t      line: needle.generatedLine -\n\t        (section.generatedOffset.generatedLine - 1),\n\t      column: needle.generatedColumn -\n\t        (section.generatedOffset.generatedLine === needle.generatedLine\n\t         ? section.generatedOffset.generatedColumn - 1\n\t         : 0),\n\t      bias: aArgs.bias\n\t    });\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t    return this._sections.every(function (s) {\n\t      return s.consumer.hasContentsOfAllSources();\n\t    });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tIndexedSourceMapConsumer.prototype.sourceContentFor =\n\t  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      var content = section.consumer.sourceContentFor(aSource, true);\n\t      if (content) {\n\t        return content;\n\t      }\n\t    }\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      // Only consider this section if the requested source is in the list of\n\t      // sources of the consumer.\n\t      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n\t        continue;\n\t      }\n\t      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t      if (generatedPosition) {\n\t        var ret = {\n\t          line: generatedPosition.line +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          column: generatedPosition.column +\n\t            (section.generatedOffset.generatedLine === generatedPosition.line\n\t             ? section.generatedOffset.generatedColumn - 1\n\t             : 0)\n\t        };\n\t        return ret;\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tIndexedSourceMapConsumer.prototype._parseMappings =\n\t  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    this.__generatedMappings = [];\n\t    this.__originalMappings = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t      var sectionMappings = section.consumer._generatedMappings;\n\t      for (var j = 0; j < sectionMappings.length; j++) {\n\t        var mapping = sectionMappings[j];\n\t\n\t        var source = section.consumer._sources.at(mapping.source);\n\t        if (section.consumer.sourceRoot !== null) {\n\t          source = util.join(section.consumer.sourceRoot, source);\n\t        }\n\t        this._sources.add(source);\n\t        source = this._sources.indexOf(source);\n\t\n\t        var name = section.consumer._names.at(mapping.name);\n\t        this._names.add(name);\n\t        name = this._names.indexOf(name);\n\t\n\t        // The mappings coming from the consumer for the section have\n\t        // generated positions relative to the start of the section, so we\n\t        // need to offset them to be relative to the start of the concatenated\n\t        // generated file.\n\t        var adjustedMapping = {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          generatedColumn: mapping.generatedColumn +\n\t            (section.generatedOffset.generatedLine === mapping.generatedLine\n\t            ? section.generatedOffset.generatedColumn - 1\n\t            : 0),\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: name\n\t        };\n\t\n\t        this.__generatedMappings.push(adjustedMapping);\n\t        if (typeof adjustedMapping.originalLine === 'number') {\n\t          this.__originalMappings.push(adjustedMapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t  };\n\t\n\texports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\texports.GREATEST_LOWER_BOUND = 1;\n\texports.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */\n\tfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t  // This function terminates when one of the following is true:\n\t  //\n\t  //   1. We find the exact element we are looking for.\n\t  //\n\t  //   2. We did not find the exact element, but we can return the index of\n\t  //      the next-closest element.\n\t  //\n\t  //   3. We did not find the exact element, and there is no next-closest\n\t  //      element than the one we are searching for, so we return -1.\n\t  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t  if (cmp === 0) {\n\t    // Found the element we are looking for.\n\t    return mid;\n\t  }\n\t  else if (cmp > 0) {\n\t    // Our needle is greater than aHaystack[mid].\n\t    if (aHigh - mid > 1) {\n\t      // The element is in the upper half.\n\t      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // The exact needle element was not found in this haystack. Determine if\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return aHigh < aHaystack.length ? aHigh : -1;\n\t    } else {\n\t      return mid;\n\t    }\n\t  }\n\t  else {\n\t    // Our needle is less than aHaystack[mid].\n\t    if (mid - aLow > 1) {\n\t      // The element is in the lower half.\n\t      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return mid;\n\t    } else {\n\t      return aLow < 0 ? -1 : aLow;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */\n\texports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t  if (aHaystack.length === 0) {\n\t    return -1;\n\t  }\n\t\n\t  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t  if (index < 0) {\n\t    return -1;\n\t  }\n\t\n\t  // We have found either the exact element, or the next-closest element than\n\t  // the one we are searching for. However, there may be more than one such\n\t  // element. Make sure we always return the smallest of these.\n\t  while (index - 1 >= 0) {\n\t    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t      break;\n\t    }\n\t    --index;\n\t  }\n\t\n\t  return index;\n\t};\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t// It turns out that some (most?) JavaScript engines don't self-host\n\t// `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t// faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t// custom comparator function, calling back and forth between the VM's C++ and\n\t// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t// worse generated code for the comparator function than would be optimal. In\n\t// fact, when sorting with a comparator, these costs outweigh the benefits of\n\t// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t// a ~3500ms mean speed-up in `bench/bench.html`.\n\t\n\t/**\n\t * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t *\n\t * @param {Array} ary\n\t *        The array.\n\t * @param {Number} x\n\t *        The index of the first item.\n\t * @param {Number} y\n\t *        The index of the second item.\n\t */\n\tfunction swap(ary, x, y) {\n\t  var temp = ary[x];\n\t  ary[x] = ary[y];\n\t  ary[y] = temp;\n\t}\n\t\n\t/**\n\t * Returns a random integer within the range `low .. high` inclusive.\n\t *\n\t * @param {Number} low\n\t *        The lower bound on the range.\n\t * @param {Number} high\n\t *        The upper bound on the range.\n\t */\n\tfunction randomIntInRange(low, high) {\n\t  return Math.round(low + (Math.random() * (high - low)));\n\t}\n\t\n\t/**\n\t * The Quick Sort algorithm.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t * @param {Number} p\n\t *        Start index of the array\n\t * @param {Number} r\n\t *        End index of the array\n\t */\n\tfunction doQuickSort(ary, comparator, p, r) {\n\t  // If our lower bound is less than our upper bound, we (1) partition the\n\t  // array into two pieces and (2) recurse on each half. If it is not, this is\n\t  // the empty array and our base case.\n\t\n\t  if (p < r) {\n\t    // (1) Partitioning.\n\t    //\n\t    // The partitioning chooses a pivot between `p` and `r` and moves all\n\t    // elements that are less than or equal to the pivot to the before it, and\n\t    // all the elements that are greater than it after it. The effect is that\n\t    // once partition is done, the pivot is in the exact place it will be when\n\t    // the array is put in sorted order, and it will not need to be moved\n\t    // again. This runs in O(n) time.\n\t\n\t    // Always choose a random pivot so that an input array which is reverse\n\t    // sorted does not cause O(n^2) running time.\n\t    var pivotIndex = randomIntInRange(p, r);\n\t    var i = p - 1;\n\t\n\t    swap(ary, pivotIndex, r);\n\t    var pivot = ary[r];\n\t\n\t    // Immediately after `j` is incremented in this loop, the following hold\n\t    // true:\n\t    //\n\t    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t    //\n\t    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t    for (var j = p; j < r; j++) {\n\t      if (comparator(ary[j], pivot) <= 0) {\n\t        i += 1;\n\t        swap(ary, i, j);\n\t      }\n\t    }\n\t\n\t    swap(ary, i + 1, j);\n\t    var q = i + 1;\n\t\n\t    // (2) Recurse on each half.\n\t\n\t    doQuickSort(ary, comparator, p, q - 1);\n\t    doQuickSort(ary, comparator, q + 1, r);\n\t  }\n\t}\n\t\n\t/**\n\t * Sort the given array in-place with the given comparator function.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t */\n\texports.quickSort = function (ary, comparator) {\n\t  doQuickSort(ary, comparator, 0, ary.length - 1);\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar SourceMapGenerator = __webpack_require__(10).SourceMapGenerator;\n\tvar util = __webpack_require__(13);\n\t\n\t// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n\t// operating systems these days (capturing the result).\n\tvar REGEX_NEWLINE = /(\\r?\\n)/;\n\t\n\t// Newline character code for charCodeAt() comparisons\n\tvar NEWLINE_CODE = 10;\n\t\n\t// Private symbol for identifying `SourceNode`s when multiple versions of\n\t// the source-map library are loaded. This MUST NOT CHANGE across\n\t// versions!\n\tvar isSourceNode = \"$$$isSourceNode$$$\";\n\t\n\t/**\n\t * SourceNodes provide a way to abstract over interpolating/concatenating\n\t * snippets of generated JavaScript source code while maintaining the line and\n\t * column information associated with the original source code.\n\t *\n\t * @param aLine The original line number.\n\t * @param aColumn The original column number.\n\t * @param aSource The original source's filename.\n\t * @param aChunks Optional. An array of strings which are snippets of\n\t *        generated JS, or other SourceNodes.\n\t * @param aName The original identifier.\n\t */\n\tfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n\t  this.children = [];\n\t  this.sourceContents = {};\n\t  this.line = aLine == null ? null : aLine;\n\t  this.column = aColumn == null ? null : aColumn;\n\t  this.source = aSource == null ? null : aSource;\n\t  this.name = aName == null ? null : aName;\n\t  this[isSourceNode] = true;\n\t  if (aChunks != null) this.add(aChunks);\n\t}\n\t\n\t/**\n\t * Creates a SourceNode from generated code and a SourceMapConsumer.\n\t *\n\t * @param aGeneratedCode The generated code\n\t * @param aSourceMapConsumer The SourceMap for the generated code\n\t * @param aRelativePath Optional. The path that relative sources in the\n\t *        SourceMapConsumer should be relative to.\n\t */\n\tSourceNode.fromStringWithSourceMap =\n\t  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n\t    // The SourceNode we want to fill with the generated code\n\t    // and the SourceMap\n\t    var node = new SourceNode();\n\t\n\t    // All even indices of this array are one line of the generated code,\n\t    // while all odd indices are the newlines between two adjacent lines\n\t    // (since `REGEX_NEWLINE` captures its match).\n\t    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\t    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\t    var shiftNextLine = function() {\n\t      var lineContents = remainingLines.shift();\n\t      // The last line of a file might not have a newline.\n\t      var newLine = remainingLines.shift() || \"\";\n\t      return lineContents + newLine;\n\t    };\n\t\n\t    // We need to remember the position of \"remainingLines\"\n\t    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\t\n\t    // The generate SourceNodes we need a code range.\n\t    // To extract it current and last mapping is used.\n\t    // Here we store the last mapping.\n\t    var lastMapping = null;\n\t\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      if (lastMapping !== null) {\n\t        // We add the code from \"lastMapping\" to \"mapping\":\n\t        // First check if there is a new line in between.\n\t        if (lastGeneratedLine < mapping.generatedLine) {\n\t          // Associate first line with \"lastMapping\"\n\t          addMappingWithCode(lastMapping, shiftNextLine());\n\t          lastGeneratedLine++;\n\t          lastGeneratedColumn = 0;\n\t          // The remaining code is added without mapping\n\t        } else {\n\t          // There is no new line in between.\n\t          // Associate the code between \"lastGeneratedColumn\" and\n\t          // \"mapping.generatedColumn\" with \"lastMapping\"\n\t          var nextLine = remainingLines[0];\n\t          var code = nextLine.substr(0, mapping.generatedColumn -\n\t                                        lastGeneratedColumn);\n\t          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n\t                                              lastGeneratedColumn);\n\t          lastGeneratedColumn = mapping.generatedColumn;\n\t          addMappingWithCode(lastMapping, code);\n\t          // No more remaining code, continue\n\t          lastMapping = mapping;\n\t          return;\n\t        }\n\t      }\n\t      // We add the generated code until the first mapping\n\t      // to the SourceNode without any mapping.\n\t      // Each line is added as separate string.\n\t      while (lastGeneratedLine < mapping.generatedLine) {\n\t        node.add(shiftNextLine());\n\t        lastGeneratedLine++;\n\t      }\n\t      if (lastGeneratedColumn < mapping.generatedColumn) {\n\t        var nextLine = remainingLines[0];\n\t        node.add(nextLine.substr(0, mapping.generatedColumn));\n\t        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n\t        lastGeneratedColumn = mapping.generatedColumn;\n\t      }\n\t      lastMapping = mapping;\n\t    }, this);\n\t    // We have processed all mappings.\n\t    if (remainingLines.length > 0) {\n\t      if (lastMapping) {\n\t        // Associate the remaining code in the current line with \"lastMapping\"\n\t        addMappingWithCode(lastMapping, shiftNextLine());\n\t      }\n\t      // and add the remaining lines without any mapping\n\t      node.add(remainingLines.join(\"\"));\n\t    }\n\t\n\t    // Copy sourcesContent into SourceNode\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aRelativePath != null) {\n\t          sourceFile = util.join(aRelativePath, sourceFile);\n\t        }\n\t        node.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t\n\t    return node;\n\t\n\t    function addMappingWithCode(mapping, code) {\n\t      if (mapping === null || mapping.source === undefined) {\n\t        node.add(code);\n\t      } else {\n\t        var source = aRelativePath\n\t          ? util.join(aRelativePath, mapping.source)\n\t          : mapping.source;\n\t        node.add(new SourceNode(mapping.originalLine,\n\t                                mapping.originalColumn,\n\t                                source,\n\t                                code,\n\t                                mapping.name));\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Add a chunk of generated JS to this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.add = function SourceNode_add(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    aChunk.forEach(function (chunk) {\n\t      this.add(chunk);\n\t    }, this);\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    if (aChunk) {\n\t      this.children.push(aChunk);\n\t    }\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a chunk of generated JS to the beginning of this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    for (var i = aChunk.length-1; i >= 0; i--) {\n\t      this.prepend(aChunk[i]);\n\t    }\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    this.children.unshift(aChunk);\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Walk over the tree of JS snippets in this node and its children. The\n\t * walking function is called once for each snippet of JS and is passed that\n\t * snippet and the its original associated source's line/column location.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n\t  var chunk;\n\t  for (var i = 0, len = this.children.length; i < len; i++) {\n\t    chunk = this.children[i];\n\t    if (chunk[isSourceNode]) {\n\t      chunk.walk(aFn);\n\t    }\n\t    else {\n\t      if (chunk !== '') {\n\t        aFn(chunk, { source: this.source,\n\t                     line: this.line,\n\t                     column: this.column,\n\t                     name: this.name });\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n\t * each of `this.children`.\n\t *\n\t * @param aSep The separator.\n\t */\n\tSourceNode.prototype.join = function SourceNode_join(aSep) {\n\t  var newChildren;\n\t  var i;\n\t  var len = this.children.length;\n\t  if (len > 0) {\n\t    newChildren = [];\n\t    for (i = 0; i < len-1; i++) {\n\t      newChildren.push(this.children[i]);\n\t      newChildren.push(aSep);\n\t    }\n\t    newChildren.push(this.children[i]);\n\t    this.children = newChildren;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Call String.prototype.replace on the very right-most source snippet. Useful\n\t * for trimming whitespace from the end of a source node, etc.\n\t *\n\t * @param aPattern The pattern to replace.\n\t * @param aReplacement The thing to replace the pattern with.\n\t */\n\tSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n\t  var lastChild = this.children[this.children.length - 1];\n\t  if (lastChild[isSourceNode]) {\n\t    lastChild.replaceRight(aPattern, aReplacement);\n\t  }\n\t  else if (typeof lastChild === 'string') {\n\t    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n\t  }\n\t  else {\n\t    this.children.push(''.replace(aPattern, aReplacement));\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the source content for a source file. This will be added to the SourceMapGenerator\n\t * in the sourcesContent field.\n\t *\n\t * @param aSourceFile The filename of the source file\n\t * @param aSourceContent The content of the source file\n\t */\n\tSourceNode.prototype.setSourceContent =\n\t  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n\t    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n\t  };\n\t\n\t/**\n\t * Walk over the tree of SourceNodes. The walking function is called for each\n\t * source file content and is passed the filename and source content.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walkSourceContents =\n\t  function SourceNode_walkSourceContents(aFn) {\n\t    for (var i = 0, len = this.children.length; i < len; i++) {\n\t      if (this.children[i][isSourceNode]) {\n\t        this.children[i].walkSourceContents(aFn);\n\t      }\n\t    }\n\t\n\t    var sources = Object.keys(this.sourceContents);\n\t    for (var i = 0, len = sources.length; i < len; i++) {\n\t      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n\t    }\n\t  };\n\t\n\t/**\n\t * Return the string representation of this source node. Walks over the tree\n\t * and concatenates all the various snippets together to one string.\n\t */\n\tSourceNode.prototype.toString = function SourceNode_toString() {\n\t  var str = \"\";\n\t  this.walk(function (chunk) {\n\t    str += chunk;\n\t  });\n\t  return str;\n\t};\n\t\n\t/**\n\t * Returns the string representation of this source node along with a source\n\t * map.\n\t */\n\tSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n\t  var generated = {\n\t    code: \"\",\n\t    line: 1,\n\t    column: 0\n\t  };\n\t  var map = new SourceMapGenerator(aArgs);\n\t  var sourceMappingActive = false;\n\t  var lastOriginalSource = null;\n\t  var lastOriginalLine = null;\n\t  var lastOriginalColumn = null;\n\t  var lastOriginalName = null;\n\t  this.walk(function (chunk, original) {\n\t    generated.code += chunk;\n\t    if (original.source !== null\n\t        && original.line !== null\n\t        && original.column !== null) {\n\t      if(lastOriginalSource !== original.source\n\t         || lastOriginalLine !== original.line\n\t         || lastOriginalColumn !== original.column\n\t         || lastOriginalName !== original.name) {\n\t        map.addMapping({\n\t          source: original.source,\n\t          original: {\n\t            line: original.line,\n\t            column: original.column\n\t          },\n\t          generated: {\n\t            line: generated.line,\n\t            column: generated.column\n\t          },\n\t          name: original.name\n\t        });\n\t      }\n\t      lastOriginalSource = original.source;\n\t      lastOriginalLine = original.line;\n\t      lastOriginalColumn = original.column;\n\t      lastOriginalName = original.name;\n\t      sourceMappingActive = true;\n\t    } else if (sourceMappingActive) {\n\t      map.addMapping({\n\t        generated: {\n\t          line: generated.line,\n\t          column: generated.column\n\t        }\n\t      });\n\t      lastOriginalSource = null;\n\t      sourceMappingActive = false;\n\t    }\n\t    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n\t      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n\t        generated.line++;\n\t        generated.column = 0;\n\t        // Mappings end at eol\n\t        if (idx + 1 === length) {\n\t          lastOriginalSource = null;\n\t          sourceMappingActive = false;\n\t        } else if (sourceMappingActive) {\n\t          map.addMapping({\n\t            source: original.source,\n\t            original: {\n\t              line: original.line,\n\t              column: original.column\n\t            },\n\t            generated: {\n\t              line: generated.line,\n\t              column: generated.column\n\t            },\n\t            name: original.name\n\t          });\n\t        }\n\t      } else {\n\t        generated.column++;\n\t      }\n\t    }\n\t  });\n\t  this.walkSourceContents(function (sourceFile, sourceContent) {\n\t    map.setSourceContent(sourceFile, sourceContent);\n\t  });\n\t\n\t  return { code: generated.code, map: map };\n\t};\n\t\n\texports.SourceNode = SourceNode;\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** typescript-logging.bundle.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap aebdd958c8e658740c81\n **/","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n__export(require(\"./Logger\"));\n__export(require(\"./LoggerImpl\"));\n__export(require(\"./LoggerFactoryService\"));\n//# sourceMappingURL=typescript-logging.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/commonjs/typescript-logging.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\n/**\n * Log level for a logger.\n */\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n})(exports.LogLevel || (exports.LogLevel = {}));\nvar LogLevel = exports.LogLevel;\n/**\n * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)\n * where this comes into play.\n */\n(function (LoggerType) {\n    LoggerType[LoggerType[\"Console\"] = 0] = \"Console\";\n    LoggerType[LoggerType[\"MessageBuffer\"] = 1] = \"MessageBuffer\";\n    LoggerType[LoggerType[\"Custom\"] = 2] = \"Custom\";\n})(exports.LoggerType || (exports.LoggerType = {}));\nvar LoggerType = exports.LoggerType;\n//# sourceMappingURL=Logger.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/commonjs/Logger.js\n ** module id = 1\n ** module chunks = 0\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Logger_1 = require(\"./Logger\");\nvar LoggerFactoryService_1 = require(\"./LoggerFactoryService\");\nvar ST = require(\"stacktrace-js\");\nvar Message = (function () {\n    function Message(ready, message) {\n        this._ready = ready;\n        this._message = message;\n    }\n    Object.defineProperty(Message.prototype, \"ready\", {\n        get: function () {\n            return this._ready;\n        },\n        set: function (value) {\n            this._ready = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Message.prototype, \"message\", {\n        get: function () {\n            return this._message;\n        },\n        set: function (value) {\n            this._message = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Message;\n}());\nvar LinkedNode = (function () {\n    function LinkedNode(value) {\n        this._previous = null;\n        this._next = null;\n        this._value = value;\n    }\n    Object.defineProperty(LinkedNode.prototype, \"previous\", {\n        get: function () {\n            return this._previous;\n        },\n        set: function (value) {\n            this._previous = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedNode.prototype, \"next\", {\n        get: function () {\n            return this._next;\n        },\n        set: function (value) {\n            this._next = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedNode.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LinkedNode;\n}());\nvar LinkedList = (function () {\n    function LinkedList() {\n        this.head = null;\n        this.size = 0;\n    }\n    LinkedList.prototype.addHead = function (value) {\n        if (!this.createHeadIfNeeded(value)) {\n            var nextNode = this.head.next;\n            var newHeadNode = new LinkedNode(value);\n            if (nextNode != null) {\n                nextNode.previous = newHeadNode;\n                newHeadNode.next = nextNode;\n            }\n            this.head = newHeadNode;\n        }\n        this.size++;\n    };\n    LinkedList.prototype.addTail = function (value) {\n        if (!this.createHeadIfNeeded(value)) {\n            var oldTailNode = this.getTailNode();\n            var newTailNode = new LinkedNode(value);\n            oldTailNode.next = newTailNode;\n            newTailNode.previous = oldTailNode;\n        }\n        this.size++;\n    };\n    LinkedList.prototype.clear = function () {\n        this.head = null;\n        this.size = 0;\n    };\n    LinkedList.prototype.getHead = function () {\n        if (this.head != null) {\n            return this.head.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.removeHead = function () {\n        if (this.head != null) {\n            var oldHead = this.head;\n            var value = oldHead.value;\n            this.head = oldHead.next;\n            this.size--;\n            return value;\n        }\n        return null;\n    };\n    LinkedList.prototype.getTail = function () {\n        var node = this.getTailNode();\n        if (node != null) {\n            return node.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.removeTail = function () {\n        var node = this.getTailNode();\n        if (node != null) {\n            if (node === this.head) {\n                this.head = null;\n            }\n            else {\n                var previousNode = node.previous;\n                previousNode.next = null;\n            }\n            this.size--;\n            return node.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.getSize = function () {\n        return this.size;\n    };\n    LinkedList.prototype.createHeadIfNeeded = function (value) {\n        if (this.head == null) {\n            this.head = new LinkedNode(value);\n            return true;\n        }\n        return false;\n    };\n    LinkedList.prototype.getTailNode = function () {\n        if (this.head == null) {\n            return null;\n        }\n        var node = this.head;\n        while (node.next != null) {\n            node = node.next;\n        }\n        return node;\n    };\n    return LinkedList;\n}());\n/**\n * Abstract base logger, extend to easily implement a custom logger that\n * logs wherever you want. You only need to implement doLog(msg: string) and\n * log that somewhere (it will contain format and everything else).\n */\nvar AbstractLogger = (function () {\n    function AbstractLogger(name, rule) {\n        this.open = true;\n        this._allMessages = new LinkedList();\n        this.name = name;\n        this.rule = rule;\n        this.level = rule.level;\n    }\n    AbstractLogger.prototype.trace = function (msg, error) {\n        this.log(Logger_1.LogLevel.Trace, msg, error);\n    };\n    AbstractLogger.prototype.debug = function (msg, error) {\n        this.log(Logger_1.LogLevel.Debug, msg, error);\n    };\n    AbstractLogger.prototype.info = function (msg, error) {\n        this.log(Logger_1.LogLevel.Info, msg, error);\n    };\n    AbstractLogger.prototype.warn = function (msg, error) {\n        this.log(Logger_1.LogLevel.Warn, msg, error);\n    };\n    AbstractLogger.prototype.error = function (msg, error) {\n        this.log(Logger_1.LogLevel.Error, msg, error);\n    };\n    AbstractLogger.prototype.fatal = function (msg, error) {\n        this.log(Logger_1.LogLevel.Fatal, msg, error);\n    };\n    AbstractLogger.prototype.tracec = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Trace, msg, error);\n    };\n    AbstractLogger.prototype.debugc = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Debug, msg, error);\n    };\n    AbstractLogger.prototype.infoc = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Info, msg, error);\n    };\n    AbstractLogger.prototype.warnc = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Warn, msg, error);\n    };\n    AbstractLogger.prototype.errorc = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Error, msg, error);\n    };\n    AbstractLogger.prototype.fatalc = function (msg, error) {\n        this.logc(Logger_1.LogLevel.Fatal, msg, error);\n    };\n    AbstractLogger.prototype.isTraceEnabled = function () {\n        return this.level == Logger_1.LogLevel.Trace;\n    };\n    AbstractLogger.prototype.isDebugEnabled = function () {\n        return this.level <= Logger_1.LogLevel.Debug;\n    };\n    AbstractLogger.prototype.isInfoEnabled = function () {\n        return this.level <= Logger_1.LogLevel.Info;\n    };\n    AbstractLogger.prototype.isWarnEnabled = function () {\n        return this.level <= Logger_1.LogLevel.Warn;\n    };\n    AbstractLogger.prototype.isErrorEnabled = function () {\n        return this.level <= Logger_1.LogLevel.Error;\n    };\n    AbstractLogger.prototype.isFatalEnabled = function () {\n        return this.level <= Logger_1.LogLevel.Fatal;\n    };\n    AbstractLogger.prototype.getLogLevel = function () {\n        return this.level;\n    };\n    AbstractLogger.prototype.log = function (level, msg, error) {\n        if (this.open && this.level <= level) {\n            this._allMessages.addTail(this.createMessage(level, msg, new Date(), error));\n            this.processMessages();\n        }\n    };\n    AbstractLogger.prototype.logc = function (level, msg, error) {\n        if (this.open && this.level <= level) {\n            this._allMessages.addTail(this.createMessage(level, msg(), new Date(), error !== undefined ? error() : undefined));\n            this.processMessages();\n        }\n    };\n    AbstractLogger.prototype.isOpen = function () {\n        return this.open;\n    };\n    AbstractLogger.prototype.close = function () {\n        this.open = false;\n        this._allMessages.clear();\n    };\n    AbstractLogger.prototype.createMessage = function (level, msg, date, error) {\n        var _this = this;\n        var lpad = function (value, chars, padWith) {\n            var howMany = chars - value.length;\n            if (howMany > 0) {\n                var res = '';\n                for (var i = 0; i < howMany; i++) {\n                    res += padWith;\n                }\n                res += value;\n                return res;\n            }\n            return value;\n        };\n        var fullYear = function (date) {\n            return lpad(date.getFullYear().toString(), 4, '0');\n        };\n        var month = function (date) {\n            return lpad((date.getMonth() + 1).toString(), 2, '0');\n        };\n        var day = function (date) {\n            return lpad(date.getDate().toString(), 2, '0');\n        };\n        var hours = function (date) {\n            return lpad(date.getHours().toString(), 2, '0');\n        };\n        var minutes = function (date) {\n            return lpad(date.getMinutes().toString(), 2, '0');\n        };\n        var seconds = function (date) {\n            return lpad(date.getSeconds().toString(), 2, '0');\n        };\n        var millis = function (date) {\n            return date.getMilliseconds().toString();\n        };\n        var result = \"\";\n        if (this.rule.logFormat.showTimeStamp) {\n            var dateSeparator = this.rule.logFormat.dateFormat.dateSeparator;\n            var ds = '';\n            switch (this.rule.logFormat.dateFormat.formatEnum) {\n                case LoggerFactoryService_1.DateFormatEnum.Default:\n                    // yyyy-mm-dd hh:mm:ss,m\n                    ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + ' ' +\n                        hours(date) + ':' + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n                    break;\n                case LoggerFactoryService_1.DateFormatEnum.YearMonthDayTime:\n                    ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + ' ' +\n                        hours(date) + ':' + minutes(date) + \":\" + seconds(date);\n                    break;\n                case LoggerFactoryService_1.DateFormatEnum.YearDayMonthWithFullTime:\n                    ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + ' ' +\n                        hours(date) + ':' + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n                    break;\n                case LoggerFactoryService_1.DateFormatEnum.YearDayMonthTime:\n                    ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + ' ' +\n                        hours(date) + ':' + minutes(date) + \":\" + seconds(date);\n                    break;\n                default:\n                    throw new Error(\"Unsupported date format enum: \" + this.rule.logFormat.dateFormat.formatEnum);\n            }\n            result += ds + \" \";\n        }\n        result += Logger_1.LogLevel[level].toUpperCase() + \" \";\n        if (this.rule.logFormat.showLoggerName) {\n            result += \"[\" + this.name + \"]\";\n        }\n        result += ' ' + msg;\n        if (error !== undefined) {\n            var message_1 = new Message(false);\n            result += '\\n' + error.name + \": \" + error.message + \"\\n@\";\n            ST.fromError(error, { offline: true }).then(function (frames) {\n                var stackStr = (frames.map(function (frame) {\n                    return frame.toString();\n                })).join('\\n  ');\n                result += '\\n' + stackStr;\n                message_1.message = result;\n                message_1.ready = true;\n                _this.processMessages();\n            });\n            return message_1;\n        }\n        else {\n            return new Message(true, result);\n        }\n    };\n    AbstractLogger.prototype.processMessages = function () {\n        // Basically we wait until errors are resolved (those messages\n        // may not be ready).\n        var msgs = this._allMessages;\n        if (msgs.getSize() > 0) {\n            do {\n                var msg = msgs.getHead();\n                if (msg != null) {\n                    if (!msg.ready) {\n                        break;\n                    }\n                    msgs.removeHead();\n                    this.doLog(msg.message);\n                }\n            } while (msgs.getSize() > 0);\n        }\n    };\n    return AbstractLogger;\n}());\nexports.AbstractLogger = AbstractLogger;\n/**\n * Simple logger, that logs to the console. If the console is unavailable will throw exception.\n */\nvar ConsoleLoggerImpl = (function (_super) {\n    __extends(ConsoleLoggerImpl, _super);\n    function ConsoleLoggerImpl(name, rule) {\n        _super.call(this, name, rule);\n    }\n    ConsoleLoggerImpl.prototype.doLog = function (msg) {\n        if (console !== undefined) {\n            console.log(msg);\n        }\n        else {\n            throw new Error(\"Console is not defined, cannot log msg: \" + msg);\n        }\n    };\n    return ConsoleLoggerImpl;\n}(AbstractLogger));\nexports.ConsoleLoggerImpl = ConsoleLoggerImpl;\n/**\n * Logger which buffers all messages, use with care due to possible high memory footprint.\n * Can be convenient in some cases. Call toString() for full output, or cast to this class\n * and call getMessages() to do something with it yourself.\n */\nvar MessageBufferLoggerImpl = (function (_super) {\n    __extends(MessageBufferLoggerImpl, _super);\n    function MessageBufferLoggerImpl(name, rule) {\n        _super.call(this, name, rule);\n        this.messages = [];\n    }\n    MessageBufferLoggerImpl.prototype.doLog = function (msg) {\n        this.messages.push(msg);\n    };\n    MessageBufferLoggerImpl.prototype.close = function () {\n        this.messages = [];\n        _super.prototype.close.call(this);\n    };\n    MessageBufferLoggerImpl.prototype.getMessages = function () {\n        return this.messages;\n    };\n    MessageBufferLoggerImpl.prototype.toString = function () {\n        return this.messages.map(function (msg) {\n            return msg;\n        }).join(\"\\n\");\n    };\n    return MessageBufferLoggerImpl;\n}(AbstractLogger));\nexports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;\n//# sourceMappingURL=LoggerImpl.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/commonjs/LoggerImpl.js\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar Logger_1 = require(\"./Logger\");\nvar LoggerImpl_1 = require(\"./LoggerImpl\");\n/**\n * Defines several date enums used for formatting a date.\n */\n(function (DateFormatEnum) {\n    /**\n     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"Default\"] = 0] = \"Default\";\n    /**\n     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearMonthDayTime\"] = 1] = \"YearMonthDayTime\";\n    /**\n     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearDayMonthWithFullTime\"] = 2] = \"YearDayMonthWithFullTime\";\n    /**\n     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearDayMonthTime\"] = 3] = \"YearDayMonthTime\";\n})(exports.DateFormatEnum || (exports.DateFormatEnum = {}));\nvar DateFormatEnum = exports.DateFormatEnum;\n/**\n * DateFormat class, stores data on how to format a date.\n */\nvar DateFormat = (function () {\n    /**\n     * Constructor, can be called empty as it uses defaults.\n     * @param formatEnum DateFormatEnum\n     * @param dateSeparator Separator used between dates\n     */\n    function DateFormat(formatEnum, dateSeparator) {\n        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }\n        if (dateSeparator === void 0) { dateSeparator = '-'; }\n        this._formatEnum = formatEnum;\n        this._dateSeparator = dateSeparator;\n    }\n    Object.defineProperty(DateFormat.prototype, \"formatEnum\", {\n        get: function () {\n            return this._formatEnum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateFormat.prototype, \"dateSeparator\", {\n        get: function () {\n            return this._dateSeparator;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return DateFormat;\n}());\nexports.DateFormat = DateFormat;\n/**\n * Information about the log format, what will a log line look like?\n */\nvar LogFormat = (function () {\n    /**\n     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.\n     * @param dateFormat DateFormat (what needs the date look like in the log line)\n     * @param showTimeStamp Show date timestamp at all?\n     * @param showLoggerName Show the logger name?\n     */\n    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {\n        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n        if (showTimeStamp === void 0) { showTimeStamp = true; }\n        if (showLoggerName === void 0) { showLoggerName = true; }\n        this._showTimeStamp = true;\n        this._showLoggerName = true;\n        this._dateFormat = dateFormat;\n        this._showTimeStamp = showTimeStamp;\n        this._showLoggerName = showLoggerName;\n    }\n    Object.defineProperty(LogFormat.prototype, \"dateFormat\", {\n        get: function () {\n            return this._dateFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogFormat.prototype, \"showTimeStamp\", {\n        get: function () {\n            return this._showTimeStamp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogFormat.prototype, \"showLoggerName\", {\n        get: function () {\n            return this._showLoggerName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LogFormat;\n}());\nexports.LogFormat = LogFormat;\n/**\n * Defines a LogGroupRule, this allows you to either have everything configured the same way\n * or for example loggers that start with name model. It allows you to group loggers together\n * to have a certain loglevel and other settings. You can configure this when creating the\n * LoggerFactory (which accepts multiple LogGroupRules).\n */\nvar LogGroupRule = (function () {\n    /**\n     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n     * @param regExp Regular expression, what matches for your logger names for this group\n     * @param level LogLevel\n     * @param logFormat LogFormat\n     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n     * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n     */\n    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n        if (logFormat === void 0) { logFormat = new LogFormat(); }\n        if (loggerType === void 0) { loggerType = Logger_1.LoggerType.Console; }\n        this._regExp = regExp;\n        this._level = level;\n        this._logFormat = logFormat;\n        this._loggerType = loggerType;\n        this._callBackLogger = callBackLogger;\n    }\n    Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n        get: function () {\n            return this._regExp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"level\", {\n        get: function () {\n            return this._level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LogGroupRule;\n}());\nexports.LogGroupRule = LogGroupRule;\n/**\n * Options object you can use to configure the LoggerFactory you create at LFService.\n */\nvar LoggerFactoryOptions = (function () {\n    function LoggerFactoryOptions() {\n        this._logGroupRules = [];\n        this._enabled = true;\n    }\n    /**\n     * Add LogGroupRule, see {LogGroupRule) for details\n     * @param rule Rule to add\n     * @returns {LoggerFactoryOptions} returns itself\n     */\n    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {\n        this._logGroupRules.push(rule);\n        return this;\n    };\n    /**\n     * Enable or disable logging completely for the LoggerFactory.\n     * @param enabled True for enabled (default)\n     * @returns {LoggerFactoryOptions} returns itself\n     */\n    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {\n        this._enabled = enabled;\n        return this;\n    };\n    Object.defineProperty(LoggerFactoryOptions.prototype, \"logGroupRules\", {\n        get: function () {\n            return this._logGroupRules;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LoggerFactoryOptions.prototype, \"enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LoggerFactoryOptions;\n}());\nexports.LoggerFactoryOptions = LoggerFactoryOptions;\nvar LoggerFactoryImpl = (function () {\n    function LoggerFactoryImpl(options) {\n        this.loggers = {};\n        this.configure(options);\n    }\n    LoggerFactoryImpl.prototype.configure = function (options) {\n        this.options = options;\n        // Close any current open loggers.\n        this.closeLoggers();\n    };\n    LoggerFactoryImpl.prototype.getLogger = function (named) {\n        if (!this.options.enabled) {\n            throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n        }\n        var logger = this.loggers[named];\n        if (logger !== undefined) {\n            return logger;\n        }\n        // Initialize logger with appropriate level\n        logger = this.loadLogger(named);\n        this.loggers[named] = logger;\n        return logger;\n    };\n    LoggerFactoryImpl.prototype.isEnabled = function () {\n        return this.options.enabled;\n    };\n    LoggerFactoryImpl.prototype.closeLoggers = function () {\n        for (var key in this.loggers) {\n            this.loggers[key].close();\n        }\n        this.loggers = {};\n    };\n    LoggerFactoryImpl.prototype.loadLogger = function (named) {\n        var logGroupRules = this.options.logGroupRules;\n        for (var i = 0; i < logGroupRules.length; i++) {\n            var logGroupRule = logGroupRules[i];\n            if (logGroupRule.regExp.test(named)) {\n                switch (logGroupRule.loggerType) {\n                    case Logger_1.LoggerType.Console:\n                        return new LoggerImpl_1.ConsoleLoggerImpl(named, logGroupRule);\n                    case Logger_1.LoggerType.MessageBuffer:\n                        return new LoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRule);\n                    case Logger_1.LoggerType.Custom:\n                        return logGroupRule.callBackLogger(named, logGroupRule);\n                    default:\n                        throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n                }\n            }\n        }\n        throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n    };\n    return LoggerFactoryImpl;\n}());\n/**\n * Create and configure your LoggerFactory from here.\n */\nvar LFService = (function () {\n    function LFService() {\n    }\n    /**\n     * Create a new LoggerFactory with given options (if any). If no options\n     * are specified, the LoggerFactory, will accept any named logger and will\n     * log on info level by default for, to the console.\n     * @param options Options, optional.\n     * @returns {LoggerFactory}\n     */\n    LFService.createLoggerFactory = function (options) {\n        var factory;\n        if (options !== undefined) {\n            factory = new LoggerFactoryImpl(options);\n        }\n        else {\n            factory = new LoggerFactoryImpl(this.createDefaultOptions());\n        }\n        return factory;\n    };\n    /**\n     * Closes all Loggers for LoggerFactories that were created.\n     * After this call, all previously fetched Loggers (from their\n     * factories) are unusable. The factories remain as they were.\n     */\n    LFService.closeLoggers = function () {\n        for (var i = 0; i < this._loggerFactories.length; i++) {\n            this._loggerFactories[i].closeLoggers();\n        }\n        this._loggerFactories = [];\n    };\n    LFService.createDefaultOptions = function () {\n        return new LoggerFactoryOptions().addLogGroupRule(new LogGroupRule(new RegExp(\".+\"), Logger_1.LogLevel.Info));\n    };\n    LFService._loggerFactories = [];\n    return LFService;\n}());\nexports.LFService = LFService;\n//# sourceMappingURL=LoggerFactoryService.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/commonjs/LoggerFactoryService.js\n ** module id = 3\n ** module chunks = 0\n **/","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function(stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        },\n        sourceCache: {}\n    };\n\n    var _generateError = function StackTrace$$GenerateError() {\n        try {\n            // Error must be thrown to get stack in IE\n            throw new Error();\n        } catch (err) {\n            return err;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     *\n     * @param {Object} first base object\n     * @param {Object} second overrides\n     * @returns {Object} merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function(obj) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    function _filtered(stackframes, filter) {\n        if (typeof filter === 'function') {\n            return stackframes.filter(filter);\n        }\n        return stackframes;\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        get: function StackTrace$$get(opts) {\n            var err = _generateError();\n            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n        },\n\n        /**\n         * Get a backtrace from invocation point.\n         * IMPORTANT: Does not handle source maps or guess function names!\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        getSync: function StackTrace$$getSync(opts) {\n            opts = _merge(_options, opts);\n            var err = _generateError();\n            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n            return _filtered(stack, opts.filter);\n        },\n\n        /**\n         * Given an error object, parse it.\n         *\n         * @param {Error} error object\n         * @param {Object} opts\n         * @returns {Promise} for Array[StackFrame}\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            var gps = new StackTraceGPS(opts);\n            return new Promise(function(resolve) {\n                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                resolve(Promise.all(stackframes.map(function(sf) {\n                    return new Promise(function(resolve) {\n                        function resolveOriginal() {\n                            resolve(sf);\n                        }\n\n                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         *\n         * @param {Object} opts\n         * @returns {Promise} of Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    return fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param {Function} fn to de-instrument\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        },\n\n        /**\n         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n         *\n         * @param {Array} stackframes\n         * @param {String} url\n         * @param {String} errorMsg\n         */\n        report: function StackTrace$$report(stackframes, url, errorMsg) {\n            return new Promise(function(resolve, reject) {\n                var req = new XMLHttpRequest();\n                req.onerror = reject;\n                req.onreadystatechange = function onreadystatechange() {\n                    if (req.readyState === 4) {\n                        if (req.status >= 200 && req.status < 400) {\n                            resolve(req.responseText);\n                        } else {\n                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                        }\n                    }\n                };\n                req.open('post', url);\n                req.setRequestHeader('Content-Type', 'application/json');\n\n                var reportPayload = {stack: stackframes};\n                if (errorMsg !== undefined) {\n                    reportPayload.message = errorMsg;\n                }\n\n                req.send(JSON.stringify(reportPayload));\n            });\n        }\n    };\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stacktrace-js/stacktrace.js\n ** module id = 4\n ** module chunks = 0\n **/","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    function _map(array, fn, thisArg) {\n        if (typeof Array.prototype.map === 'function') {\n            return array.map(fn, thisArg);\n        } else {\n            var output = new Array(array.length);\n            for (var i = 0; i < array.length; i++) {\n                output[i] = fn.call(thisArg, array[i]);\n            }\n            return output;\n        }\n    }\n\n    function _filter(array, fn, thisArg) {\n        if (typeof Array.prototype.filter === 'function') {\n            return array.filter(fn, thisArg);\n        } else {\n            var output = [];\n            for (var i = 0; i < array.length; i++) {\n                if (fn.call(thisArg, array[i])) {\n                    output.push(array[i]);\n                }\n            }\n            return output;\n        }\n    }\n\n    function _indexOf(array, target) {\n        if (typeof Array.prototype.indexOf === 'function') {\n            return array.indexOf(target);\n        } else {\n            for (var i = 0; i < array.length; i++) {\n                if (array[i] === target) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame(line);\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n                    return new StackFrame(functionName,\n                        undefined,\n                        locationParts[0],\n                        locationParts[1],\n                        locationParts[2],\n                        line);\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame(\n                            match[3] || undefined,\n                            undefined,\n                            match[2],\n                            match[1],\n                            undefined,\n                            lines[i]\n                        )\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return _map(filtered, function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n                return new StackFrame(\n                    functionName,\n                    args,\n                    locationParts[0],\n                    locationParts[1],\n                    locationParts[2],\n                    line);\n            }, this);\n        }\n    };\n}));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/error-stack-parser/error-stack-parser.js\n ** module id = 5\n ** module chunks = 0\n **/","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n        if (functionName !== undefined) {\n            this.setFunctionName(functionName);\n        }\n        if (args !== undefined) {\n            this.setArgs(args);\n        }\n        if (fileName !== undefined) {\n            this.setFileName(fileName);\n        }\n        if (lineNumber !== undefined) {\n            this.setLineNumber(lineNumber);\n        }\n        if (columnNumber !== undefined) {\n            this.setColumnNumber(columnNumber);\n        }\n        if (source !== undefined) {\n            this.setSource(source);\n        }\n    }\n\n    StackFrame.prototype = {\n        getFunctionName: function () {\n            return this.functionName;\n        },\n        setFunctionName: function (v) {\n            this.functionName = String(v);\n        },\n\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        // NOTE: Property name may be misleading as it includes the path,\n        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n        getFileName: function () {\n            return this.fileName;\n        },\n        setFileName: function (v) {\n            this.fileName = String(v);\n        },\n\n        getLineNumber: function () {\n            return this.lineNumber;\n        },\n        setLineNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Line Number must be a Number');\n            }\n            this.lineNumber = Number(v);\n        },\n\n        getColumnNumber: function () {\n            return this.columnNumber;\n        },\n        setColumnNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Column Number must be a Number');\n            }\n            this.columnNumber = Number(v);\n        },\n\n        getSource: function () {\n            return this.source;\n        },\n        setSource: function (v) {\n            this.source = String(v);\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    return StackFrame;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stackframe/stackframe.js\n ** module id = 6\n ** module chunks = 0\n **/","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stack-generator', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.StackGenerator = factory(root.StackFrame);\n    }\n}(this, function (StackFrame) {\n    return {\n        backtrace: function StackGenerator$$backtrace(opts) {\n            var stack = [];\n            var maxStackSize = 10;\n\n            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n                maxStackSize = opts.maxStackSize;\n            }\n\n            var curr = arguments.callee;\n            while (curr && stack.length < maxStackSize) {\n                // Allow V8 optimizations\n                var args = new Array(curr['arguments'].length);\n                for(var i = 0; i < args.length; ++i) {\n                    args[i] = curr['arguments'][i];\n                }\n                if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n                    stack.push(new StackFrame(RegExp.$1 || undefined, args));\n                } else {\n                    stack.push(new StackFrame(undefined, args));\n                }\n\n                try {\n                    curr = curr.caller;\n                } catch (e) {\n                    break;\n                }\n            }\n            return stack;\n        }\n    };\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stack-generator/stack-generator.js\n ** module id = 7\n ** module chunks = 0\n **/","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if (req.status >= 200 && req.status < 300) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        // function {name}({args}) m[1]=name m[2]=args\n        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n        // {name} = function ({args}) TODO args capture\n        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n        // {name} = eval()\n        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        var m;\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                m = reFunctionExpression.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionDeclaration.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionEvaluation.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n        if (m && m[1]) {\n            return m[1];\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\n            var loc = mapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                var mappedSource = mapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n                resolve(\n                    new StackFrame(\n                        loc.name || stackframe.functionName,\n                        stackframe.args,\n                        loc.source,\n                        loc.line,\n                        loc.column));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame(guessedFunctionName,\n                            stackframe.args,\n                            stackframe.fileName,\n                            lineNumber,\n                            columnNumber));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = base + sourceMappingURL;\n                    }\n\n                    this._get(sourceMappingURL).then(function(sourceMap) {\n                        if (typeof sourceMap === 'string') {\n                            sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n                        }\n                        if (typeof sourceMap.sourceRoot === 'undefined') {\n                            sourceMap.sourceRoot = base;\n                        }\n\n                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)\n                            .then(resolve)['catch'](function() {\n                            resolve(stackframe);\n                        });\n                    }, reject)['catch'](reject);\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stacktrace-gps/stacktrace-gps.js\n ** module id = 8\n ** module chunks = 0\n **/","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/source-map.js\n ** module id = 9\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/source-map-generator.js\n ** module id = 10\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/base64-vlq.js\n ** module id = 11\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/base64.js\n ** module id = 12\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/util.js\n ** module id = 13\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/array-set.js\n ** module id = 14\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/mapping-list.js\n ** module id = 15\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/source-map-consumer.js\n ** module id = 16\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/binary-search.js\n ** module id = 17\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/quick-sort.js\n ** module id = 18\n ** module chunks = 0\n **/","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/source-map/lib/source-node.js\n ** module id = 19\n ** module chunks = 0\n **/"],"sourceRoot":""}