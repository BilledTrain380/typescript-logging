{"version":3,"sources":["webpack:///typescript-logging.bundle.min.js","webpack:///webpack/bootstrap 25566c33c3497128f473","webpack:///./dist/commonjs/typescript-logging.js","webpack:///./dist/commonjs/AbstractCategoryLogger.js","webpack:///./dist/commonjs/DataStructures.js","webpack:///./dist/commonjs/LoggerOptions.js","webpack:///./dist/commonjs/MessageUtils.js","webpack:///./~/stacktrace-js/stacktrace.js","webpack:///./~/error-stack-parser/error-stack-parser.js","webpack:///./~/stackframe/stackframe.js","webpack:///./~/stack-generator/stack-generator.js","webpack:///./~/stack-generator/~/stackframe/stackframe.js","webpack:///./~/stacktrace-gps/stacktrace-gps.js","webpack:///./~/source-map/source-map.js","webpack:///./~/source-map/lib/source-map-generator.js","webpack:///./~/source-map/lib/base64-vlq.js","webpack:///./~/source-map/lib/base64.js","webpack:///./~/source-map/lib/util.js","webpack:///./~/source-map/lib/array-set.js","webpack:///./~/source-map/lib/mapping-list.js","webpack:///./~/source-map/lib/source-map-consumer.js","webpack:///./~/source-map/lib/binary-search.js","webpack:///./~/source-map/lib/quick-sort.js","webpack:///./~/source-map/lib/source-node.js","webpack:///./dist/commonjs/CategoryConsoleLoggerImpl.js","webpack:///./dist/commonjs/CategoryDelegateLoggerImpl.js","webpack:///./dist/commonjs/CategoryLogger.js","webpack:///./dist/commonjs/CategoryService.js","webpack:///./dist/commonjs/CategoryExtensionLoggerImpl.js","webpack:///./dist/commonjs/ExtensionHelper.js","webpack:///./dist/commonjs/CategoryMessageBufferImpl.js","webpack:///./dist/commonjs/LoggerFactoryService.js","webpack:///./dist/commonjs/LoggerFactoryImpl.js","webpack:///./dist/commonjs/LoggerImpl.js","webpack:///./dist/commonjs/JSONHelper.js"],"names":["TSL","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__export","hasOwnProperty","AbstractCategoryLogger_1","AbstractCategoryLogger","CategoryConsoleLoggerImpl_1","CategoryConsoleLoggerImpl","CategoryDelegateLoggerImpl_1","CategoryDelegateLoggerImpl","CategoryLogger_1","Category","CategoryMessageBufferImpl_1","CategoryMessageBufferLoggerImpl","CategoryService_1","CategoryDefaultConfiguration","CategoryRuntimeSettings","CategoryServiceFactory","LoggerFactoryService_1","LoggerFactoryOptions","LFService","LogGroupRule","LoggerImpl_1","AbstractLogger","ConsoleLoggerImpl","MessageBufferLoggerImpl","LoggerOptions_1","CategoryLogFormat","DateFormat","DateFormatEnum","LogFormat","LoggerType","LogLevel","MessageUtils_1","MessageFormatUtils","DataStructures_1","SimpleMap","LinkedList","ExtensionHelper_1","ExtensionHelper","CategoryLogMessageImpl","message","error","categories","date","level","logFormat","ready","this","_resolvedErrorMessage","errorAsStack","prototype","getMessage","getErrorAsStack","setErrorAsStack","stack","getError","getCategories","getDate","getLevel","getLogFormat","isReady","setReady","value","Object","defineProperty","get","set","enumerable","configurable","isResolvedErrorMessage","rootCategory","runtimeSettings","allMessages","trace","msg","_i","arguments","length","_log","apply","Trace","concat","debug","Debug","info","Info","warn","Warn","Error","fatal","Fatal","resolved","log","tracec","_logc","debugc","infoc","warnc","errorc","fatalc","resolvedc","logc","getRootCategory","createDefaultLogMessage","renderDefaultMessage","_logInternal","_this","logCateries","undefined","push","_loop_1","i","category","settings","this_1","getCategorySettings","getCategoryPath","logLevel","actualError","logMessage","Date","resolvedErrorMessage","addTail","processMessages","logMessage_1","renderError","then","state_1","msgs","getSize","getHead","removeHead","doLog","LinkedNode","_previous","_next","_value","head","size","addHead","createHeadIfNeeded","nextNode","next","newHeadNode","previous","oldTailNode","getTailNode","newTailNode","clear","oldHead","getTail","node","removeTail","previousNode","filter","f","recurse","fn","values","result","array","put","key","exists","remove","keys","isEmpty","TuplePair","x","y","_x","_y","StringBuilder","data","append","line","appendLine","toString","separator","join","fromString","val","toLowerCase","formatEnum","dateSeparator","Default","_formatEnum","_dateSeparator","dateFormat","showTimeStamp","showLoggerName","_showTimeStamp","_showLoggerName","_dateFormat","showCategoryName","_showCategoryName","ST","renderDate","lpad","chars","padWith","howMany","res","fullYear","d","getFullYear","month","getMonth","day","hours","getHours","minutes","getMinutes","seconds","getSeconds","millis","getMilliseconds","ds","YearMonthDayTime","YearDayMonthWithFullTime","YearDayMonthTime","addStack","toUpperCase","forEach","idx","name","Promise","resolve","fromError","offline","frames","stackStr","map","frame","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","ErrorStackParser","StackGenerator","StackTraceGPS","_merge","first","second","target","obj","prop","_isShapedLikeParsableError","err","_filtered","stackframes","_options","stackframe","functionName","indexOf","sourceCache","_generateError","opts","generateArtificially","getSync","parse","backtrace","gps","all","sf","resolveOriginal","pinpoint","bind","stackFrames","instrument","callback","errback","thisArg","__stacktraceOriginalFn","instrumented","e","deinstrument","report","url","errorMsg","reject","req","XMLHttpRequest","onerror","onreadystatechange","readyState","status","responseText","open","setRequestHeader","reportPayload","send","JSON","stringify","StackFrame","_map","Array","output","_filter","_indexOf","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stacktrace","parseOpera","match","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","regExp","parts","exec","replace","filtered","split","tokens","slice","locationParts","pop","fileName","parseOpera9","parseOpera11","parseOpera10","lineRE","lines","len","argsRaw","functionCall","shift","args","_isNumber","n","isNaN","parseFloat","isFinite","lineNumber","columnNumber","source","setFunctionName","setArgs","setFileName","setLineNumber","setColumnNumber","setSource","getFunctionName","v","String","getArgs","TypeError","getFileName","getLineNumber","Number","getColumnNumber","getSource","maxStackSize","curr","callee","test","RegExp","$1","caller","_capitalize","str","substring","_getter","props","booleanProps","numericProps","stringProps","arrayProps","getEvalOrigin","evalOrigin","setEvalOrigin","Boolean","j","k","SourceMap","_xdr","_atob","b64str","window","atob","_parseJson","string","_findFunctionName","reFunctionDeclaration","reFunctionExpression","reFunctionEvaluation","code","maxLines","Math","min","commentPos","substr","_ensureSupportedEnvironment","create","_ensureStackFrameIsLegit","_findSourceMappingURL","_extractLocationInfoFromSourceMap","rawSourceMap","mapConsumer","SourceMapConsumer","loc","originalPositionFor","column","mappedSource","sourceContentFor","ajax","_get","location","isDataUrl","supportedEncodingRegexp","sourceMapStart","encodedSource","xhrPromise","method","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","guessedFunctionName","sourceMappingURL","base","lastIndexOf","sourceMap","sourceRoot","SourceMapGenerator","SourceNode","aArgs","_file","util","getArg","_sourceRoot","_skipValidation","_sources","ArraySet","_names","_mappings","MappingList","_sourcesContents","base64VLQ","_version","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","generatedLine","generatedColumn","relative","original","originalLine","originalColumn","addMapping","sources","sourceFile","content","setSourceContent","_validateMapping","has","add","aSourceFile","aSourceContent","toSetString","applySourceMap","aSourceMapPath","newSources","newNames","unsortedForEach","aGenerated","aOriginal","aSource","aName","_serializeMappings","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","toArray","compareByGeneratedPositionsInflated","encode","_generateSourcesContent","aSources","aSourceRoot","toJSON","version","names","sourcesContent","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","digit","encoded","vlq","decode","aStr","aIndex","aOutParam","continuation","strLen","charCodeAt","charAt","rest","intToCharMap","number","charCode","bigA","bigZ","littleA","littleZ","zero","nine","plus","slash","littleOffset","numberOffset","aDefaultValue","urlParse","aUrl","urlRegexp","scheme","auth","host","port","path","urlGenerate","aParsedUrl","normalize","aPath","part","isAbsolute","up","splice","aRoot","aPathUrl","aRootUrl","dataUrlRegexp","joined","index","identity","s","isProtoString","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","compareByGeneratedPositionsDeflated","onlyCompareGenerated","strcmp","aStr1","aStr2","supportsNullProto","_array","_set","fromArray","aArray","aAllowDuplicates","getOwnPropertyNames","sStr","isDuplicate","at","aIdx","generatedPositionAfter","lineA","lineB","columnA","columnB","_sorted","_last","aCallback","aThisArg","aMapping","sort","aSourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","Mapping","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","binarySearch","quickSort","__generatedMappings","_parseMappings","__originalMappings","_charIsMappingSeparator","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","aContext","aOrder","context","order","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findMapping","lastColumn","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","segment","end","cachedSegments","temp","originalMappings","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","some","sc","nullOnMissing","fileUriAbsPath","generatedPositionFor","constructor","sectionIndex","section","bias","every","generatedPosition","ret","sectionMappings","adjustedMapping","recursiveSearch","aLow","aHigh","aHaystack","aCompare","mid","floor","swap","ary","randomIntInRange","low","high","round","random","doQuickSort","comparator","r","pivotIndex","pivot","q","aLine","aColumn","aChunks","children","sourceContents","isSourceNode","REGEX_NEWLINE","NEWLINE_CODE","fromStringWithSourceMap","aGeneratedCode","aRelativePath","addMappingWithCode","remainingLines","shiftNextLine","lineContents","newLine","lastGeneratedLine","lastMapping","nextLine","aChunk","isArray","chunk","prepend","unshift","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent","__extends","b","__","_super","fullMsg","console","logged","delegate","_delegate","_a","parent","_children","_logLevel","_id","nextId","_name","_parent","CategoryServiceImpl","getInstance","registerCategory","cat","currentId","CategoryExtensionLoggerImpl_1","loggerType","callBackLogger","Console","_category","_loggerType","_logFormat","_callBackLogger","Custom","defaultConfig","rootCategories","categoryRuntimeSettings","rootLoggers","register","INSTANCE","getLogger","rootCategoryExists","pair","logger","createRootLogger","setDefaultConfiguration","config","reset","newRuntimeSettings_1","setting","setConfigurationCategory","applyChildren","resetRootLogger","categorySettings","child","tupleLogger","initializeRuntimeSettingsForCategory","enableExtensionIntegration","delegateLogger","CategoryExtensionLoggerImpl","getRootCategories","getCategoryById","MessageBuffer","getRuntimeSettings","sendCategoryLogMessage","registered","instance","sendRootCategoriesToExtension","cats","getAllCategories","sendCategoriesRuntimeUpdateMessage","processMessageFromExtension","from","type","valueRequest","catsApplied","applyLogLevel","categoryId","recursive","categoryIds","formattedMessage","sendMessage","service","catLevels","catSettings","getCategoryAsJSON","childCategories","parentId","_applyLogLevelRecursive","addCats","allCats","catChild","postMessage","messages","getMessages","LoggerFactoryImpl_1","_regExp","_level","_logGroupRules","_enabled","addLogGroupRule","rule","setEnabled","enabled","createLoggerFactory","options","LoggerFactoryImpl","createDefaultOptions","_loggerFactories","closeLoggers","loggerFactory","loggers","configure","named","loadLogger","isEnabled","close","logGroupRules","logGroupRules_1","logGroupRule","Message","_ready","_message","_allMessages","isTraceEnabled","isDebugEnabled","isInfoEnabled","isWarnEnabled","isErrorEnabled","isFatalEnabled","getLogLevel","isOpen","createMessage","message_1","stackResult","JSONTypeImpl","getValue","JSONBooleanType","JSONNumberType","JSONStringType","JSONObjectType","JSONArrayType","JSONNullType","JSONTypeConverter","toJSONType","JSONObject","addBoolean","checkName","checkValue","addNumber","addString","addNull","addArray","addObject","object","pretty","comma","buffer","JSONArray","objects","JSONHelper","categoryToJSON","arr","_categoryToJSON"],"mappings":"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","file":"typescript-logging.bundle.min.js","sourcesContent":["var TSL =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tfunction __export(m) {\n\t    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t}\n\tvar AbstractCategoryLogger_1 = __webpack_require__(1);\n\texports.AbstractCategoryLogger = AbstractCategoryLogger_1.AbstractCategoryLogger;\n\tvar CategoryConsoleLoggerImpl_1 = __webpack_require__(22);\n\texports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl;\n\tvar CategoryDelegateLoggerImpl_1 = __webpack_require__(23);\n\texports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl;\n\tvar CategoryLogger_1 = __webpack_require__(24);\n\texports.Category = CategoryLogger_1.Category;\n\tvar CategoryMessageBufferImpl_1 = __webpack_require__(28);\n\texports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl;\n\tvar CategoryService_1 = __webpack_require__(25);\n\texports.CategoryDefaultConfiguration = CategoryService_1.CategoryDefaultConfiguration;\n\texports.CategoryRuntimeSettings = CategoryService_1.CategoryRuntimeSettings;\n\texports.CategoryServiceFactory = CategoryService_1.CategoryServiceFactory;\n\tvar LoggerFactoryService_1 = __webpack_require__(29);\n\texports.LoggerFactoryOptions = LoggerFactoryService_1.LoggerFactoryOptions;\n\texports.LFService = LoggerFactoryService_1.LFService;\n\texports.LogGroupRule = LoggerFactoryService_1.LogGroupRule;\n\tvar LoggerImpl_1 = __webpack_require__(31);\n\texports.AbstractLogger = LoggerImpl_1.AbstractLogger;\n\texports.ConsoleLoggerImpl = LoggerImpl_1.ConsoleLoggerImpl;\n\texports.MessageBufferLoggerImpl = LoggerImpl_1.MessageBufferLoggerImpl;\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\texports.CategoryLogFormat = LoggerOptions_1.CategoryLogFormat;\n\texports.DateFormat = LoggerOptions_1.DateFormat;\n\texports.DateFormatEnum = LoggerOptions_1.DateFormatEnum;\n\texports.LogFormat = LoggerOptions_1.LogFormat;\n\texports.LoggerType = LoggerOptions_1.LoggerType;\n\texports.LogLevel = LoggerOptions_1.LogLevel;\n\tvar MessageUtils_1 = __webpack_require__(4);\n\texports.MessageFormatUtils = MessageUtils_1.MessageFormatUtils;\n\tvar DataStructures_1 = __webpack_require__(2);\n\texports.SimpleMap = DataStructures_1.SimpleMap;\n\texports.LinkedList = DataStructures_1.LinkedList;\n\t__export(__webpack_require__(32));\n\tvar ExtensionHelper_1 = __webpack_require__(27);\n\texports.ExtensionHelper = ExtensionHelper_1.ExtensionHelper;\n\t//# sourceMappingURL=typescript-logging.js.map\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar DataStructures_1 = __webpack_require__(2);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\tvar MessageUtils_1 = __webpack_require__(4);\n\tvar CategoryLogMessageImpl = (function () {\n\t    function CategoryLogMessageImpl(message, error, categories, date, level, logFormat, ready) {\n\t        this._resolvedErrorMessage = false;\n\t        this.errorAsStack = null;\n\t        this.message = message;\n\t        this.error = error;\n\t        this.categories = categories;\n\t        this.date = date;\n\t        this.level = level;\n\t        this.logFormat = logFormat;\n\t        this.ready = ready;\n\t    }\n\t    CategoryLogMessageImpl.prototype.getMessage = function () {\n\t        return this.message;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getErrorAsStack = function () {\n\t        return this.errorAsStack;\n\t    };\n\t    CategoryLogMessageImpl.prototype.setErrorAsStack = function (stack) {\n\t        this.errorAsStack = stack;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getError = function () {\n\t        return this.error;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getCategories = function () {\n\t        return this.categories;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getDate = function () {\n\t        return this.date;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getLevel = function () {\n\t        return this.level;\n\t    };\n\t    CategoryLogMessageImpl.prototype.getLogFormat = function () {\n\t        return this.logFormat;\n\t    };\n\t    CategoryLogMessageImpl.prototype.isReady = function () {\n\t        return this.ready;\n\t    };\n\t    CategoryLogMessageImpl.prototype.setReady = function (value) {\n\t        this.ready = value;\n\t    };\n\t    Object.defineProperty(CategoryLogMessageImpl.prototype, \"resolvedErrorMessage\", {\n\t        get: function () {\n\t            return this._resolvedErrorMessage;\n\t        },\n\t        set: function (value) {\n\t            this._resolvedErrorMessage = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    CategoryLogMessageImpl.prototype.isResolvedErrorMessage = function () {\n\t        return this._resolvedErrorMessage;\n\t    };\n\t    return CategoryLogMessageImpl;\n\t}());\n\t/**\n\t * Abstract category logger, use as your base class for new type of loggers (it\n\t * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument\n\t * provides full access to anything related to the logging event.\n\t * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on\n\t * this class which will return you the formatted log message as string (e.g. the\n\t * default loggers all use this).\n\t */\n\tvar AbstractCategoryLogger = (function () {\n\t    function AbstractCategoryLogger(rootCategory, runtimeSettings) {\n\t        this.allMessages = new DataStructures_1.LinkedList();\n\t        this.rootCategory = rootCategory;\n\t        this.runtimeSettings = runtimeSettings;\n\t    }\n\t    AbstractCategoryLogger.prototype.trace = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, null, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.debug = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, null, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.info = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Info, msg, null, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.warn = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, null, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.error = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.fatal = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.resolved = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.log = function (level, msg, error) {\n\t        var categories = [];\n\t        for (var _i = 3; _i < arguments.length; _i++) {\n\t            categories[_i - 3] = arguments[_i];\n\t        }\n\t        this._log.apply(this, [level, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.tracec = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, function () { return null; }, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.debugc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, function () { return null; }, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.infoc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Info, msg, function () { return null; }, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.warnc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, function () { return null; }, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.errorc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.fatalc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.resolvedc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.logc = function (level, msg, error) {\n\t        var categories = [];\n\t        for (var _i = 3; _i < arguments.length; _i++) {\n\t            categories[_i - 3] = arguments[_i];\n\t        }\n\t        this._logc.apply(this, [level, msg, error, false].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype.getRootCategory = function () {\n\t        return this.rootCategory;\n\t    };\n\t    AbstractCategoryLogger.prototype.createDefaultLogMessage = function (msg) {\n\t        return MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, true);\n\t    };\n\t    AbstractCategoryLogger.prototype._log = function (level, msg, error, resolved) {\n\t        if (error === void 0) { error = null; }\n\t        if (resolved === void 0) { resolved = false; }\n\t        var categories = [];\n\t        for (var _i = 4; _i < arguments.length; _i++) {\n\t            categories[_i - 4] = arguments[_i];\n\t        }\n\t        this._logInternal.apply(this, [level, function () { return msg; }, function () { return error; }, resolved].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype._logc = function (level, msg, error, resolved) {\n\t        if (resolved === void 0) { resolved = false; }\n\t        var categories = [];\n\t        for (var _i = 4; _i < arguments.length; _i++) {\n\t            categories[_i - 4] = arguments[_i];\n\t        }\n\t        this._logInternal.apply(this, [level, msg, error, resolved].concat(categories));\n\t    };\n\t    AbstractCategoryLogger.prototype._logInternal = function (level, msg, error, resolved) {\n\t        var _this = this;\n\t        var categories = [];\n\t        for (var _i = 4; _i < arguments.length; _i++) {\n\t            categories[_i - 4] = arguments[_i];\n\t        }\n\t        var logCateries;\n\t        // Log root category by default if none present\n\t        if (categories !== undefined && categories.length > 0) {\n\t            logCateries = categories;\n\t        }\n\t        else {\n\t            logCateries = [];\n\t            logCateries.push(this.rootCategory);\n\t        }\n\t        var _loop_1 = function (i) {\n\t            var category = logCateries[i];\n\t            if (category == null) {\n\t                throw new Error(\"Cannot have a null element within categories, at index=\" + i);\n\t            }\n\t            var settings = this_1.runtimeSettings.getCategorySettings(category);\n\t            if (settings == null) {\n\t                throw new Error(\"Category with path: \" + category.getCategoryPath() + \" is not registered with this logger, maybe \" +\n\t                    \"you registered it with a different root logger?\");\n\t            }\n\t            if (settings.logLevel <= level) {\n\t                var actualError = error != null ? error() : null;\n\t                if (actualError == null) {\n\t                    var logMessage = new CategoryLogMessageImpl(msg(), actualError, logCateries, new Date(), level, settings.logFormat, true);\n\t                    logMessage.resolvedErrorMessage = resolved;\n\t                    this_1.allMessages.addTail(logMessage);\n\t                    this_1.processMessages();\n\t                }\n\t                else {\n\t                    var logMessage_1 = new CategoryLogMessageImpl(msg(), actualError, logCateries, new Date(), level, settings.logFormat, false);\n\t                    logMessage_1.resolvedErrorMessage = resolved;\n\t                    this_1.allMessages.addTail(logMessage_1);\n\t                    MessageUtils_1.MessageFormatUtils.renderError(actualError).then(function (stack) {\n\t                        logMessage_1.setErrorAsStack(stack);\n\t                        logMessage_1.setReady(true);\n\t                        _this.processMessages();\n\t                    });\n\t                }\n\t                return \"break\";\n\t            }\n\t        };\n\t        var this_1 = this;\n\t        // Get the runtime levels for given categories. If their level is lower than given level, we log.\n\t        // In addition we pass along which category/categories we log this statement for.\n\t        for (var i = 0; i < logCateries.length; i++) {\n\t            var state_1 = _loop_1(i);\n\t            if (state_1 === \"break\")\n\t                break;\n\t        }\n\t    };\n\t    AbstractCategoryLogger.prototype.processMessages = function () {\n\t        // Basically we wait until errors are resolved (those messages\n\t        // may not be ready).\n\t        var msgs = this.allMessages;\n\t        if (msgs.getSize() > 0) {\n\t            do {\n\t                var msg = msgs.getHead();\n\t                if (msg != null) {\n\t                    if (!msg.isReady()) {\n\t                        break;\n\t                    }\n\t                    msgs.removeHead();\n\t                    this.doLog(msg);\n\t                }\n\t            } while (msgs.getSize() > 0);\n\t        }\n\t    };\n\t    return AbstractCategoryLogger;\n\t}());\n\texports.AbstractCategoryLogger = AbstractCategoryLogger;\n\t//# sourceMappingURL=AbstractCategoryLogger.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar LinkedNode = (function () {\n\t    function LinkedNode(value) {\n\t        this._previous = null;\n\t        this._next = null;\n\t        this._value = value;\n\t    }\n\t    Object.defineProperty(LinkedNode.prototype, \"previous\", {\n\t        get: function () {\n\t            return this._previous;\n\t        },\n\t        set: function (value) {\n\t            this._previous = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LinkedNode.prototype, \"next\", {\n\t        get: function () {\n\t            return this._next;\n\t        },\n\t        set: function (value) {\n\t            this._next = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LinkedNode.prototype, \"value\", {\n\t        get: function () {\n\t            return this._value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LinkedNode;\n\t}());\n\t/**\n\t * Double linkedlist implementation.\n\t */\n\tvar LinkedList = (function () {\n\t    function LinkedList() {\n\t        this.head = null;\n\t        this.size = 0;\n\t    }\n\t    LinkedList.prototype.addHead = function (value) {\n\t        if (!this.createHeadIfNeeded(value)) {\n\t            if (this.head != null) {\n\t                var nextNode = this.head.next;\n\t                var newHeadNode = new LinkedNode(value);\n\t                if (nextNode != null) {\n\t                    nextNode.previous = newHeadNode;\n\t                    newHeadNode.next = nextNode;\n\t                }\n\t                this.head = newHeadNode;\n\t            }\n\t            else {\n\t                throw new Error(\"This should never happen, list implementation broken\");\n\t            }\n\t        }\n\t        this.size++;\n\t    };\n\t    LinkedList.prototype.addTail = function (value) {\n\t        if (!this.createHeadIfNeeded(value)) {\n\t            var oldTailNode = this.getTailNode();\n\t            if (oldTailNode != null) {\n\t                var newTailNode = new LinkedNode(value);\n\t                oldTailNode.next = newTailNode;\n\t                newTailNode.previous = oldTailNode;\n\t            }\n\t            else {\n\t                throw new Error(\"List implementation broken\");\n\t            }\n\t        }\n\t        this.size++;\n\t    };\n\t    LinkedList.prototype.clear = function () {\n\t        this.head = null;\n\t        this.size = 0;\n\t    };\n\t    LinkedList.prototype.getHead = function () {\n\t        if (this.head != null) {\n\t            return this.head.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.removeHead = function () {\n\t        if (this.head != null) {\n\t            var oldHead = this.head;\n\t            var value = oldHead.value;\n\t            this.head = oldHead.next;\n\t            this.size--;\n\t            return value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.getTail = function () {\n\t        var node = this.getTailNode();\n\t        if (node != null) {\n\t            return node.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.removeTail = function () {\n\t        var node = this.getTailNode();\n\t        if (node != null) {\n\t            if (node === this.head) {\n\t                this.head = null;\n\t            }\n\t            else {\n\t                var previousNode = node.previous;\n\t                if (previousNode != null) {\n\t                    previousNode.next = null;\n\t                }\n\t                else {\n\t                    throw new Error(\"List implementation is broken\");\n\t                }\n\t            }\n\t            this.size--;\n\t            return node.value;\n\t        }\n\t        return null;\n\t    };\n\t    LinkedList.prototype.getSize = function () {\n\t        return this.size;\n\t    };\n\t    LinkedList.prototype.filter = function (f) {\n\t        var recurse = function (fn, node, values) {\n\t            if (fn(node.value)) {\n\t                values.push(node.value);\n\t            }\n\t            var nextNode = node.next;\n\t            if (nextNode != null) {\n\t                recurse(fn, nextNode, values);\n\t            }\n\t        };\n\t        var result = [];\n\t        var node = this.head;\n\t        if (node != null) {\n\t            recurse(f, node, result);\n\t        }\n\t        return result;\n\t    };\n\t    LinkedList.prototype.createHeadIfNeeded = function (value) {\n\t        if (this.head == null) {\n\t            this.head = new LinkedNode(value);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    LinkedList.prototype.getTailNode = function () {\n\t        if (this.head == null) {\n\t            return null;\n\t        }\n\t        var node = this.head;\n\t        while (node.next != null) {\n\t            node = node.next;\n\t        }\n\t        return node;\n\t    };\n\t    return LinkedList;\n\t}());\n\texports.LinkedList = LinkedList;\n\t/**\n\t * Map implementation keyed by string (always). Note that the get/remove return either value or null.\n\t * This map does not support undefined in any fasion (on purpose).\n\t */\n\tvar SimpleMap = (function () {\n\t    function SimpleMap() {\n\t        this.array = {};\n\t    }\n\t    SimpleMap.prototype.put = function (key, value) {\n\t        if (value === undefined) {\n\t            throw new Error(\"Undefined value is not allowed, null is.\");\n\t        }\n\t        this.array[key] = value;\n\t    };\n\t    SimpleMap.prototype.get = function (key) {\n\t        var value = this.array[key];\n\t        if (value !== undefined) {\n\t            return value;\n\t        }\n\t        return null;\n\t    };\n\t    SimpleMap.prototype.exists = function (key) {\n\t        var value = this.array[key];\n\t        return value !== undefined;\n\t    };\n\t    SimpleMap.prototype.remove = function (key) {\n\t        var value = this.array[key];\n\t        if (value !== undefined) {\n\t            delete this.array[key];\n\t        }\n\t        return value;\n\t    };\n\t    SimpleMap.prototype.keys = function () {\n\t        var keys = [];\n\t        for (var key in this.array) {\n\t            // To prevent random stuff to appear\n\t            if (this.array.hasOwnProperty(key)) {\n\t                keys.push(key);\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\t    SimpleMap.prototype.values = function () {\n\t        var values = [];\n\t        for (var key in this.array) {\n\t            // To prevent random stuff to appear\n\t            if (this.array.hasOwnProperty(key)) {\n\t                values.push(this.get(key));\n\t            }\n\t        }\n\t        return values;\n\t    };\n\t    SimpleMap.prototype.size = function () {\n\t        return this.keys().length;\n\t    };\n\t    SimpleMap.prototype.isEmpty = function () {\n\t        return this.size() === 0;\n\t    };\n\t    SimpleMap.prototype.clear = function () {\n\t        this.array = {};\n\t    };\n\t    return SimpleMap;\n\t}());\n\texports.SimpleMap = SimpleMap;\n\t/**\n\t * Tuple to hold two values.\n\t */\n\tvar TuplePair = (function () {\n\t    function TuplePair(x, y) {\n\t        this._x = x;\n\t        this._y = y;\n\t    }\n\t    Object.defineProperty(TuplePair.prototype, \"x\", {\n\t        get: function () {\n\t            return this._x;\n\t        },\n\t        set: function (value) {\n\t            this._x = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(TuplePair.prototype, \"y\", {\n\t        get: function () {\n\t            return this._y;\n\t        },\n\t        set: function (value) {\n\t            this._y = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return TuplePair;\n\t}());\n\texports.TuplePair = TuplePair;\n\t/**\n\t * Utility class to build up a string.\n\t */\n\tvar StringBuilder = (function () {\n\t    function StringBuilder() {\n\t        this.data = [];\n\t    }\n\t    StringBuilder.prototype.append = function (line) {\n\t        if (line === undefined || line == null) {\n\t            throw new Error(\"String must be set, cannot append null or undefined\");\n\t        }\n\t        this.data.push(line);\n\t        return this;\n\t    };\n\t    StringBuilder.prototype.appendLine = function (line) {\n\t        this.data.push(line + \"\\n\");\n\t        return this;\n\t    };\n\t    StringBuilder.prototype.isEmpty = function () {\n\t        return this.data.length === 0;\n\t    };\n\t    StringBuilder.prototype.clear = function () {\n\t        this.data = [];\n\t    };\n\t    StringBuilder.prototype.toString = function (separator) {\n\t        if (separator === void 0) { separator = \"\"; }\n\t        return this.data.join(separator);\n\t    };\n\t    return StringBuilder;\n\t}());\n\texports.StringBuilder = StringBuilder;\n\t//# sourceMappingURL=DataStructures.js.map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Log level for a logger.\n\t */\n\t(function (LogLevel) {\n\t    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n\t    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n\t    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n\t    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n\t    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n\t    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n\t})(exports.LogLevel || (exports.LogLevel = {}));\n\tvar LogLevel = exports.LogLevel;\n\t/* tslint:disable:no-namespace */\n\t(function (LogLevel) {\n\t    /**\n\t     * Returns LogLevel based on string representation\n\t     * @param val Value\n\t     * @returns {LogLevel}, Error is thrown if invalid.\n\t     */\n\t    function fromString(val) {\n\t        if (val == null) {\n\t            throw new Error(\"Argument must be set\");\n\t        }\n\t        switch (val.toLowerCase()) {\n\t            case \"trace\":\n\t                return LogLevel.Trace;\n\t            case \"debug\":\n\t                return LogLevel.Debug;\n\t            case \"info\":\n\t                return LogLevel.Info;\n\t            case \"warn\":\n\t                return LogLevel.Warn;\n\t            case \"error\":\n\t                return LogLevel.Error;\n\t            case \"fatal\":\n\t                return LogLevel.Fatal;\n\t            default:\n\t                throw new Error(\"Unsupported value for conversion: \" + val);\n\t        }\n\t    }\n\t    LogLevel.fromString = fromString;\n\t})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\t/* tslint:disable:enable-namespace */\n\t/**\n\t * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)\n\t * where this comes into play.\n\t */\n\t(function (LoggerType) {\n\t    LoggerType[LoggerType[\"Console\"] = 0] = \"Console\";\n\t    LoggerType[LoggerType[\"MessageBuffer\"] = 1] = \"MessageBuffer\";\n\t    LoggerType[LoggerType[\"Custom\"] = 2] = \"Custom\";\n\t})(exports.LoggerType || (exports.LoggerType = {}));\n\tvar LoggerType = exports.LoggerType;\n\t/**\n\t * Defines several date enums used for formatting a date.\n\t */\n\t(function (DateFormatEnum) {\n\t    /**\n\t     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"Default\"] = 0] = \"Default\";\n\t    /**\n\t     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearMonthDayTime\"] = 1] = \"YearMonthDayTime\";\n\t    /**\n\t     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearDayMonthWithFullTime\"] = 2] = \"YearDayMonthWithFullTime\";\n\t    /**\n\t     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59\n\t     * Note the date separator can be set separately.\n\t     */\n\t    DateFormatEnum[DateFormatEnum[\"YearDayMonthTime\"] = 3] = \"YearDayMonthTime\";\n\t})(exports.DateFormatEnum || (exports.DateFormatEnum = {}));\n\tvar DateFormatEnum = exports.DateFormatEnum;\n\t/**\n\t * DateFormat class, stores data on how to format a date.\n\t */\n\tvar DateFormat = (function () {\n\t    /**\n\t     * Constructor to define the dateformat used for logging, can be called empty as it uses defaults.\n\t     * @param formatEnum DateFormatEnum, use one of the constants from the enum. Defaults to DateFormatEnum.Default\n\t     * @param dateSeparator Separator used between dates, defaults to -\n\t     */\n\t    function DateFormat(formatEnum, dateSeparator) {\n\t        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }\n\t        if (dateSeparator === void 0) { dateSeparator = \"-\"; }\n\t        this._formatEnum = formatEnum;\n\t        this._dateSeparator = dateSeparator;\n\t    }\n\t    Object.defineProperty(DateFormat.prototype, \"formatEnum\", {\n\t        get: function () {\n\t            return this._formatEnum;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(DateFormat.prototype, \"dateSeparator\", {\n\t        get: function () {\n\t            return this._dateSeparator;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return DateFormat;\n\t}());\n\texports.DateFormat = DateFormat;\n\t/**\n\t * Information about the log format, what will a log line look like?\n\t */\n\tvar LogFormat = (function () {\n\t    /**\n\t     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.\n\t     * @param dateFormat DateFormat (what needs the date look like in the log line)\n\t     * @param showTimeStamp Show date timestamp at all?\n\t     * @param showLoggerName Show the logger name?\n\t     */\n\t    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {\n\t        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n\t        if (showTimeStamp === void 0) { showTimeStamp = true; }\n\t        if (showLoggerName === void 0) { showLoggerName = true; }\n\t        this._showTimeStamp = true;\n\t        this._showLoggerName = true;\n\t        this._dateFormat = dateFormat;\n\t        this._showTimeStamp = showTimeStamp;\n\t        this._showLoggerName = showLoggerName;\n\t    }\n\t    Object.defineProperty(LogFormat.prototype, \"dateFormat\", {\n\t        get: function () {\n\t            return this._dateFormat;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogFormat.prototype, \"showTimeStamp\", {\n\t        get: function () {\n\t            return this._showTimeStamp;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogFormat.prototype, \"showLoggerName\", {\n\t        get: function () {\n\t            return this._showLoggerName;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LogFormat;\n\t}());\n\texports.LogFormat = LogFormat;\n\t/**\n\t * Information about the log format, what will a log line look like?\n\t */\n\tvar CategoryLogFormat = (function () {\n\t    /**\n\t     * Create an instance defining the category log format used.\n\t     * @param dateFormat Date format (uses default), for details see DateFormat class.\n\t     * @param showTimeStamp True to show timestamp in the logging, defaults to true.\n\t     * @param showCategoryName True to show category name in the logging, defaults to true.\n\t     */\n\t    function CategoryLogFormat(dateFormat, showTimeStamp, showCategoryName) {\n\t        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n\t        if (showTimeStamp === void 0) { showTimeStamp = true; }\n\t        if (showCategoryName === void 0) { showCategoryName = true; }\n\t        this._dateFormat = dateFormat;\n\t        this._showTimeStamp = showTimeStamp;\n\t        this._showCategoryName = showCategoryName;\n\t    }\n\t    Object.defineProperty(CategoryLogFormat.prototype, \"dateFormat\", {\n\t        get: function () {\n\t            return this._dateFormat;\n\t        },\n\t        set: function (value) {\n\t            this._dateFormat = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryLogFormat.prototype, \"showTimeStamp\", {\n\t        get: function () {\n\t            return this._showTimeStamp;\n\t        },\n\t        set: function (value) {\n\t            this._showTimeStamp = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryLogFormat.prototype, \"showCategoryName\", {\n\t        get: function () {\n\t            return this._showCategoryName;\n\t        },\n\t        set: function (value) {\n\t            this._showCategoryName = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return CategoryLogFormat;\n\t}());\n\texports.CategoryLogFormat = CategoryLogFormat;\n\t//# sourceMappingURL=LoggerOptions.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ST = __webpack_require__(5);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\t/**\n\t * Some utilities to format messages.\n\t */\n\tvar MessageFormatUtils = (function () {\n\t    function MessageFormatUtils() {\n\t    }\n\t    /**\n\t     * Render given date in given DateFormat and return as String.\n\t     * @param date Date\n\t     * @param dateFormat Format\n\t     * @returns {string} Formatted date\n\t     */\n\t    MessageFormatUtils.renderDate = function (date, dateFormat) {\n\t        var lpad = function (value, chars, padWith) {\n\t            var howMany = chars - value.length;\n\t            if (howMany > 0) {\n\t                var res = \"\";\n\t                for (var i = 0; i < howMany; i++) {\n\t                    res += padWith;\n\t                }\n\t                res += value;\n\t                return res;\n\t            }\n\t            return value;\n\t        };\n\t        var fullYear = function (d) {\n\t            return lpad(d.getFullYear().toString(), 4, \"0\");\n\t        };\n\t        var month = function (d) {\n\t            return lpad((d.getMonth() + 1).toString(), 2, \"0\");\n\t        };\n\t        var day = function (d) {\n\t            return lpad(d.getDate().toString(), 2, \"0\");\n\t        };\n\t        var hours = function (d) {\n\t            return lpad(d.getHours().toString(), 2, \"0\");\n\t        };\n\t        var minutes = function (d) {\n\t            return lpad(d.getMinutes().toString(), 2, \"0\");\n\t        };\n\t        var seconds = function (d) {\n\t            return lpad(d.getSeconds().toString(), 2, \"0\");\n\t        };\n\t        var millis = function (d) {\n\t            return lpad(d.getMilliseconds().toString(), 3, \"0\");\n\t        };\n\t        var dateSeparator = dateFormat.dateSeparator;\n\t        var ds = \"\";\n\t        switch (dateFormat.formatEnum) {\n\t            case LoggerOptions_1.DateFormatEnum.Default:\n\t                // yyyy-mm-dd hh:mm:ss,m\n\t                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + \" \" +\n\t                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n\t                break;\n\t            case LoggerOptions_1.DateFormatEnum.YearMonthDayTime:\n\t                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + \" \" +\n\t                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date);\n\t                break;\n\t            case LoggerOptions_1.DateFormatEnum.YearDayMonthWithFullTime:\n\t                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + \" \" +\n\t                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n\t                break;\n\t            case LoggerOptions_1.DateFormatEnum.YearDayMonthTime:\n\t                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + \" \" +\n\t                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date);\n\t                break;\n\t            default:\n\t                throw new Error(\"Unsupported date format enum: \" + dateFormat.formatEnum);\n\t        }\n\t        return ds;\n\t    };\n\t    /**\n\t     * Renders given category log message\n\t     * @param msg Message to format\n\t     * @param addStack If true adds the stack to the output, otherwise skips it\n\t     * @returns {string} Formatted message\n\t     */\n\t    MessageFormatUtils.renderDefaultMessage = function (msg, addStack) {\n\t        var result = \"\";\n\t        var logFormat = msg.getLogFormat();\n\t        if (logFormat.showTimeStamp) {\n\t            result += MessageFormatUtils.renderDate(msg.getDate(), logFormat.dateFormat) + \" \";\n\t        }\n\t        result += LoggerOptions_1.LogLevel[msg.getLevel()].toUpperCase();\n\t        if (msg.isResolvedErrorMessage()) {\n\t            result += \" (resolved)\";\n\t        }\n\t        result += \" \";\n\t        if (logFormat.showCategoryName) {\n\t            result += \"[\";\n\t            msg.getCategories().forEach(function (value, idx) {\n\t                if (idx > 0) {\n\t                    result += \", \";\n\t                }\n\t                result += value.name;\n\t            });\n\t            result += \"]\";\n\t        }\n\t        result += \" \" + msg.getMessage();\n\t        if (addStack && msg.getErrorAsStack() != null) {\n\t            result += \"\\n\" + msg.getErrorAsStack();\n\t        }\n\t        return result;\n\t    };\n\t    /**\n\t     * Render error as stack\n\t     * @param error Return error as Promise\n\t     * @returns {Promise<string>|Promise} Promise for stack\n\t     */\n\t    MessageFormatUtils.renderError = function (error) {\n\t        var result = error.name + \": \" + error.message + \"\\n@\";\n\t        return new Promise(function (resolve) {\n\t            // This one has a promise too\n\t            ST.fromError(error, { offline: true }).then(function (frames) {\n\t                var stackStr = (frames.map(function (frame) {\n\t                    return frame.toString();\n\t                })).join(\"\\n  \");\n\t                result += \"\\n\" + stackStr;\n\t                // This resolves our returned promise\n\t                resolve(result);\n\t            });\n\t        });\n\t    };\n\t    return MessageFormatUtils;\n\t}());\n\texports.MessageFormatUtils = MessageFormatUtils;\n\t//# sourceMappingURL=MessageUtils.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6), __webpack_require__(8), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n\t    } else {\n\t        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n\t    }\n\t}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n\t    var _options = {\n\t        filter: function(stackframe) {\n\t            // Filter out stackframes for this library by default\n\t            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n\t                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n\t        },\n\t        sourceCache: {}\n\t    };\n\t\n\t    var _generateError = function StackTrace$$GenerateError() {\n\t        try {\n\t            // Error must be thrown to get stack in IE\n\t            throw new Error();\n\t        } catch (err) {\n\t            return err;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Merge 2 given Objects. If a conflict occurs the second object wins.\n\t     * Does not do deep merges.\n\t     *\n\t     * @param {Object} first base object\n\t     * @param {Object} second overrides\n\t     * @returns {Object} merged first and second\n\t     * @private\n\t     */\n\t    function _merge(first, second) {\n\t        var target = {};\n\t\n\t        [first, second].forEach(function(obj) {\n\t            for (var prop in obj) {\n\t                if (obj.hasOwnProperty(prop)) {\n\t                    target[prop] = obj[prop];\n\t                }\n\t            }\n\t            return target;\n\t        });\n\t\n\t        return target;\n\t    }\n\t\n\t    function _isShapedLikeParsableError(err) {\n\t        return err.stack || err['opera#sourceloc'];\n\t    }\n\t\n\t    function _filtered(stackframes, filter) {\n\t        if (typeof filter === 'function') {\n\t            return stackframes.filter(filter);\n\t        }\n\t        return stackframes;\n\t    }\n\t\n\t    return {\n\t        /**\n\t         * Get a backtrace from invocation point.\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Array} of StackFrame\n\t         */\n\t        get: function StackTrace$$get(opts) {\n\t            var err = _generateError();\n\t            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n\t        },\n\t\n\t        /**\n\t         * Get a backtrace from invocation point.\n\t         * IMPORTANT: Does not handle source maps or guess function names!\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Array} of StackFrame\n\t         */\n\t        getSync: function StackTrace$$getSync(opts) {\n\t            opts = _merge(_options, opts);\n\t            var err = _generateError();\n\t            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n\t            return _filtered(stack, opts.filter);\n\t        },\n\t\n\t        /**\n\t         * Given an error object, parse it.\n\t         *\n\t         * @param {Error} error object\n\t         * @param {Object} opts\n\t         * @returns {Promise} for Array[StackFrame}\n\t         */\n\t        fromError: function StackTrace$$fromError(error, opts) {\n\t            opts = _merge(_options, opts);\n\t            var gps = new StackTraceGPS(opts);\n\t            return new Promise(function(resolve) {\n\t                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n\t                resolve(Promise.all(stackframes.map(function(sf) {\n\t                    return new Promise(function(resolve) {\n\t                        function resolveOriginal() {\n\t                            resolve(sf);\n\t                        }\n\t\n\t                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n\t                    });\n\t                })));\n\t            }.bind(this));\n\t        },\n\t\n\t        /**\n\t         * Use StackGenerator to generate a backtrace.\n\t         *\n\t         * @param {Object} opts\n\t         * @returns {Promise} of Array[StackFrame]\n\t         */\n\t        generateArtificially: function StackTrace$$generateArtificially(opts) {\n\t            opts = _merge(_options, opts);\n\t            var stackFrames = StackGenerator.backtrace(opts);\n\t            if (typeof opts.filter === 'function') {\n\t                stackFrames = stackFrames.filter(opts.filter);\n\t            }\n\t            return Promise.resolve(stackFrames);\n\t        },\n\t\n\t        /**\n\t         * Given a function, wrap it such that invocations trigger a callback that\n\t         * is called with a stack trace.\n\t         *\n\t         * @param {Function} fn to be instrumented\n\t         * @param {Function} callback function to call with a stack trace on invocation\n\t         * @param {Function} errback optional function to call with error if unable to get stack trace.\n\t         * @param {Object} thisArg optional context object (e.g. window)\n\t         */\n\t        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n\t            if (typeof fn !== 'function') {\n\t                throw new Error('Cannot instrument non-function object');\n\t            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n\t                // Already instrumented, return given Function\n\t                return fn;\n\t            }\n\t\n\t            var instrumented = function StackTrace$$instrumented() {\n\t                try {\n\t                    this.get().then(callback, errback)['catch'](errback);\n\t                    return fn.apply(thisArg || this, arguments);\n\t                } catch (e) {\n\t                    if (_isShapedLikeParsableError(e)) {\n\t                        this.fromError(e).then(callback, errback)['catch'](errback);\n\t                    }\n\t                    throw e;\n\t                }\n\t            }.bind(this);\n\t            instrumented.__stacktraceOriginalFn = fn;\n\t\n\t            return instrumented;\n\t        },\n\t\n\t        /**\n\t         * Given a function that has been instrumented,\n\t         * revert the function to it's original (non-instrumented) state.\n\t         *\n\t         * @param {Function} fn to de-instrument\n\t         */\n\t        deinstrument: function StackTrace$$deinstrument(fn) {\n\t            if (typeof fn !== 'function') {\n\t                throw new Error('Cannot de-instrument non-function object');\n\t            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n\t                return fn.__stacktraceOriginalFn;\n\t            } else {\n\t                // Function not instrumented, return original\n\t                return fn;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n\t         *\n\t         * @param {Array} stackframes\n\t         * @param {String} url\n\t         * @param {String} errorMsg\n\t         */\n\t        report: function StackTrace$$report(stackframes, url, errorMsg) {\n\t            return new Promise(function(resolve, reject) {\n\t                var req = new XMLHttpRequest();\n\t                req.onerror = reject;\n\t                req.onreadystatechange = function onreadystatechange() {\n\t                    if (req.readyState === 4) {\n\t                        if (req.status >= 200 && req.status < 400) {\n\t                            resolve(req.responseText);\n\t                        } else {\n\t                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n\t                        }\n\t                    }\n\t                };\n\t                req.open('post', url);\n\t                req.setRequestHeader('Content-Type', 'application/json');\n\t\n\t                var reportPayload = {stack: stackframes};\n\t                if (errorMsg !== undefined) {\n\t                    reportPayload.message = errorMsg;\n\t                }\n\t\n\t                req.send(JSON.stringify(reportPayload));\n\t            });\n\t        }\n\t    };\n\t}));\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.ErrorStackParser = factory(root.StackFrame);\n\t    }\n\t}(this, function ErrorStackParser(StackFrame) {\n\t    'use strict';\n\t\n\t    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n\t    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n\t    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\t\n\t    function _map(array, fn, thisArg) {\n\t        if (typeof Array.prototype.map === 'function') {\n\t            return array.map(fn, thisArg);\n\t        } else {\n\t            var output = new Array(array.length);\n\t            for (var i = 0; i < array.length; i++) {\n\t                output[i] = fn.call(thisArg, array[i]);\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    function _filter(array, fn, thisArg) {\n\t        if (typeof Array.prototype.filter === 'function') {\n\t            return array.filter(fn, thisArg);\n\t        } else {\n\t            var output = [];\n\t            for (var i = 0; i < array.length; i++) {\n\t                if (fn.call(thisArg, array[i])) {\n\t                    output.push(array[i]);\n\t                }\n\t            }\n\t            return output;\n\t        }\n\t    }\n\t\n\t    function _indexOf(array, target) {\n\t        if (typeof Array.prototype.indexOf === 'function') {\n\t            return array.indexOf(target);\n\t        } else {\n\t            for (var i = 0; i < array.length; i++) {\n\t                if (array[i] === target) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    return {\n\t        /**\n\t         * Given an Error object, extract the most information from it.\n\t         *\n\t         * @param {Error} error object\n\t         * @return {Array} of StackFrames\n\t         */\n\t        parse: function ErrorStackParser$$parse(error) {\n\t            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n\t                return this.parseOpera(error);\n\t            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n\t                return this.parseV8OrIE(error);\n\t            } else if (error.stack) {\n\t                return this.parseFFOrSafari(error);\n\t            } else {\n\t                throw new Error('Cannot parse given Error object');\n\t            }\n\t        },\n\t\n\t        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n\t        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n\t            // Fail-fast but return locations like \"(native)\"\n\t            if (urlLike.indexOf(':') === -1) {\n\t                return [urlLike];\n\t            }\n\t\n\t            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n\t            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n\t            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n\t        },\n\t\n\t        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !!line.match(CHROME_IE_STACK_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                if (line.indexOf('(eval ') > -1) {\n\t                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n\t                }\n\t                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionName = tokens.join(' ') || undefined;\n\t                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\t\n\t                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n\t            }, this);\n\t        },\n\t\n\t        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                if (line.indexOf(' > eval') > -1) {\n\t                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n\t                }\n\t\n\t                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n\t                    // Safari eval frames only have function names and nothing else\n\t                    return new StackFrame(line);\n\t                } else {\n\t                    var tokens = line.split('@');\n\t                    var locationParts = this.extractLocation(tokens.pop());\n\t                    var functionName = tokens.join('@') || undefined;\n\t                    return new StackFrame(functionName,\n\t                        undefined,\n\t                        locationParts[0],\n\t                        locationParts[1],\n\t                        locationParts[2],\n\t                        line);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        parseOpera: function ErrorStackParser$$parseOpera(e) {\n\t            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n\t                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n\t                return this.parseOpera9(e);\n\t            } else if (!e.stack) {\n\t                return this.parseOpera10(e);\n\t            } else {\n\t                return this.parseOpera11(e);\n\t            }\n\t        },\n\t\n\t        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(\n\t                        new StackFrame(\n\t                            match[3] || undefined,\n\t                            undefined,\n\t                            match[2],\n\t                            match[1],\n\t                            undefined,\n\t                            lines[i]\n\t                        )\n\t                    );\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 10.65+ Error.stack very similar to FF/Safari\n\t        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n\t            var filtered = _filter(error.stack.split('\\n'), function(line) {\n\t                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n\t            }, this);\n\t\n\t            return _map(filtered, function(line) {\n\t                var tokens = line.split('@');\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionCall = (tokens.shift() || '');\n\t                var functionName = functionCall\n\t                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n\t                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n\t                var argsRaw;\n\t                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n\t                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n\t                }\n\t                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n\t                    undefined : argsRaw.split(',');\n\t                return new StackFrame(\n\t                    functionName,\n\t                    args,\n\t                    locationParts[0],\n\t                    locationParts[1],\n\t                    locationParts[2],\n\t                    line);\n\t            }, this);\n\t        }\n\t    };\n\t}));\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n\t        if (functionName !== undefined) {\n\t            this.setFunctionName(functionName);\n\t        }\n\t        if (args !== undefined) {\n\t            this.setArgs(args);\n\t        }\n\t        if (fileName !== undefined) {\n\t            this.setFileName(fileName);\n\t        }\n\t        if (lineNumber !== undefined) {\n\t            this.setLineNumber(lineNumber);\n\t        }\n\t        if (columnNumber !== undefined) {\n\t            this.setColumnNumber(columnNumber);\n\t        }\n\t        if (source !== undefined) {\n\t            this.setSource(source);\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getFunctionName: function () {\n\t            return this.functionName;\n\t        },\n\t        setFunctionName: function (v) {\n\t            this.functionName = String(v);\n\t        },\n\t\n\t        getArgs: function () {\n\t            return this.args;\n\t        },\n\t        setArgs: function (v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        // NOTE: Property name may be misleading as it includes the path,\n\t        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n\t        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n\t        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n\t        getFileName: function () {\n\t            return this.fileName;\n\t        },\n\t        setFileName: function (v) {\n\t            this.fileName = String(v);\n\t        },\n\t\n\t        getLineNumber: function () {\n\t            return this.lineNumber;\n\t        },\n\t        setLineNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Line Number must be a Number');\n\t            }\n\t            this.lineNumber = Number(v);\n\t        },\n\t\n\t        getColumnNumber: function () {\n\t            return this.columnNumber;\n\t        },\n\t        setColumnNumber: function (v) {\n\t            if (!_isNumber(v)) {\n\t                throw new TypeError('Column Number must be a Number');\n\t            }\n\t            this.columnNumber = Number(v);\n\t        },\n\t\n\t        getSource: function () {\n\t            return this.source;\n\t        },\n\t        setSource: function (v) {\n\t            this.source = String(v);\n\t        },\n\t\n\t        toString: function() {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.StackGenerator = factory(root.StackFrame);\n\t    }\n\t}(this, function (StackFrame) {\n\t    return {\n\t        backtrace: function StackGenerator$$backtrace(opts) {\n\t            var stack = [];\n\t            var maxStackSize = 10;\n\t\n\t            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n\t                maxStackSize = opts.maxStackSize;\n\t            }\n\t\n\t            var curr = arguments.callee;\n\t            while (curr && stack.length < maxStackSize) {\n\t                // Allow V8 optimizations\n\t                var args = new Array(curr['arguments'].length);\n\t                for(var i = 0; i < args.length; ++i) {\n\t                    args[i] = curr['arguments'][i];\n\t                }\n\t                if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n\t                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));\n\t                } else {\n\t                    stack.push(new StackFrame({args: args}));\n\t                }\n\t\n\t                try {\n\t                    curr = curr.caller;\n\t                } catch (e) {\n\t                    break;\n\t                }\n\t            }\n\t            return stack;\n\t        }\n\t    };\n\t}));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function () {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function _capitalize(str) {\n\t        return str[0].toUpperCase() + str.substring(1);\n\t    }\n\t\n\t    function _getter(p) {\n\t        return function () {\n\t            return this[p];\n\t        };\n\t    }\n\t\n\t    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n\t    var numericProps = ['columnNumber', 'lineNumber'];\n\t    var stringProps = ['fileName', 'functionName', 'source'];\n\t    var arrayProps = ['args'];\n\t\n\t    function StackFrame(obj) {\n\t        if (obj instanceof Object) {\n\t            var props = booleanProps.concat(numericProps.concat(stringProps.concat(arrayProps)));\n\t            for (var i = 0; i < props.length; i++) {\n\t                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n\t                    this['set' + _capitalize(props[i])](obj[props[i]]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getArgs: function () {\n\t            return this.args;\n\t        },\n\t        setArgs: function (v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        getEvalOrigin: function () {\n\t            return this.evalOrigin;\n\t        },\n\t        setEvalOrigin: function (v) {\n\t            if (v instanceof StackFrame) {\n\t                this.evalOrigin = v;\n\t            } else if (v instanceof Object) {\n\t                this.evalOrigin = new StackFrame(v);\n\t            } else {\n\t                throw new TypeError('Eval Origin must be an Object or StackFrame');\n\t            }\n\t        },\n\t\n\t        toString: function () {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    for (var i = 0; i < booleanProps.length; i++) {\n\t        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\t        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function (p) {\n\t            return function (v) {\n\t                this[p] = Boolean(v);\n\t            };\n\t        })(booleanProps[i]);\n\t    }\n\t\n\t    for (var j = 0; j < numericProps.length; j++) {\n\t        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\t        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function (p) {\n\t            return function (v) {\n\t                if (!_isNumber(v)) {\n\t                    throw new TypeError(p + ' must be a Number');\n\t                }\n\t                this[p] = Number(v);\n\t            };\n\t        })(numericProps[j]);\n\t    }\n\t\n\t    for (var k = 0; k < stringProps.length; k++) {\n\t        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\t        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function (p) {\n\t            return function (v) {\n\t                this[p] = String(v);\n\t            };\n\t        })(stringProps[k]);\n\t    }\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(11), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n\t    } else {\n\t        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n\t    }\n\t}(this, function(SourceMap, StackFrame) {\n\t    'use strict';\n\t\n\t    /**\n\t     * Make a X-Domain request to url and callback.\n\t     *\n\t     * @param {String} url\n\t     * @returns {Promise} with response text if fulfilled\n\t     */\n\t    function _xdr(url) {\n\t        return new Promise(function(resolve, reject) {\n\t            var req = new XMLHttpRequest();\n\t            req.open('get', url);\n\t            req.onerror = reject;\n\t            req.onreadystatechange = function onreadystatechange() {\n\t                if (req.readyState === 4) {\n\t                    if (req.status >= 200 && req.status < 300) {\n\t                        resolve(req.responseText);\n\t                    } else {\n\t                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n\t                    }\n\t                }\n\t            };\n\t            req.send();\n\t        });\n\t\n\t    }\n\t\n\t    /**\n\t     * Convert a Base64-encoded string into its original representation.\n\t     * Used for inline sourcemaps.\n\t     *\n\t     * @param {String} b64str Base-64 encoded string\n\t     * @returns {String} original representation of the base64-encoded string.\n\t     */\n\t    function _atob(b64str) {\n\t        if (typeof window !== 'undefined' && window.atob) {\n\t            return window.atob(b64str);\n\t        } else {\n\t            throw new Error('You must supply a polyfill for window.atob in this environment');\n\t        }\n\t    }\n\t\n\t    function _parseJson(string) {\n\t        if (typeof JSON !== 'undefined' && JSON.parse) {\n\t            return JSON.parse(string);\n\t        } else {\n\t            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n\t        }\n\t    }\n\t\n\t    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n\t        // function {name}({args}) m[1]=name m[2]=args\n\t        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n\t        // {name} = function ({args}) TODO args capture\n\t        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n\t        // {name} = eval()\n\t        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n\t        var lines = source.split('\\n');\n\t\n\t        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n\t        var code = '';\n\t        var maxLines = Math.min(lineNumber, 20);\n\t        var m;\n\t        for (var i = 0; i < maxLines; ++i) {\n\t            // lineNo is 1-based, source[] is 0-based\n\t            var line = lines[lineNumber - i - 1];\n\t            var commentPos = line.indexOf('//');\n\t            if (commentPos >= 0) {\n\t                line = line.substr(0, commentPos);\n\t            }\n\t\n\t            if (line) {\n\t                code = line + code;\n\t                m = reFunctionExpression.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t                m = reFunctionDeclaration.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t                m = reFunctionEvaluation.exec(code);\n\t                if (m && m[1]) {\n\t                    return m[1];\n\t                }\n\t            }\n\t        }\n\t        return undefined;\n\t    }\n\t\n\t    function _ensureSupportedEnvironment() {\n\t        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n\t            throw new Error('Unable to consume source maps in older browsers');\n\t        }\n\t    }\n\t\n\t    function _ensureStackFrameIsLegit(stackframe) {\n\t        if (typeof stackframe !== 'object') {\n\t            throw new TypeError('Given StackFrame is not an object');\n\t        } else if (typeof stackframe.fileName !== 'string') {\n\t            throw new TypeError('Given file name is not a String');\n\t        } else if (typeof stackframe.lineNumber !== 'number' ||\n\t            stackframe.lineNumber % 1 !== 0 ||\n\t            stackframe.lineNumber < 1) {\n\t            throw new TypeError('Given line number must be a positive integer');\n\t        } else if (typeof stackframe.columnNumber !== 'number' ||\n\t            stackframe.columnNumber % 1 !== 0 ||\n\t            stackframe.columnNumber < 0) {\n\t            throw new TypeError('Given column number must be a non-negative integer');\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function _findSourceMappingURL(source) {\n\t        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n\t        if (m && m[1]) {\n\t            return m[1];\n\t        } else {\n\t            throw new Error('sourceMappingURL not found');\n\t        }\n\t    }\n\t\n\t    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n\t        return new Promise(function(resolve, reject) {\n\t            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\t\n\t            var loc = mapConsumer.originalPositionFor({\n\t                line: stackframe.lineNumber,\n\t                column: stackframe.columnNumber\n\t            });\n\t\n\t            if (loc.source) {\n\t                var mappedSource = mapConsumer.sourceContentFor(loc.source);\n\t                if (mappedSource) {\n\t                    sourceCache[loc.source] = mappedSource;\n\t                }\n\t                resolve(\n\t                    new StackFrame(\n\t                        loc.name || stackframe.functionName,\n\t                        stackframe.args,\n\t                        loc.source,\n\t                        loc.line,\n\t                        loc.column));\n\t            } else {\n\t                reject(new Error('Could not get original source for given stackframe and source map'));\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {Object} opts\n\t     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n\t     *      opts.offline = True to prevent network requests.\n\t     *              Best effort without sources or source maps.\n\t     *      opts.ajax = Promise returning function to make X-Domain requests\n\t     */\n\t    return function StackTraceGPS(opts) {\n\t        if (!(this instanceof StackTraceGPS)) {\n\t            return new StackTraceGPS(opts);\n\t        }\n\t        opts = opts || {};\n\t\n\t        this.sourceCache = opts.sourceCache || {};\n\t\n\t        this.ajax = opts.ajax || _xdr;\n\t\n\t        this._atob = opts.atob || _atob;\n\t\n\t        this._get = function _get(location) {\n\t            return new Promise(function(resolve, reject) {\n\t                var isDataUrl = location.substr(0, 5) === 'data:';\n\t                if (this.sourceCache[location]) {\n\t                    resolve(this.sourceCache[location]);\n\t                } else if (opts.offline && !isDataUrl) {\n\t                    reject(new Error('Cannot make network requests in offline mode'));\n\t                } else {\n\t                    if (isDataUrl) {\n\t                        // data URLs can have parameters.\n\t                        // see http://tools.ietf.org/html/rfc2397\n\t                        var supportedEncodingRegexp =\n\t                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n\t                        var match = location.match(supportedEncodingRegexp);\n\t                        if (match) {\n\t                            var sourceMapStart = match[0].length;\n\t                            var encodedSource = location.substr(sourceMapStart);\n\t                            var source = this._atob(encodedSource);\n\t                            this.sourceCache[location] = source;\n\t                            resolve(source);\n\t                        } else {\n\t                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n\t                        }\n\t                    } else {\n\t                        var xhrPromise = this.ajax(location, {method: 'get'});\n\t                        // Cache the Promise to prevent duplicate in-flight requests\n\t                        this.sourceCache[location] = xhrPromise;\n\t                        xhrPromise.then(resolve, reject);\n\t                    }\n\t                }\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, enhance function name and use source maps for a\n\t         * better StackFrame.\n\t         *\n\t         * @param {StackFrame} stackframe object\n\t         * @returns {Promise} that resolves with with source-mapped StackFrame\n\t         */\n\t        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n\t                    function resolveMappedStackFrame() {\n\t                        resolve(mappedStackFrame);\n\t                    }\n\t\n\t                    this.findFunctionName(mappedStackFrame)\n\t                        .then(resolve, resolveMappedStackFrame)\n\t                        ['catch'](resolveMappedStackFrame);\n\t                }.bind(this), reject);\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, guess function name from location information.\n\t         *\n\t         * @param {StackFrame} stackframe\n\t         * @returns {Promise} that resolves with enhanced StackFrame.\n\t         */\n\t        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                _ensureStackFrameIsLegit(stackframe);\n\t                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n\t                    var lineNumber = stackframe.lineNumber;\n\t                    var columnNumber = stackframe.columnNumber;\n\t                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n\t                    // Only replace functionName if we found something\n\t                    if (guessedFunctionName) {\n\t                        resolve(new StackFrame(guessedFunctionName,\n\t                            stackframe.args,\n\t                            stackframe.fileName,\n\t                            lineNumber,\n\t                            columnNumber));\n\t                    } else {\n\t                        resolve(stackframe);\n\t                    }\n\t                }, reject)['catch'](reject);\n\t            }.bind(this));\n\t        };\n\t\n\t        /**\n\t         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n\t         *\n\t         * @param {StackFrame} stackframe\n\t         * @returns {Promise} that resolves with enhanced StackFrame.\n\t         */\n\t        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n\t            return new Promise(function(resolve, reject) {\n\t                _ensureSupportedEnvironment();\n\t                _ensureStackFrameIsLegit(stackframe);\n\t\n\t                var sourceCache = this.sourceCache;\n\t                var fileName = stackframe.fileName;\n\t                this._get(fileName).then(function(source) {\n\t                    var sourceMappingURL = _findSourceMappingURL(source);\n\t                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n\t                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\t\n\t                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n\t                        sourceMappingURL = base + sourceMappingURL;\n\t                    }\n\t\n\t                    this._get(sourceMappingURL).then(function(sourceMap) {\n\t                        if (typeof sourceMap === 'string') {\n\t                            sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n\t                        }\n\t                        if (typeof sourceMap.sourceRoot === 'undefined') {\n\t                            sourceMap.sourceRoot = base;\n\t                        }\n\t\n\t                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)\n\t                            .then(resolve)['catch'](function() {\n\t                            resolve(stackframe);\n\t                        });\n\t                    }, reject)['catch'](reject);\n\t                }.bind(this), reject)['catch'](reject);\n\t            }.bind(this));\n\t        };\n\t    };\n\t}));\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t * Copyright 2009-2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE.txt or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\texports.SourceMapGenerator = __webpack_require__(12).SourceMapGenerator;\n\texports.SourceMapConsumer = __webpack_require__(18).SourceMapConsumer;\n\texports.SourceNode = __webpack_require__(21).SourceNode;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar base64VLQ = __webpack_require__(13);\n\tvar util = __webpack_require__(15);\n\tvar ArraySet = __webpack_require__(16).ArraySet;\n\tvar MappingList = __webpack_require__(17).MappingList;\n\t\n\t/**\n\t * An instance of the SourceMapGenerator represents a source map which is\n\t * being built incrementally. You may pass an object with the following\n\t * properties:\n\t *\n\t *   - file: The filename of the generated source.\n\t *   - sourceRoot: A root for all relative URLs in this source map.\n\t */\n\tfunction SourceMapGenerator(aArgs) {\n\t  if (!aArgs) {\n\t    aArgs = {};\n\t  }\n\t  this._file = util.getArg(aArgs, 'file', null);\n\t  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n\t  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t  this._mappings = new MappingList();\n\t  this._sourcesContents = null;\n\t}\n\t\n\tSourceMapGenerator.prototype._version = 3;\n\t\n\t/**\n\t * Creates a new SourceMapGenerator based on a SourceMapConsumer\n\t *\n\t * @param aSourceMapConsumer The SourceMap.\n\t */\n\tSourceMapGenerator.fromSourceMap =\n\t  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n\t    var sourceRoot = aSourceMapConsumer.sourceRoot;\n\t    var generator = new SourceMapGenerator({\n\t      file: aSourceMapConsumer.file,\n\t      sourceRoot: sourceRoot\n\t    });\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      var newMapping = {\n\t        generated: {\n\t          line: mapping.generatedLine,\n\t          column: mapping.generatedColumn\n\t        }\n\t      };\n\t\n\t      if (mapping.source != null) {\n\t        newMapping.source = mapping.source;\n\t        if (sourceRoot != null) {\n\t          newMapping.source = util.relative(sourceRoot, newMapping.source);\n\t        }\n\t\n\t        newMapping.original = {\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        };\n\t\n\t        if (mapping.name != null) {\n\t          newMapping.name = mapping.name;\n\t        }\n\t      }\n\t\n\t      generator.addMapping(newMapping);\n\t    });\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        generator.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t    return generator;\n\t  };\n\t\n\t/**\n\t * Add a single mapping from original source line and column to the generated\n\t * source's line and column for this source map being created. The mapping\n\t * object should have the following properties:\n\t *\n\t *   - generated: An object with the generated line and column positions.\n\t *   - original: An object with the original line and column positions.\n\t *   - source: The original source file (relative to the sourceRoot).\n\t *   - name: An optional original token name for this mapping.\n\t */\n\tSourceMapGenerator.prototype.addMapping =\n\t  function SourceMapGenerator_addMapping(aArgs) {\n\t    var generated = util.getArg(aArgs, 'generated');\n\t    var original = util.getArg(aArgs, 'original', null);\n\t    var source = util.getArg(aArgs, 'source', null);\n\t    var name = util.getArg(aArgs, 'name', null);\n\t\n\t    if (!this._skipValidation) {\n\t      this._validateMapping(generated, original, source, name);\n\t    }\n\t\n\t    if (source != null) {\n\t      source = String(source);\n\t      if (!this._sources.has(source)) {\n\t        this._sources.add(source);\n\t      }\n\t    }\n\t\n\t    if (name != null) {\n\t      name = String(name);\n\t      if (!this._names.has(name)) {\n\t        this._names.add(name);\n\t      }\n\t    }\n\t\n\t    this._mappings.add({\n\t      generatedLine: generated.line,\n\t      generatedColumn: generated.column,\n\t      originalLine: original != null && original.line,\n\t      originalColumn: original != null && original.column,\n\t      source: source,\n\t      name: name\n\t    });\n\t  };\n\t\n\t/**\n\t * Set the source content for a source file.\n\t */\n\tSourceMapGenerator.prototype.setSourceContent =\n\t  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n\t    var source = aSourceFile;\n\t    if (this._sourceRoot != null) {\n\t      source = util.relative(this._sourceRoot, source);\n\t    }\n\t\n\t    if (aSourceContent != null) {\n\t      // Add the source content to the _sourcesContents map.\n\t      // Create a new _sourcesContents map if the property is null.\n\t      if (!this._sourcesContents) {\n\t        this._sourcesContents = Object.create(null);\n\t      }\n\t      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n\t    } else if (this._sourcesContents) {\n\t      // Remove the source file from the _sourcesContents map.\n\t      // If the _sourcesContents map is empty, set the property to null.\n\t      delete this._sourcesContents[util.toSetString(source)];\n\t      if (Object.keys(this._sourcesContents).length === 0) {\n\t        this._sourcesContents = null;\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Applies the mappings of a sub-source-map for a specific source file to the\n\t * source map being generated. Each mapping to the supplied source file is\n\t * rewritten using the supplied source map. Note: The resolution for the\n\t * resulting mappings is the minimium of this map and the supplied map.\n\t *\n\t * @param aSourceMapConsumer The source map to be applied.\n\t * @param aSourceFile Optional. The filename of the source file.\n\t *        If omitted, SourceMapConsumer's file property will be used.\n\t * @param aSourceMapPath Optional. The dirname of the path to the source map\n\t *        to be applied. If relative, it is relative to the SourceMapConsumer.\n\t *        This parameter is needed when the two source maps aren't in the same\n\t *        directory, and the source map to be applied contains relative source\n\t *        paths. If so, those relative source paths need to be rewritten\n\t *        relative to the SourceMapGenerator.\n\t */\n\tSourceMapGenerator.prototype.applySourceMap =\n\t  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t    var sourceFile = aSourceFile;\n\t    // If aSourceFile is omitted, we will use the file property of the SourceMap\n\t    if (aSourceFile == null) {\n\t      if (aSourceMapConsumer.file == null) {\n\t        throw new Error(\n\t          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n\t          'or the source map\\'s \"file\" property. Both were omitted.'\n\t        );\n\t      }\n\t      sourceFile = aSourceMapConsumer.file;\n\t    }\n\t    var sourceRoot = this._sourceRoot;\n\t    // Make \"sourceFile\" relative if an absolute Url is passed.\n\t    if (sourceRoot != null) {\n\t      sourceFile = util.relative(sourceRoot, sourceFile);\n\t    }\n\t    // Applying the SourceMap can add and remove items from the sources and\n\t    // the names array.\n\t    var newSources = new ArraySet();\n\t    var newNames = new ArraySet();\n\t\n\t    // Find mappings for the \"sourceFile\"\n\t    this._mappings.unsortedForEach(function (mapping) {\n\t      if (mapping.source === sourceFile && mapping.originalLine != null) {\n\t        // Check if it can be mapped by the source map, then update the mapping.\n\t        var original = aSourceMapConsumer.originalPositionFor({\n\t          line: mapping.originalLine,\n\t          column: mapping.originalColumn\n\t        });\n\t        if (original.source != null) {\n\t          // Copy mapping\n\t          mapping.source = original.source;\n\t          if (aSourceMapPath != null) {\n\t            mapping.source = util.join(aSourceMapPath, mapping.source)\n\t          }\n\t          if (sourceRoot != null) {\n\t            mapping.source = util.relative(sourceRoot, mapping.source);\n\t          }\n\t          mapping.originalLine = original.line;\n\t          mapping.originalColumn = original.column;\n\t          if (original.name != null) {\n\t            mapping.name = original.name;\n\t          }\n\t        }\n\t      }\n\t\n\t      var source = mapping.source;\n\t      if (source != null && !newSources.has(source)) {\n\t        newSources.add(source);\n\t      }\n\t\n\t      var name = mapping.name;\n\t      if (name != null && !newNames.has(name)) {\n\t        newNames.add(name);\n\t      }\n\t\n\t    }, this);\n\t    this._sources = newSources;\n\t    this._names = newNames;\n\t\n\t    // Copy sourcesContents of applied map.\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aSourceMapPath != null) {\n\t          sourceFile = util.join(aSourceMapPath, sourceFile);\n\t        }\n\t        if (sourceRoot != null) {\n\t          sourceFile = util.relative(sourceRoot, sourceFile);\n\t        }\n\t        this.setSourceContent(sourceFile, content);\n\t      }\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * A mapping can have one of the three levels of data:\n\t *\n\t *   1. Just the generated position.\n\t *   2. The Generated position, original position, and original source.\n\t *   3. Generated and original position, original source, as well as a name\n\t *      token.\n\t *\n\t * To maintain consistency, we validate that any new mapping being added falls\n\t * in to one of these categories.\n\t */\n\tSourceMapGenerator.prototype._validateMapping =\n\t  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n\t                                              aName) {\n\t    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t        && aGenerated.line > 0 && aGenerated.column >= 0\n\t        && !aOriginal && !aSource && !aName) {\n\t      // Case 1.\n\t      return;\n\t    }\n\t    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n\t             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n\t             && aGenerated.line > 0 && aGenerated.column >= 0\n\t             && aOriginal.line > 0 && aOriginal.column >= 0\n\t             && aSource) {\n\t      // Cases 2 and 3.\n\t      return;\n\t    }\n\t    else {\n\t      throw new Error('Invalid mapping: ' + JSON.stringify({\n\t        generated: aGenerated,\n\t        source: aSource,\n\t        original: aOriginal,\n\t        name: aName\n\t      }));\n\t    }\n\t  };\n\t\n\t/**\n\t * Serialize the accumulated mappings in to the stream of base 64 VLQs\n\t * specified by the source map format.\n\t */\n\tSourceMapGenerator.prototype._serializeMappings =\n\t  function SourceMapGenerator_serializeMappings() {\n\t    var previousGeneratedColumn = 0;\n\t    var previousGeneratedLine = 1;\n\t    var previousOriginalColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousName = 0;\n\t    var previousSource = 0;\n\t    var result = '';\n\t    var next;\n\t    var mapping;\n\t    var nameIdx;\n\t    var sourceIdx;\n\t\n\t    var mappings = this._mappings.toArray();\n\t    for (var i = 0, len = mappings.length; i < len; i++) {\n\t      mapping = mappings[i];\n\t      next = ''\n\t\n\t      if (mapping.generatedLine !== previousGeneratedLine) {\n\t        previousGeneratedColumn = 0;\n\t        while (mapping.generatedLine !== previousGeneratedLine) {\n\t          next += ';';\n\t          previousGeneratedLine++;\n\t        }\n\t      }\n\t      else {\n\t        if (i > 0) {\n\t          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n\t            continue;\n\t          }\n\t          next += ',';\n\t        }\n\t      }\n\t\n\t      next += base64VLQ.encode(mapping.generatedColumn\n\t                                 - previousGeneratedColumn);\n\t      previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t      if (mapping.source != null) {\n\t        sourceIdx = this._sources.indexOf(mapping.source);\n\t        next += base64VLQ.encode(sourceIdx - previousSource);\n\t        previousSource = sourceIdx;\n\t\n\t        // lines are stored 0-based in SourceMap spec version 3\n\t        next += base64VLQ.encode(mapping.originalLine - 1\n\t                                   - previousOriginalLine);\n\t        previousOriginalLine = mapping.originalLine - 1;\n\t\n\t        next += base64VLQ.encode(mapping.originalColumn\n\t                                   - previousOriginalColumn);\n\t        previousOriginalColumn = mapping.originalColumn;\n\t\n\t        if (mapping.name != null) {\n\t          nameIdx = this._names.indexOf(mapping.name);\n\t          next += base64VLQ.encode(nameIdx - previousName);\n\t          previousName = nameIdx;\n\t        }\n\t      }\n\t\n\t      result += next;\n\t    }\n\t\n\t    return result;\n\t  };\n\t\n\tSourceMapGenerator.prototype._generateSourcesContent =\n\t  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n\t    return aSources.map(function (source) {\n\t      if (!this._sourcesContents) {\n\t        return null;\n\t      }\n\t      if (aSourceRoot != null) {\n\t        source = util.relative(aSourceRoot, source);\n\t      }\n\t      var key = util.toSetString(source);\n\t      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n\t        ? this._sourcesContents[key]\n\t        : null;\n\t    }, this);\n\t  };\n\t\n\t/**\n\t * Externalize the source map.\n\t */\n\tSourceMapGenerator.prototype.toJSON =\n\t  function SourceMapGenerator_toJSON() {\n\t    var map = {\n\t      version: this._version,\n\t      sources: this._sources.toArray(),\n\t      names: this._names.toArray(),\n\t      mappings: this._serializeMappings()\n\t    };\n\t    if (this._file != null) {\n\t      map.file = this._file;\n\t    }\n\t    if (this._sourceRoot != null) {\n\t      map.sourceRoot = this._sourceRoot;\n\t    }\n\t    if (this._sourcesContents) {\n\t      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n\t    }\n\t\n\t    return map;\n\t  };\n\t\n\t/**\n\t * Render the source map being generated to a string.\n\t */\n\tSourceMapGenerator.prototype.toString =\n\t  function SourceMapGenerator_toString() {\n\t    return JSON.stringify(this.toJSON());\n\t  };\n\t\n\texports.SourceMapGenerator = SourceMapGenerator;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t *\n\t * Based on the Base 64 VLQ implementation in Closure Compiler:\n\t * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n\t *\n\t * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *  * Redistributions of source code must retain the above copyright\n\t *    notice, this list of conditions and the following disclaimer.\n\t *  * Redistributions in binary form must reproduce the above\n\t *    copyright notice, this list of conditions and the following\n\t *    disclaimer in the documentation and/or other materials provided\n\t *    with the distribution.\n\t *  * Neither the name of Google Inc. nor the names of its\n\t *    contributors may be used to endorse or promote products derived\n\t *    from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tvar base64 = __webpack_require__(14);\n\t\n\t// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n\t// length quantities we use in the source map spec, the first bit is the sign,\n\t// the next four bits are the actual value, and the 6th bit is the\n\t// continuation bit. The continuation bit tells us whether there are more\n\t// digits in this value following this digit.\n\t//\n\t//   Continuation\n\t//   |    Sign\n\t//   |    |\n\t//   V    V\n\t//   101011\n\t\n\tvar VLQ_BASE_SHIFT = 5;\n\t\n\t// binary: 100000\n\tvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\t\n\t// binary: 011111\n\tvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\t\n\t// binary: 100000\n\tvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\t\n\t/**\n\t * Converts from a two-complement value to a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n\t *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n\t */\n\tfunction toVLQSigned(aValue) {\n\t  return aValue < 0\n\t    ? ((-aValue) << 1) + 1\n\t    : (aValue << 1) + 0;\n\t}\n\t\n\t/**\n\t * Converts to a two-complement value from a value where the sign bit is\n\t * placed in the least significant bit.  For example, as decimals:\n\t *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n\t *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n\t */\n\tfunction fromVLQSigned(aValue) {\n\t  var isNegative = (aValue & 1) === 1;\n\t  var shifted = aValue >> 1;\n\t  return isNegative\n\t    ? -shifted\n\t    : shifted;\n\t}\n\t\n\t/**\n\t * Returns the base 64 VLQ encoded value.\n\t */\n\texports.encode = function base64VLQ_encode(aValue) {\n\t  var encoded = \"\";\n\t  var digit;\n\t\n\t  var vlq = toVLQSigned(aValue);\n\t\n\t  do {\n\t    digit = vlq & VLQ_BASE_MASK;\n\t    vlq >>>= VLQ_BASE_SHIFT;\n\t    if (vlq > 0) {\n\t      // There are still more digits in this value, so we must make sure the\n\t      // continuation bit is marked.\n\t      digit |= VLQ_CONTINUATION_BIT;\n\t    }\n\t    encoded += base64.encode(digit);\n\t  } while (vlq > 0);\n\t\n\t  return encoded;\n\t};\n\t\n\t/**\n\t * Decodes the next base 64 VLQ value from the given string and returns the\n\t * value and the rest of the string via the out parameter.\n\t */\n\texports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n\t  var strLen = aStr.length;\n\t  var result = 0;\n\t  var shift = 0;\n\t  var continuation, digit;\n\t\n\t  do {\n\t    if (aIndex >= strLen) {\n\t      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n\t    }\n\t\n\t    digit = base64.decode(aStr.charCodeAt(aIndex++));\n\t    if (digit === -1) {\n\t      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n\t    }\n\t\n\t    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n\t    digit &= VLQ_BASE_MASK;\n\t    result = result + (digit << shift);\n\t    shift += VLQ_BASE_SHIFT;\n\t  } while (continuation);\n\t\n\t  aOutParam.value = fromVLQSigned(result);\n\t  aOutParam.rest = aIndex;\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\t\n\t/**\n\t * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n\t */\n\texports.encode = function (number) {\n\t  if (0 <= number && number < intToCharMap.length) {\n\t    return intToCharMap[number];\n\t  }\n\t  throw new TypeError(\"Must be between 0 and 63: \" + number);\n\t};\n\t\n\t/**\n\t * Decode a single base 64 character code digit to an integer. Returns -1 on\n\t * failure.\n\t */\n\texports.decode = function (charCode) {\n\t  var bigA = 65;     // 'A'\n\t  var bigZ = 90;     // 'Z'\n\t\n\t  var littleA = 97;  // 'a'\n\t  var littleZ = 122; // 'z'\n\t\n\t  var zero = 48;     // '0'\n\t  var nine = 57;     // '9'\n\t\n\t  var plus = 43;     // '+'\n\t  var slash = 47;    // '/'\n\t\n\t  var littleOffset = 26;\n\t  var numberOffset = 52;\n\t\n\t  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\t  if (bigA <= charCode && charCode <= bigZ) {\n\t    return (charCode - bigA);\n\t  }\n\t\n\t  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\t  if (littleA <= charCode && charCode <= littleZ) {\n\t    return (charCode - littleA + littleOffset);\n\t  }\n\t\n\t  // 52 - 61: 0123456789\n\t  if (zero <= charCode && charCode <= nine) {\n\t    return (charCode - zero + numberOffset);\n\t  }\n\t\n\t  // 62: +\n\t  if (charCode == plus) {\n\t    return 62;\n\t  }\n\t\n\t  // 63: /\n\t  if (charCode == slash) {\n\t    return 63;\n\t  }\n\t\n\t  // Invalid base64 digit.\n\t  return -1;\n\t};\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t/**\n\t * This is a helper function for getting values from parameter/options\n\t * objects.\n\t *\n\t * @param args The object we are extracting values from\n\t * @param name The name of the property we are getting.\n\t * @param defaultValue An optional value to return if the property is missing\n\t * from the object. If this is not specified and the property is missing, an\n\t * error will be thrown.\n\t */\n\tfunction getArg(aArgs, aName, aDefaultValue) {\n\t  if (aName in aArgs) {\n\t    return aArgs[aName];\n\t  } else if (arguments.length === 3) {\n\t    return aDefaultValue;\n\t  } else {\n\t    throw new Error('\"' + aName + '\" is a required argument.');\n\t  }\n\t}\n\texports.getArg = getArg;\n\t\n\tvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n\tvar dataUrlRegexp = /^data:.+\\,.+$/;\n\t\n\tfunction urlParse(aUrl) {\n\t  var match = aUrl.match(urlRegexp);\n\t  if (!match) {\n\t    return null;\n\t  }\n\t  return {\n\t    scheme: match[1],\n\t    auth: match[2],\n\t    host: match[3],\n\t    port: match[4],\n\t    path: match[5]\n\t  };\n\t}\n\texports.urlParse = urlParse;\n\t\n\tfunction urlGenerate(aParsedUrl) {\n\t  var url = '';\n\t  if (aParsedUrl.scheme) {\n\t    url += aParsedUrl.scheme + ':';\n\t  }\n\t  url += '//';\n\t  if (aParsedUrl.auth) {\n\t    url += aParsedUrl.auth + '@';\n\t  }\n\t  if (aParsedUrl.host) {\n\t    url += aParsedUrl.host;\n\t  }\n\t  if (aParsedUrl.port) {\n\t    url += \":\" + aParsedUrl.port\n\t  }\n\t  if (aParsedUrl.path) {\n\t    url += aParsedUrl.path;\n\t  }\n\t  return url;\n\t}\n\texports.urlGenerate = urlGenerate;\n\t\n\t/**\n\t * Normalizes a path, or the path portion of a URL:\n\t *\n\t * - Replaces consecutive slashes with one slash.\n\t * - Removes unnecessary '.' parts.\n\t * - Removes unnecessary '<dir>/..' parts.\n\t *\n\t * Based on code in the Node.js 'path' core module.\n\t *\n\t * @param aPath The path or url to normalize.\n\t */\n\tfunction normalize(aPath) {\n\t  var path = aPath;\n\t  var url = urlParse(aPath);\n\t  if (url) {\n\t    if (!url.path) {\n\t      return aPath;\n\t    }\n\t    path = url.path;\n\t  }\n\t  var isAbsolute = exports.isAbsolute(path);\n\t\n\t  var parts = path.split(/\\/+/);\n\t  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n\t    part = parts[i];\n\t    if (part === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (part === '..') {\n\t      up++;\n\t    } else if (up > 0) {\n\t      if (part === '') {\n\t        // The first part is blank if the path is absolute. Trying to go\n\t        // above the root is a no-op. Therefore we can remove all '..' parts\n\t        // directly after the root.\n\t        parts.splice(i + 1, up);\n\t        up = 0;\n\t      } else {\n\t        parts.splice(i, 2);\n\t        up--;\n\t      }\n\t    }\n\t  }\n\t  path = parts.join('/');\n\t\n\t  if (path === '') {\n\t    path = isAbsolute ? '/' : '.';\n\t  }\n\t\n\t  if (url) {\n\t    url.path = path;\n\t    return urlGenerate(url);\n\t  }\n\t  return path;\n\t}\n\texports.normalize = normalize;\n\t\n\t/**\n\t * Joins two paths/URLs.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be joined with the root.\n\t *\n\t * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n\t *   first.\n\t * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t *   is updated with the result and aRoot is returned. Otherwise the result\n\t *   is returned.\n\t *   - If aPath is absolute, the result is aPath.\n\t *   - Otherwise the two paths are joined with a slash.\n\t * - Joining for example 'http://' and 'www.example.com' is also supported.\n\t */\n\tfunction join(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t  if (aPath === \"\") {\n\t    aPath = \".\";\n\t  }\n\t  var aPathUrl = urlParse(aPath);\n\t  var aRootUrl = urlParse(aRoot);\n\t  if (aRootUrl) {\n\t    aRoot = aRootUrl.path || '/';\n\t  }\n\t\n\t  // `join(foo, '//www.example.org')`\n\t  if (aPathUrl && !aPathUrl.scheme) {\n\t    if (aRootUrl) {\n\t      aPathUrl.scheme = aRootUrl.scheme;\n\t    }\n\t    return urlGenerate(aPathUrl);\n\t  }\n\t\n\t  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t    return aPath;\n\t  }\n\t\n\t  // `join('http://', 'www.example.com')`\n\t  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t    aRootUrl.host = aPath;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t\n\t  var joined = aPath.charAt(0) === '/'\n\t    ? aPath\n\t    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t\n\t  if (aRootUrl) {\n\t    aRootUrl.path = joined;\n\t    return urlGenerate(aRootUrl);\n\t  }\n\t  return joined;\n\t}\n\texports.join = join;\n\t\n\texports.isAbsolute = function (aPath) {\n\t  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n\t};\n\t\n\t/**\n\t * Make a path relative to a URL or another path.\n\t *\n\t * @param aRoot The root path or URL.\n\t * @param aPath The path or URL to be made relative to aRoot.\n\t */\n\tfunction relative(aRoot, aPath) {\n\t  if (aRoot === \"\") {\n\t    aRoot = \".\";\n\t  }\n\t\n\t  aRoot = aRoot.replace(/\\/$/, '');\n\t\n\t  // It is possible for the path to be above the root. In this case, simply\n\t  // checking whether the root is a prefix of the path won't work. Instead, we\n\t  // need to remove components from the root one by one, until either we find\n\t  // a prefix that fits, or we run out of components to remove.\n\t  var level = 0;\n\t  while (aPath.indexOf(aRoot + '/') !== 0) {\n\t    var index = aRoot.lastIndexOf(\"/\");\n\t    if (index < 0) {\n\t      return aPath;\n\t    }\n\t\n\t    // If the only part of the root that is left is the scheme (i.e. http://,\n\t    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n\t    // have exhausted all components, so the path is not relative to the root.\n\t    aRoot = aRoot.slice(0, index);\n\t    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n\t      return aPath;\n\t    }\n\t\n\t    ++level;\n\t  }\n\t\n\t  // Make sure we add a \"../\" for each component we removed from the root.\n\t  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n\t}\n\texports.relative = relative;\n\t\n\tvar supportsNullProto = (function () {\n\t  var obj = Object.create(null);\n\t  return !('__proto__' in obj);\n\t}());\n\t\n\tfunction identity (s) {\n\t  return s;\n\t}\n\t\n\t/**\n\t * Because behavior goes wacky when you set `__proto__` on objects, we\n\t * have to prefix all the strings in our set with an arbitrary character.\n\t *\n\t * See https://github.com/mozilla/source-map/pull/31 and\n\t * https://github.com/mozilla/source-map/issues/30\n\t *\n\t * @param String aStr\n\t */\n\tfunction toSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return '$' + aStr;\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.toSetString = supportsNullProto ? identity : toSetString;\n\t\n\tfunction fromSetString(aStr) {\n\t  if (isProtoString(aStr)) {\n\t    return aStr.slice(1);\n\t  }\n\t\n\t  return aStr;\n\t}\n\texports.fromSetString = supportsNullProto ? identity : fromSetString;\n\t\n\tfunction isProtoString(s) {\n\t  if (!s) {\n\t    return false;\n\t  }\n\t\n\t  var length = s.length;\n\t\n\t  if (length < 9 /* \"__proto__\".length */) {\n\t    return false;\n\t  }\n\t\n\t  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n\t      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n\t      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n\t      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n\t      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n\t      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n\t    return false;\n\t  }\n\t\n\t  for (var i = length - 10; i >= 0; i--) {\n\t    if (s.charCodeAt(i) !== 36 /* '$' */) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings where the original positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same original source/line/column, but different generated\n\t * line and column the same. Useful when searching for a mapping with a\n\t * stubbed out mapping.\n\t */\n\tfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n\t  var cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0 || onlyCompareOriginal) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByOriginalPositions = compareByOriginalPositions;\n\t\n\t/**\n\t * Comparator between two mappings with deflated source and name indices where\n\t * the generated positions are compared.\n\t *\n\t * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n\t * mappings with the same generated line and column, but different\n\t * source/name/original line and column the same. Useful when searching for a\n\t * mapping with a stubbed out mapping.\n\t */\n\tfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0 || onlyCompareGenerated) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.source - mappingB.source;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return mappingA.name - mappingB.name;\n\t}\n\texports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\t\n\tfunction strcmp(aStr1, aStr2) {\n\t  if (aStr1 === aStr2) {\n\t    return 0;\n\t  }\n\t\n\t  if (aStr1 > aStr2) {\n\t    return 1;\n\t  }\n\t\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Comparator between two mappings with inflated source and name strings where\n\t * the generated positions are compared.\n\t */\n\tfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n\t  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = strcmp(mappingA.source, mappingB.source);\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalLine - mappingB.originalLine;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  cmp = mappingA.originalColumn - mappingB.originalColumn;\n\t  if (cmp !== 0) {\n\t    return cmp;\n\t  }\n\t\n\t  return strcmp(mappingA.name, mappingB.name);\n\t}\n\texports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(15);\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A data structure which is a combination of an array and a set. Adding a new\n\t * member is O(1), testing for membership is O(1), and finding the index of an\n\t * element is O(1). Removing elements from the set is not supported. Only\n\t * strings are supported for membership.\n\t */\n\tfunction ArraySet() {\n\t  this._array = [];\n\t  this._set = Object.create(null);\n\t}\n\t\n\t/**\n\t * Static method for creating ArraySet instances from an existing array.\n\t */\n\tArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n\t  var set = new ArraySet();\n\t  for (var i = 0, len = aArray.length; i < len; i++) {\n\t    set.add(aArray[i], aAllowDuplicates);\n\t  }\n\t  return set;\n\t};\n\t\n\t/**\n\t * Return how many unique items are in this ArraySet. If duplicates have been\n\t * added, than those do not count towards the size.\n\t *\n\t * @returns Number\n\t */\n\tArraySet.prototype.size = function ArraySet_size() {\n\t  return Object.getOwnPropertyNames(this._set).length;\n\t};\n\t\n\t/**\n\t * Add the given string to this set.\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n\t  var sStr = util.toSetString(aStr);\n\t  var isDuplicate = has.call(this._set, sStr);\n\t  var idx = this._array.length;\n\t  if (!isDuplicate || aAllowDuplicates) {\n\t    this._array.push(aStr);\n\t  }\n\t  if (!isDuplicate) {\n\t    this._set[sStr] = idx;\n\t  }\n\t};\n\t\n\t/**\n\t * Is the given string a member of this set?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.has = function ArraySet_has(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  return has.call(this._set, sStr);\n\t};\n\t\n\t/**\n\t * What is the index of the given string in the array?\n\t *\n\t * @param String aStr\n\t */\n\tArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n\t  var sStr = util.toSetString(aStr);\n\t  if (has.call(this._set, sStr)) {\n\t    return this._set[sStr];\n\t  }\n\t  throw new Error('\"' + aStr + '\" is not in the set.');\n\t};\n\t\n\t/**\n\t * What is the element at the given index?\n\t *\n\t * @param Number aIdx\n\t */\n\tArraySet.prototype.at = function ArraySet_at(aIdx) {\n\t  if (aIdx >= 0 && aIdx < this._array.length) {\n\t    return this._array[aIdx];\n\t  }\n\t  throw new Error('No element indexed by ' + aIdx);\n\t};\n\t\n\t/**\n\t * Returns the array representation of this set (which has the proper indices\n\t * indicated by indexOf). Note that this is a copy of the internal array used\n\t * for storing the members so that no one can mess with internal state.\n\t */\n\tArraySet.prototype.toArray = function ArraySet_toArray() {\n\t  return this._array.slice();\n\t};\n\t\n\texports.ArraySet = ArraySet;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2014 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(15);\n\t\n\t/**\n\t * Determine whether mappingB is after mappingA with respect to generated\n\t * position.\n\t */\n\tfunction generatedPositionAfter(mappingA, mappingB) {\n\t  // Optimized for most common case\n\t  var lineA = mappingA.generatedLine;\n\t  var lineB = mappingB.generatedLine;\n\t  var columnA = mappingA.generatedColumn;\n\t  var columnB = mappingB.generatedColumn;\n\t  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n\t         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n\t}\n\t\n\t/**\n\t * A data structure to provide a sorted view of accumulated mappings in a\n\t * performance conscious manner. It trades a neglibable overhead in general\n\t * case for a large speedup in case of mappings being added in order.\n\t */\n\tfunction MappingList() {\n\t  this._array = [];\n\t  this._sorted = true;\n\t  // Serves as infimum\n\t  this._last = {generatedLine: -1, generatedColumn: 0};\n\t}\n\t\n\t/**\n\t * Iterate through internal items. This method takes the same arguments that\n\t * `Array.prototype.forEach` takes.\n\t *\n\t * NOTE: The order of the mappings is NOT guaranteed.\n\t */\n\tMappingList.prototype.unsortedForEach =\n\t  function MappingList_forEach(aCallback, aThisArg) {\n\t    this._array.forEach(aCallback, aThisArg);\n\t  };\n\t\n\t/**\n\t * Add the given source mapping.\n\t *\n\t * @param Object aMapping\n\t */\n\tMappingList.prototype.add = function MappingList_add(aMapping) {\n\t  if (generatedPositionAfter(this._last, aMapping)) {\n\t    this._last = aMapping;\n\t    this._array.push(aMapping);\n\t  } else {\n\t    this._sorted = false;\n\t    this._array.push(aMapping);\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the flat, sorted array of mappings. The mappings are sorted by\n\t * generated position.\n\t *\n\t * WARNING: This method returns internal data without copying, for\n\t * performance. The return value must NOT be mutated, and should be treated as\n\t * an immutable borrow. If you want to take ownership, you must make your own\n\t * copy.\n\t */\n\tMappingList.prototype.toArray = function MappingList_toArray() {\n\t  if (!this._sorted) {\n\t    this._array.sort(util.compareByGeneratedPositionsInflated);\n\t    this._sorted = true;\n\t  }\n\t  return this._array;\n\t};\n\t\n\texports.MappingList = MappingList;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar util = __webpack_require__(15);\n\tvar binarySearch = __webpack_require__(19);\n\tvar ArraySet = __webpack_require__(16).ArraySet;\n\tvar base64VLQ = __webpack_require__(13);\n\tvar quickSort = __webpack_require__(20).quickSort;\n\t\n\tfunction SourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  return sourceMap.sections != null\n\t    ? new IndexedSourceMapConsumer(sourceMap)\n\t    : new BasicSourceMapConsumer(sourceMap);\n\t}\n\t\n\tSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n\t  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n\t}\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tSourceMapConsumer.prototype._version = 3;\n\t\n\t// `__generatedMappings` and `__originalMappings` are arrays that hold the\n\t// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n\t// are lazily instantiated, accessed via the `_generatedMappings` and\n\t// `_originalMappings` getters respectively, and we only parse the mappings\n\t// and create these arrays once queried for a source location. We jump through\n\t// these hoops because there can be many thousands of mappings, and parsing\n\t// them is expensive, so we only want to do it if we must.\n\t//\n\t// Each object in the arrays is of the form:\n\t//\n\t//     {\n\t//       generatedLine: The line number in the generated code,\n\t//       generatedColumn: The column number in the generated code,\n\t//       source: The path to the original source file that generated this\n\t//               chunk of code,\n\t//       originalLine: The line number in the original source that\n\t//                     corresponds to this chunk of generated code,\n\t//       originalColumn: The column number in the original source that\n\t//                       corresponds to this chunk of generated code,\n\t//       name: The name of the original symbol which generated this chunk of\n\t//             code.\n\t//     }\n\t//\n\t// All properties except for `generatedLine` and `generatedColumn` can be\n\t// `null`.\n\t//\n\t// `_generatedMappings` is ordered by the generated positions.\n\t//\n\t// `_originalMappings` is ordered by the original positions.\n\t\n\tSourceMapConsumer.prototype.__generatedMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n\t  get: function () {\n\t    if (!this.__generatedMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__generatedMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype.__originalMappings = null;\n\tObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n\t  get: function () {\n\t    if (!this.__originalMappings) {\n\t      this._parseMappings(this._mappings, this.sourceRoot);\n\t    }\n\t\n\t    return this.__originalMappings;\n\t  }\n\t});\n\t\n\tSourceMapConsumer.prototype._charIsMappingSeparator =\n\t  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n\t    var c = aStr.charAt(index);\n\t    return c === \";\" || c === \",\";\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    throw new Error(\"Subclasses must implement _parseMappings\");\n\t  };\n\t\n\tSourceMapConsumer.GENERATED_ORDER = 1;\n\tSourceMapConsumer.ORIGINAL_ORDER = 2;\n\t\n\tSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n\tSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Iterate over each mapping between an original source/line/column and a\n\t * generated line/column in this source map.\n\t *\n\t * @param Function aCallback\n\t *        The function that is called with each mapping.\n\t * @param Object aContext\n\t *        Optional. If specified, this object will be the value of `this` every\n\t *        time that `aCallback` is called.\n\t * @param aOrder\n\t *        Either `SourceMapConsumer.GENERATED_ORDER` or\n\t *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n\t *        iterate over the mappings sorted by the generated file's line/column\n\t *        order or the original's source/line/column order, respectively. Defaults to\n\t *        `SourceMapConsumer.GENERATED_ORDER`.\n\t */\n\tSourceMapConsumer.prototype.eachMapping =\n\t  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n\t    var context = aContext || null;\n\t    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\t\n\t    var mappings;\n\t    switch (order) {\n\t    case SourceMapConsumer.GENERATED_ORDER:\n\t      mappings = this._generatedMappings;\n\t      break;\n\t    case SourceMapConsumer.ORIGINAL_ORDER:\n\t      mappings = this._originalMappings;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unknown order of iteration.\");\n\t    }\n\t\n\t    var sourceRoot = this.sourceRoot;\n\t    mappings.map(function (mapping) {\n\t      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\t      if (source != null && sourceRoot != null) {\n\t        source = util.join(sourceRoot, source);\n\t      }\n\t      return {\n\t        source: source,\n\t        generatedLine: mapping.generatedLine,\n\t        generatedColumn: mapping.generatedColumn,\n\t        originalLine: mapping.originalLine,\n\t        originalColumn: mapping.originalColumn,\n\t        name: mapping.name === null ? null : this._names.at(mapping.name)\n\t      };\n\t    }, this).forEach(aCallback, context);\n\t  };\n\t\n\t/**\n\t * Returns all generated line and column information for the original source,\n\t * line, and column provided. If no column is provided, returns all mappings\n\t * corresponding to a either the line we are searching for or the next\n\t * closest line that has any mappings. Otherwise, returns all mappings\n\t * corresponding to the given line and either the column we are searching for\n\t * or the next closest column that has any offsets.\n\t *\n\t * The only argument is an object with the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: Optional. the column number in the original source.\n\t *\n\t * and an array of objects is returned, each with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tSourceMapConsumer.prototype.allGeneratedPositionsFor =\n\t  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n\t    var line = util.getArg(aArgs, 'line');\n\t\n\t    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n\t    // returns the index of the closest mapping less than the needle. By\n\t    // setting needle.originalColumn to 0, we thus find the last mapping for\n\t    // the given line, provided such a mapping exists.\n\t    var needle = {\n\t      source: util.getArg(aArgs, 'source'),\n\t      originalLine: line,\n\t      originalColumn: util.getArg(aArgs, 'column', 0)\n\t    };\n\t\n\t    if (this.sourceRoot != null) {\n\t      needle.source = util.relative(this.sourceRoot, needle.source);\n\t    }\n\t    if (!this._sources.has(needle.source)) {\n\t      return [];\n\t    }\n\t    needle.source = this._sources.indexOf(needle.source);\n\t\n\t    var mappings = [];\n\t\n\t    var index = this._findMapping(needle,\n\t                                  this._originalMappings,\n\t                                  \"originalLine\",\n\t                                  \"originalColumn\",\n\t                                  util.compareByOriginalPositions,\n\t                                  binarySearch.LEAST_UPPER_BOUND);\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (aArgs.column === undefined) {\n\t        var originalLine = mapping.originalLine;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we found. Since\n\t        // mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we found.\n\t        while (mapping && mapping.originalLine === originalLine) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      } else {\n\t        var originalColumn = mapping.originalColumn;\n\t\n\t        // Iterate until either we run out of mappings, or we run into\n\t        // a mapping for a different line than the one we were searching for.\n\t        // Since mappings are sorted, this is guaranteed to find all mappings for\n\t        // the line we are searching for.\n\t        while (mapping &&\n\t               mapping.originalLine === line &&\n\t               mapping.originalColumn == originalColumn) {\n\t          mappings.push({\n\t            line: util.getArg(mapping, 'generatedLine', null),\n\t            column: util.getArg(mapping, 'generatedColumn', null),\n\t            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t          });\n\t\n\t          mapping = this._originalMappings[++index];\n\t        }\n\t      }\n\t    }\n\t\n\t    return mappings;\n\t  };\n\t\n\texports.SourceMapConsumer = SourceMapConsumer;\n\t\n\t/**\n\t * A BasicSourceMapConsumer instance represents a parsed source map which we can\n\t * query for information about the original file positions by giving it a file\n\t * position in the generated source.\n\t *\n\t * The only parameter is the raw source map (either as a JSON string, or\n\t * already parsed to an object). According to the spec, source maps have the\n\t * following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - sources: An array of URLs to the original source files.\n\t *   - names: An array of identifiers which can be referrenced by individual mappings.\n\t *   - sourceRoot: Optional. The URL root from which all sources are relative.\n\t *   - sourcesContent: Optional. An array of contents of the original source files.\n\t *   - mappings: A string of base64 VLQs which contain the actual mappings.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *\n\t * Here is an example source map, taken from the source map spec[0]:\n\t *\n\t *     {\n\t *       version : 3,\n\t *       file: \"out.js\",\n\t *       sourceRoot : \"\",\n\t *       sources: [\"foo.js\", \"bar.js\"],\n\t *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *       mappings: \"AA,AB;;ABCDE;\"\n\t *     }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n\t */\n\tfunction BasicSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sources = util.getArg(sourceMap, 'sources');\n\t  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n\t  // requires the array) to play nice here.\n\t  var names = util.getArg(sourceMap, 'names', []);\n\t  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n\t  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n\t  var mappings = util.getArg(sourceMap, 'mappings');\n\t  var file = util.getArg(sourceMap, 'file', null);\n\t\n\t  // Once again, Sass deviates from the spec and supplies the version as a\n\t  // string rather than a number, so we use loose equality checking here.\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  sources = sources\n\t    .map(String)\n\t    // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n\t    // See bugzil.la/1090768.\n\t    .map(util.normalize)\n\t    // Always ensure that absolute sources are internally stored relative to\n\t    // the source root, if the source root is absolute. Not doing this would\n\t    // be particularly problematic when the source root is a prefix of the\n\t    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n\t    .map(function (source) {\n\t      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n\t        ? util.relative(sourceRoot, source)\n\t        : source;\n\t    });\n\t\n\t  // Pass `true` below to allow duplicate names and sources. While source maps\n\t  // are intended to be compressed and deduplicated, the TypeScript compiler\n\t  // sometimes generates source maps with duplicates in them. See Github issue\n\t  // #72 and bugzil.la/889492.\n\t  this._names = ArraySet.fromArray(names.map(String), true);\n\t  this._sources = ArraySet.fromArray(sources, true);\n\t\n\t  this.sourceRoot = sourceRoot;\n\t  this.sourcesContent = sourcesContent;\n\t  this._mappings = mappings;\n\t  this.file = file;\n\t}\n\t\n\tBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\t\n\t/**\n\t * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n\t *\n\t * @param SourceMapGenerator aSourceMap\n\t *        The source map that will be consumed.\n\t * @returns BasicSourceMapConsumer\n\t */\n\tBasicSourceMapConsumer.fromSourceMap =\n\t  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n\t    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\t\n\t    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n\t    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n\t    smc.sourceRoot = aSourceMap._sourceRoot;\n\t    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n\t                                                            smc.sourceRoot);\n\t    smc.file = aSourceMap._file;\n\t\n\t    // Because we are modifying the entries (by converting string sources and\n\t    // names to indices into the sources and names ArraySets), we have to make\n\t    // a copy of the entry or else bad things happen. Shared mutable state\n\t    // strikes again! See github issue #191.\n\t\n\t    var generatedMappings = aSourceMap._mappings.toArray().slice();\n\t    var destGeneratedMappings = smc.__generatedMappings = [];\n\t    var destOriginalMappings = smc.__originalMappings = [];\n\t\n\t    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n\t      var srcMapping = generatedMappings[i];\n\t      var destMapping = new Mapping;\n\t      destMapping.generatedLine = srcMapping.generatedLine;\n\t      destMapping.generatedColumn = srcMapping.generatedColumn;\n\t\n\t      if (srcMapping.source) {\n\t        destMapping.source = sources.indexOf(srcMapping.source);\n\t        destMapping.originalLine = srcMapping.originalLine;\n\t        destMapping.originalColumn = srcMapping.originalColumn;\n\t\n\t        if (srcMapping.name) {\n\t          destMapping.name = names.indexOf(srcMapping.name);\n\t        }\n\t\n\t        destOriginalMappings.push(destMapping);\n\t      }\n\t\n\t      destGeneratedMappings.push(destMapping);\n\t    }\n\t\n\t    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\t\n\t    return smc;\n\t  };\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tBasicSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    return this._sources.toArray().map(function (s) {\n\t      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n\t    }, this);\n\t  }\n\t});\n\t\n\t/**\n\t * Provide the JIT with a nice shape / hidden class.\n\t */\n\tfunction Mapping() {\n\t  this.generatedLine = 0;\n\t  this.generatedColumn = 0;\n\t  this.source = null;\n\t  this.originalLine = null;\n\t  this.originalColumn = null;\n\t  this.name = null;\n\t}\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tBasicSourceMapConsumer.prototype._parseMappings =\n\t  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    var generatedLine = 1;\n\t    var previousGeneratedColumn = 0;\n\t    var previousOriginalLine = 0;\n\t    var previousOriginalColumn = 0;\n\t    var previousSource = 0;\n\t    var previousName = 0;\n\t    var length = aStr.length;\n\t    var index = 0;\n\t    var cachedSegments = {};\n\t    var temp = {};\n\t    var originalMappings = [];\n\t    var generatedMappings = [];\n\t    var mapping, str, segment, end, value;\n\t\n\t    while (index < length) {\n\t      if (aStr.charAt(index) === ';') {\n\t        generatedLine++;\n\t        index++;\n\t        previousGeneratedColumn = 0;\n\t      }\n\t      else if (aStr.charAt(index) === ',') {\n\t        index++;\n\t      }\n\t      else {\n\t        mapping = new Mapping();\n\t        mapping.generatedLine = generatedLine;\n\t\n\t        // Because each offset is encoded relative to the previous one,\n\t        // many segments often have the same encoding. We can exploit this\n\t        // fact by caching the parsed variable length fields of each segment,\n\t        // allowing us to avoid a second parse if we encounter the same\n\t        // segment again.\n\t        for (end = index; end < length; end++) {\n\t          if (this._charIsMappingSeparator(aStr, end)) {\n\t            break;\n\t          }\n\t        }\n\t        str = aStr.slice(index, end);\n\t\n\t        segment = cachedSegments[str];\n\t        if (segment) {\n\t          index += str.length;\n\t        } else {\n\t          segment = [];\n\t          while (index < end) {\n\t            base64VLQ.decode(aStr, index, temp);\n\t            value = temp.value;\n\t            index = temp.rest;\n\t            segment.push(value);\n\t          }\n\t\n\t          if (segment.length === 2) {\n\t            throw new Error('Found a source, but no line and column');\n\t          }\n\t\n\t          if (segment.length === 3) {\n\t            throw new Error('Found a source and line, but no column');\n\t          }\n\t\n\t          cachedSegments[str] = segment;\n\t        }\n\t\n\t        // Generated column.\n\t        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n\t        previousGeneratedColumn = mapping.generatedColumn;\n\t\n\t        if (segment.length > 1) {\n\t          // Original source.\n\t          mapping.source = previousSource + segment[1];\n\t          previousSource += segment[1];\n\t\n\t          // Original line.\n\t          mapping.originalLine = previousOriginalLine + segment[2];\n\t          previousOriginalLine = mapping.originalLine;\n\t          // Lines are stored 0-based\n\t          mapping.originalLine += 1;\n\t\n\t          // Original column.\n\t          mapping.originalColumn = previousOriginalColumn + segment[3];\n\t          previousOriginalColumn = mapping.originalColumn;\n\t\n\t          if (segment.length > 4) {\n\t            // Original name.\n\t            mapping.name = previousName + segment[4];\n\t            previousName += segment[4];\n\t          }\n\t        }\n\t\n\t        generatedMappings.push(mapping);\n\t        if (typeof mapping.originalLine === 'number') {\n\t          originalMappings.push(mapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    this.__generatedMappings = generatedMappings;\n\t\n\t    quickSort(originalMappings, util.compareByOriginalPositions);\n\t    this.__originalMappings = originalMappings;\n\t  };\n\t\n\t/**\n\t * Find the mapping that best matches the hypothetical \"needle\" mapping that\n\t * we are searching for in the given \"haystack\" of mappings.\n\t */\n\tBasicSourceMapConsumer.prototype._findMapping =\n\t  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n\t                                         aColumnName, aComparator, aBias) {\n\t    // To return the position we are searching for, we must first find the\n\t    // mapping for the given position and then return the opposite position it\n\t    // points to. Because the mappings are sorted, we can use binary search to\n\t    // find the best mapping.\n\t\n\t    if (aNeedle[aLineName] <= 0) {\n\t      throw new TypeError('Line must be greater than or equal to 1, got '\n\t                          + aNeedle[aLineName]);\n\t    }\n\t    if (aNeedle[aColumnName] < 0) {\n\t      throw new TypeError('Column must be greater than or equal to 0, got '\n\t                          + aNeedle[aColumnName]);\n\t    }\n\t\n\t    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n\t  };\n\t\n\t/**\n\t * Compute the last column for each generated mapping. The last column is\n\t * inclusive.\n\t */\n\tBasicSourceMapConsumer.prototype.computeColumnSpans =\n\t  function SourceMapConsumer_computeColumnSpans() {\n\t    for (var index = 0; index < this._generatedMappings.length; ++index) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      // Mappings do not contain a field for the last generated columnt. We\n\t      // can come up with an optimistic estimate, however, by assuming that\n\t      // mappings are contiguous (i.e. given two consecutive mappings, the\n\t      // first mapping ends where the second one starts).\n\t      if (index + 1 < this._generatedMappings.length) {\n\t        var nextMapping = this._generatedMappings[index + 1];\n\t\n\t        if (mapping.generatedLine === nextMapping.generatedLine) {\n\t          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n\t          continue;\n\t        }\n\t      }\n\t\n\t      // The last mapping for each line spans the entire line.\n\t      mapping.lastGeneratedColumn = Infinity;\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.originalPositionFor =\n\t  function SourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._generatedMappings,\n\t      \"generatedLine\",\n\t      \"generatedColumn\",\n\t      util.compareByGeneratedPositionsDeflated,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._generatedMappings[index];\n\t\n\t      if (mapping.generatedLine === needle.generatedLine) {\n\t        var source = util.getArg(mapping, 'source', null);\n\t        if (source !== null) {\n\t          source = this._sources.at(source);\n\t          if (this.sourceRoot != null) {\n\t            source = util.join(this.sourceRoot, source);\n\t          }\n\t        }\n\t        var name = util.getArg(mapping, 'name', null);\n\t        if (name !== null) {\n\t          name = this._names.at(name);\n\t        }\n\t        return {\n\t          source: source,\n\t          line: util.getArg(mapping, 'originalLine', null),\n\t          column: util.getArg(mapping, 'originalColumn', null),\n\t          name: name\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      source: null,\n\t      line: null,\n\t      column: null,\n\t      name: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n\t    if (!this.sourcesContent) {\n\t      return false;\n\t    }\n\t    return this.sourcesContent.length >= this._sources.size() &&\n\t      !this.sourcesContent.some(function (sc) { return sc == null; });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tBasicSourceMapConsumer.prototype.sourceContentFor =\n\t  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    if (!this.sourcesContent) {\n\t      return null;\n\t    }\n\t\n\t    if (this.sourceRoot != null) {\n\t      aSource = util.relative(this.sourceRoot, aSource);\n\t    }\n\t\n\t    if (this._sources.has(aSource)) {\n\t      return this.sourcesContent[this._sources.indexOf(aSource)];\n\t    }\n\t\n\t    var url;\n\t    if (this.sourceRoot != null\n\t        && (url = util.urlParse(this.sourceRoot))) {\n\t      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t      // many users. We can help them out when they expect file:// URIs to\n\t      // behave like it would if they were running a local HTTP server. See\n\t      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n\t      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t      if (url.scheme == \"file\"\n\t          && this._sources.has(fileUriAbsPath)) {\n\t        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t      }\n\t\n\t      if ((!url.path || url.path == \"/\")\n\t          && this._sources.has(\"/\" + aSource)) {\n\t        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n\t      }\n\t    }\n\t\n\t    // This function is used recursively from\n\t    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n\t    // don't want to throw if we can't find the source - we just want to\n\t    // return null, so we provide a flag to exit gracefully.\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n\t *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tBasicSourceMapConsumer.prototype.generatedPositionFor =\n\t  function SourceMapConsumer_generatedPositionFor(aArgs) {\n\t    var source = util.getArg(aArgs, 'source');\n\t    if (this.sourceRoot != null) {\n\t      source = util.relative(this.sourceRoot, source);\n\t    }\n\t    if (!this._sources.has(source)) {\n\t      return {\n\t        line: null,\n\t        column: null,\n\t        lastColumn: null\n\t      };\n\t    }\n\t    source = this._sources.indexOf(source);\n\t\n\t    var needle = {\n\t      source: source,\n\t      originalLine: util.getArg(aArgs, 'line'),\n\t      originalColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    var index = this._findMapping(\n\t      needle,\n\t      this._originalMappings,\n\t      \"originalLine\",\n\t      \"originalColumn\",\n\t      util.compareByOriginalPositions,\n\t      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n\t    );\n\t\n\t    if (index >= 0) {\n\t      var mapping = this._originalMappings[index];\n\t\n\t      if (mapping.source === needle.source) {\n\t        return {\n\t          line: util.getArg(mapping, 'generatedLine', null),\n\t          column: util.getArg(mapping, 'generatedColumn', null),\n\t          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n\t        };\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null,\n\t      lastColumn: null\n\t    };\n\t  };\n\t\n\texports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\t\n\t/**\n\t * An IndexedSourceMapConsumer instance represents a parsed source map which\n\t * we can query for information. It differs from BasicSourceMapConsumer in\n\t * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n\t * input.\n\t *\n\t * The only parameter is a raw source map (either as a JSON string, or already\n\t * parsed to an object). According to the spec for indexed source maps, they\n\t * have the following attributes:\n\t *\n\t *   - version: Which version of the source map spec this map is following.\n\t *   - file: Optional. The generated file this source map is associated with.\n\t *   - sections: A list of section definitions.\n\t *\n\t * Each value under the \"sections\" field has two fields:\n\t *   - offset: The offset into the original specified at which this section\n\t *       begins to apply, defined as an object with a \"line\" and \"column\"\n\t *       field.\n\t *   - map: A source map definition. This source map could also be indexed,\n\t *       but doesn't have to be.\n\t *\n\t * Instead of the \"map\" field, it's also possible to have a \"url\" field\n\t * specifying a URL to retrieve a source map from, but that's currently\n\t * unsupported.\n\t *\n\t * Here's an example source map, taken from the source map spec[0], but\n\t * modified to omit a section which uses the \"url\" field.\n\t *\n\t *  {\n\t *    version : 3,\n\t *    file: \"app.js\",\n\t *    sections: [{\n\t *      offset: {line:100, column:10},\n\t *      map: {\n\t *        version : 3,\n\t *        file: \"section.js\",\n\t *        sources: [\"foo.js\", \"bar.js\"],\n\t *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n\t *        mappings: \"AAAA,E;;ABCDE;\"\n\t *      }\n\t *    }],\n\t *  }\n\t *\n\t * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n\t */\n\tfunction IndexedSourceMapConsumer(aSourceMap) {\n\t  var sourceMap = aSourceMap;\n\t  if (typeof aSourceMap === 'string') {\n\t    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n\t  }\n\t\n\t  var version = util.getArg(sourceMap, 'version');\n\t  var sections = util.getArg(sourceMap, 'sections');\n\t\n\t  if (version != this._version) {\n\t    throw new Error('Unsupported version: ' + version);\n\t  }\n\t\n\t  this._sources = new ArraySet();\n\t  this._names = new ArraySet();\n\t\n\t  var lastOffset = {\n\t    line: -1,\n\t    column: 0\n\t  };\n\t  this._sections = sections.map(function (s) {\n\t    if (s.url) {\n\t      // The url field will require support for asynchronicity.\n\t      // See https://github.com/mozilla/source-map/issues/16\n\t      throw new Error('Support for url field in sections not implemented.');\n\t    }\n\t    var offset = util.getArg(s, 'offset');\n\t    var offsetLine = util.getArg(offset, 'line');\n\t    var offsetColumn = util.getArg(offset, 'column');\n\t\n\t    if (offsetLine < lastOffset.line ||\n\t        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n\t      throw new Error('Section offsets must be ordered and non-overlapping.');\n\t    }\n\t    lastOffset = offset;\n\t\n\t    return {\n\t      generatedOffset: {\n\t        // The offset fields are 0-based, but we use 1-based indices when\n\t        // encoding/decoding from VLQ.\n\t        generatedLine: offsetLine + 1,\n\t        generatedColumn: offsetColumn + 1\n\t      },\n\t      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n\t    }\n\t  });\n\t}\n\t\n\tIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n\tIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\t\n\t/**\n\t * The version of the source mapping spec that we are consuming.\n\t */\n\tIndexedSourceMapConsumer.prototype._version = 3;\n\t\n\t/**\n\t * The list of original sources.\n\t */\n\tObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n\t  get: function () {\n\t    var sources = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n\t        sources.push(this._sections[i].consumer.sources[j]);\n\t      }\n\t    }\n\t    return sources;\n\t  }\n\t});\n\t\n\t/**\n\t * Returns the original source, line, and column information for the generated\n\t * source's line and column positions provided. The only argument is an object\n\t * with the following properties:\n\t *\n\t *   - line: The line number in the generated source.\n\t *   - column: The column number in the generated source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - source: The original source file, or null.\n\t *   - line: The line number in the original source, or null.\n\t *   - column: The column number in the original source, or null.\n\t *   - name: The original identifier, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.originalPositionFor =\n\t  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n\t    var needle = {\n\t      generatedLine: util.getArg(aArgs, 'line'),\n\t      generatedColumn: util.getArg(aArgs, 'column')\n\t    };\n\t\n\t    // Find the section containing the generated position we're trying to map\n\t    // to an original position.\n\t    var sectionIndex = binarySearch.search(needle, this._sections,\n\t      function(needle, section) {\n\t        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\t        if (cmp) {\n\t          return cmp;\n\t        }\n\t\n\t        return (needle.generatedColumn -\n\t                section.generatedOffset.generatedColumn);\n\t      });\n\t    var section = this._sections[sectionIndex];\n\t\n\t    if (!section) {\n\t      return {\n\t        source: null,\n\t        line: null,\n\t        column: null,\n\t        name: null\n\t      };\n\t    }\n\t\n\t    return section.consumer.originalPositionFor({\n\t      line: needle.generatedLine -\n\t        (section.generatedOffset.generatedLine - 1),\n\t      column: needle.generatedColumn -\n\t        (section.generatedOffset.generatedLine === needle.generatedLine\n\t         ? section.generatedOffset.generatedColumn - 1\n\t         : 0),\n\t      bias: aArgs.bias\n\t    });\n\t  };\n\t\n\t/**\n\t * Return true if we have the source content for every source in the source\n\t * map, false otherwise.\n\t */\n\tIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n\t  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n\t    return this._sections.every(function (s) {\n\t      return s.consumer.hasContentsOfAllSources();\n\t    });\n\t  };\n\t\n\t/**\n\t * Returns the original source content. The only argument is the url of the\n\t * original source file. Returns null if no original source content is\n\t * available.\n\t */\n\tIndexedSourceMapConsumer.prototype.sourceContentFor =\n\t  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      var content = section.consumer.sourceContentFor(aSource, true);\n\t      if (content) {\n\t        return content;\n\t      }\n\t    }\n\t    if (nullOnMissing) {\n\t      return null;\n\t    }\n\t    else {\n\t      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n\t    }\n\t  };\n\t\n\t/**\n\t * Returns the generated line and column information for the original source,\n\t * line, and column positions provided. The only argument is an object with\n\t * the following properties:\n\t *\n\t *   - source: The filename of the original source.\n\t *   - line: The line number in the original source.\n\t *   - column: The column number in the original source.\n\t *\n\t * and an object is returned with the following properties:\n\t *\n\t *   - line: The line number in the generated source, or null.\n\t *   - column: The column number in the generated source, or null.\n\t */\n\tIndexedSourceMapConsumer.prototype.generatedPositionFor =\n\t  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t\n\t      // Only consider this section if the requested source is in the list of\n\t      // sources of the consumer.\n\t      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n\t        continue;\n\t      }\n\t      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\t      if (generatedPosition) {\n\t        var ret = {\n\t          line: generatedPosition.line +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          column: generatedPosition.column +\n\t            (section.generatedOffset.generatedLine === generatedPosition.line\n\t             ? section.generatedOffset.generatedColumn - 1\n\t             : 0)\n\t        };\n\t        return ret;\n\t      }\n\t    }\n\t\n\t    return {\n\t      line: null,\n\t      column: null\n\t    };\n\t  };\n\t\n\t/**\n\t * Parse the mappings in a string in to a data structure which we can easily\n\t * query (the ordered arrays in the `this.__generatedMappings` and\n\t * `this.__originalMappings` properties).\n\t */\n\tIndexedSourceMapConsumer.prototype._parseMappings =\n\t  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n\t    this.__generatedMappings = [];\n\t    this.__originalMappings = [];\n\t    for (var i = 0; i < this._sections.length; i++) {\n\t      var section = this._sections[i];\n\t      var sectionMappings = section.consumer._generatedMappings;\n\t      for (var j = 0; j < sectionMappings.length; j++) {\n\t        var mapping = sectionMappings[j];\n\t\n\t        var source = section.consumer._sources.at(mapping.source);\n\t        if (section.consumer.sourceRoot !== null) {\n\t          source = util.join(section.consumer.sourceRoot, source);\n\t        }\n\t        this._sources.add(source);\n\t        source = this._sources.indexOf(source);\n\t\n\t        var name = section.consumer._names.at(mapping.name);\n\t        this._names.add(name);\n\t        name = this._names.indexOf(name);\n\t\n\t        // The mappings coming from the consumer for the section have\n\t        // generated positions relative to the start of the section, so we\n\t        // need to offset them to be relative to the start of the concatenated\n\t        // generated file.\n\t        var adjustedMapping = {\n\t          source: source,\n\t          generatedLine: mapping.generatedLine +\n\t            (section.generatedOffset.generatedLine - 1),\n\t          generatedColumn: mapping.generatedColumn +\n\t            (section.generatedOffset.generatedLine === mapping.generatedLine\n\t            ? section.generatedOffset.generatedColumn - 1\n\t            : 0),\n\t          originalLine: mapping.originalLine,\n\t          originalColumn: mapping.originalColumn,\n\t          name: name\n\t        };\n\t\n\t        this.__generatedMappings.push(adjustedMapping);\n\t        if (typeof adjustedMapping.originalLine === 'number') {\n\t          this.__originalMappings.push(adjustedMapping);\n\t        }\n\t      }\n\t    }\n\t\n\t    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n\t    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n\t  };\n\t\n\texports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\texports.GREATEST_LOWER_BOUND = 1;\n\texports.LEAST_UPPER_BOUND = 2;\n\t\n\t/**\n\t * Recursive implementation of binary search.\n\t *\n\t * @param aLow Indices here and lower do not contain the needle.\n\t * @param aHigh Indices here and higher do not contain the needle.\n\t * @param aNeedle The element being searched for.\n\t * @param aHaystack The non-empty array being searched.\n\t * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t */\n\tfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n\t  // This function terminates when one of the following is true:\n\t  //\n\t  //   1. We find the exact element we are looking for.\n\t  //\n\t  //   2. We did not find the exact element, but we can return the index of\n\t  //      the next-closest element.\n\t  //\n\t  //   3. We did not find the exact element, and there is no next-closest\n\t  //      element than the one we are searching for, so we return -1.\n\t  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n\t  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\t  if (cmp === 0) {\n\t    // Found the element we are looking for.\n\t    return mid;\n\t  }\n\t  else if (cmp > 0) {\n\t    // Our needle is greater than aHaystack[mid].\n\t    if (aHigh - mid > 1) {\n\t      // The element is in the upper half.\n\t      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // The exact needle element was not found in this haystack. Determine if\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return aHigh < aHaystack.length ? aHigh : -1;\n\t    } else {\n\t      return mid;\n\t    }\n\t  }\n\t  else {\n\t    // Our needle is less than aHaystack[mid].\n\t    if (mid - aLow > 1) {\n\t      // The element is in the lower half.\n\t      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n\t    }\n\t\n\t    // we are in termination case (3) or (2) and return the appropriate thing.\n\t    if (aBias == exports.LEAST_UPPER_BOUND) {\n\t      return mid;\n\t    } else {\n\t      return aLow < 0 ? -1 : aLow;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * This is an implementation of binary search which will always try and return\n\t * the index of the closest element if there is no exact hit. This is because\n\t * mappings between original and generated line/col pairs are single points,\n\t * and there is an implicit region between each of them, so a miss just means\n\t * that you aren't on the very start of a region.\n\t *\n\t * @param aNeedle The element you are looking for.\n\t * @param aHaystack The array that is being searched.\n\t * @param aCompare A function which takes the needle and an element in the\n\t *     array and returns -1, 0, or 1 depending on whether the needle is less\n\t *     than, equal to, or greater than the element, respectively.\n\t * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n\t *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n\t *     closest element that is smaller than or greater than the one we are\n\t *     searching for, respectively, if the exact element cannot be found.\n\t *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n\t */\n\texports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n\t  if (aHaystack.length === 0) {\n\t    return -1;\n\t  }\n\t\n\t  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n\t                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\t  if (index < 0) {\n\t    return -1;\n\t  }\n\t\n\t  // We have found either the exact element, or the next-closest element than\n\t  // the one we are searching for. However, there may be more than one such\n\t  // element. Make sure we always return the smallest of these.\n\t  while (index - 1 >= 0) {\n\t    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n\t      break;\n\t    }\n\t    --index;\n\t  }\n\t\n\t  return index;\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\t// It turns out that some (most?) JavaScript engines don't self-host\n\t// `Array.prototype.sort`. This makes sense because C++ will likely remain\n\t// faster than JS when doing raw CPU-intensive sorting. However, when using a\n\t// custom comparator function, calling back and forth between the VM's C++ and\n\t// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n\t// worse generated code for the comparator function than would be optimal. In\n\t// fact, when sorting with a comparator, these costs outweigh the benefits of\n\t// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n\t// a ~3500ms mean speed-up in `bench/bench.html`.\n\t\n\t/**\n\t * Swap the elements indexed by `x` and `y` in the array `ary`.\n\t *\n\t * @param {Array} ary\n\t *        The array.\n\t * @param {Number} x\n\t *        The index of the first item.\n\t * @param {Number} y\n\t *        The index of the second item.\n\t */\n\tfunction swap(ary, x, y) {\n\t  var temp = ary[x];\n\t  ary[x] = ary[y];\n\t  ary[y] = temp;\n\t}\n\t\n\t/**\n\t * Returns a random integer within the range `low .. high` inclusive.\n\t *\n\t * @param {Number} low\n\t *        The lower bound on the range.\n\t * @param {Number} high\n\t *        The upper bound on the range.\n\t */\n\tfunction randomIntInRange(low, high) {\n\t  return Math.round(low + (Math.random() * (high - low)));\n\t}\n\t\n\t/**\n\t * The Quick Sort algorithm.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t * @param {Number} p\n\t *        Start index of the array\n\t * @param {Number} r\n\t *        End index of the array\n\t */\n\tfunction doQuickSort(ary, comparator, p, r) {\n\t  // If our lower bound is less than our upper bound, we (1) partition the\n\t  // array into two pieces and (2) recurse on each half. If it is not, this is\n\t  // the empty array and our base case.\n\t\n\t  if (p < r) {\n\t    // (1) Partitioning.\n\t    //\n\t    // The partitioning chooses a pivot between `p` and `r` and moves all\n\t    // elements that are less than or equal to the pivot to the before it, and\n\t    // all the elements that are greater than it after it. The effect is that\n\t    // once partition is done, the pivot is in the exact place it will be when\n\t    // the array is put in sorted order, and it will not need to be moved\n\t    // again. This runs in O(n) time.\n\t\n\t    // Always choose a random pivot so that an input array which is reverse\n\t    // sorted does not cause O(n^2) running time.\n\t    var pivotIndex = randomIntInRange(p, r);\n\t    var i = p - 1;\n\t\n\t    swap(ary, pivotIndex, r);\n\t    var pivot = ary[r];\n\t\n\t    // Immediately after `j` is incremented in this loop, the following hold\n\t    // true:\n\t    //\n\t    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n\t    //\n\t    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\t    for (var j = p; j < r; j++) {\n\t      if (comparator(ary[j], pivot) <= 0) {\n\t        i += 1;\n\t        swap(ary, i, j);\n\t      }\n\t    }\n\t\n\t    swap(ary, i + 1, j);\n\t    var q = i + 1;\n\t\n\t    // (2) Recurse on each half.\n\t\n\t    doQuickSort(ary, comparator, p, q - 1);\n\t    doQuickSort(ary, comparator, q + 1, r);\n\t  }\n\t}\n\t\n\t/**\n\t * Sort the given array in-place with the given comparator function.\n\t *\n\t * @param {Array} ary\n\t *        An array to sort.\n\t * @param {function} comparator\n\t *        Function to use to compare two items.\n\t */\n\texports.quickSort = function (ary, comparator) {\n\t  doQuickSort(ary, comparator, 0, ary.length - 1);\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* -*- Mode: js; js-indent-level: 2; -*- */\n\t/*\n\t * Copyright 2011 Mozilla Foundation and contributors\n\t * Licensed under the New BSD license. See LICENSE or:\n\t * http://opensource.org/licenses/BSD-3-Clause\n\t */\n\t\n\tvar SourceMapGenerator = __webpack_require__(12).SourceMapGenerator;\n\tvar util = __webpack_require__(15);\n\t\n\t// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n\t// operating systems these days (capturing the result).\n\tvar REGEX_NEWLINE = /(\\r?\\n)/;\n\t\n\t// Newline character code for charCodeAt() comparisons\n\tvar NEWLINE_CODE = 10;\n\t\n\t// Private symbol for identifying `SourceNode`s when multiple versions of\n\t// the source-map library are loaded. This MUST NOT CHANGE across\n\t// versions!\n\tvar isSourceNode = \"$$$isSourceNode$$$\";\n\t\n\t/**\n\t * SourceNodes provide a way to abstract over interpolating/concatenating\n\t * snippets of generated JavaScript source code while maintaining the line and\n\t * column information associated with the original source code.\n\t *\n\t * @param aLine The original line number.\n\t * @param aColumn The original column number.\n\t * @param aSource The original source's filename.\n\t * @param aChunks Optional. An array of strings which are snippets of\n\t *        generated JS, or other SourceNodes.\n\t * @param aName The original identifier.\n\t */\n\tfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n\t  this.children = [];\n\t  this.sourceContents = {};\n\t  this.line = aLine == null ? null : aLine;\n\t  this.column = aColumn == null ? null : aColumn;\n\t  this.source = aSource == null ? null : aSource;\n\t  this.name = aName == null ? null : aName;\n\t  this[isSourceNode] = true;\n\t  if (aChunks != null) this.add(aChunks);\n\t}\n\t\n\t/**\n\t * Creates a SourceNode from generated code and a SourceMapConsumer.\n\t *\n\t * @param aGeneratedCode The generated code\n\t * @param aSourceMapConsumer The SourceMap for the generated code\n\t * @param aRelativePath Optional. The path that relative sources in the\n\t *        SourceMapConsumer should be relative to.\n\t */\n\tSourceNode.fromStringWithSourceMap =\n\t  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n\t    // The SourceNode we want to fill with the generated code\n\t    // and the SourceMap\n\t    var node = new SourceNode();\n\t\n\t    // All even indices of this array are one line of the generated code,\n\t    // while all odd indices are the newlines between two adjacent lines\n\t    // (since `REGEX_NEWLINE` captures its match).\n\t    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\t    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\t    var shiftNextLine = function() {\n\t      var lineContents = remainingLines.shift();\n\t      // The last line of a file might not have a newline.\n\t      var newLine = remainingLines.shift() || \"\";\n\t      return lineContents + newLine;\n\t    };\n\t\n\t    // We need to remember the position of \"remainingLines\"\n\t    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\t\n\t    // The generate SourceNodes we need a code range.\n\t    // To extract it current and last mapping is used.\n\t    // Here we store the last mapping.\n\t    var lastMapping = null;\n\t\n\t    aSourceMapConsumer.eachMapping(function (mapping) {\n\t      if (lastMapping !== null) {\n\t        // We add the code from \"lastMapping\" to \"mapping\":\n\t        // First check if there is a new line in between.\n\t        if (lastGeneratedLine < mapping.generatedLine) {\n\t          // Associate first line with \"lastMapping\"\n\t          addMappingWithCode(lastMapping, shiftNextLine());\n\t          lastGeneratedLine++;\n\t          lastGeneratedColumn = 0;\n\t          // The remaining code is added without mapping\n\t        } else {\n\t          // There is no new line in between.\n\t          // Associate the code between \"lastGeneratedColumn\" and\n\t          // \"mapping.generatedColumn\" with \"lastMapping\"\n\t          var nextLine = remainingLines[0];\n\t          var code = nextLine.substr(0, mapping.generatedColumn -\n\t                                        lastGeneratedColumn);\n\t          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n\t                                              lastGeneratedColumn);\n\t          lastGeneratedColumn = mapping.generatedColumn;\n\t          addMappingWithCode(lastMapping, code);\n\t          // No more remaining code, continue\n\t          lastMapping = mapping;\n\t          return;\n\t        }\n\t      }\n\t      // We add the generated code until the first mapping\n\t      // to the SourceNode without any mapping.\n\t      // Each line is added as separate string.\n\t      while (lastGeneratedLine < mapping.generatedLine) {\n\t        node.add(shiftNextLine());\n\t        lastGeneratedLine++;\n\t      }\n\t      if (lastGeneratedColumn < mapping.generatedColumn) {\n\t        var nextLine = remainingLines[0];\n\t        node.add(nextLine.substr(0, mapping.generatedColumn));\n\t        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n\t        lastGeneratedColumn = mapping.generatedColumn;\n\t      }\n\t      lastMapping = mapping;\n\t    }, this);\n\t    // We have processed all mappings.\n\t    if (remainingLines.length > 0) {\n\t      if (lastMapping) {\n\t        // Associate the remaining code in the current line with \"lastMapping\"\n\t        addMappingWithCode(lastMapping, shiftNextLine());\n\t      }\n\t      // and add the remaining lines without any mapping\n\t      node.add(remainingLines.join(\"\"));\n\t    }\n\t\n\t    // Copy sourcesContent into SourceNode\n\t    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n\t      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\t      if (content != null) {\n\t        if (aRelativePath != null) {\n\t          sourceFile = util.join(aRelativePath, sourceFile);\n\t        }\n\t        node.setSourceContent(sourceFile, content);\n\t      }\n\t    });\n\t\n\t    return node;\n\t\n\t    function addMappingWithCode(mapping, code) {\n\t      if (mapping === null || mapping.source === undefined) {\n\t        node.add(code);\n\t      } else {\n\t        var source = aRelativePath\n\t          ? util.join(aRelativePath, mapping.source)\n\t          : mapping.source;\n\t        node.add(new SourceNode(mapping.originalLine,\n\t                                mapping.originalColumn,\n\t                                source,\n\t                                code,\n\t                                mapping.name));\n\t      }\n\t    }\n\t  };\n\t\n\t/**\n\t * Add a chunk of generated JS to this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.add = function SourceNode_add(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    aChunk.forEach(function (chunk) {\n\t      this.add(chunk);\n\t    }, this);\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    if (aChunk) {\n\t      this.children.push(aChunk);\n\t    }\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a chunk of generated JS to the beginning of this source node.\n\t *\n\t * @param aChunk A string snippet of generated JS code, another instance of\n\t *        SourceNode, or an array where each member is one of those things.\n\t */\n\tSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n\t  if (Array.isArray(aChunk)) {\n\t    for (var i = aChunk.length-1; i >= 0; i--) {\n\t      this.prepend(aChunk[i]);\n\t    }\n\t  }\n\t  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n\t    this.children.unshift(aChunk);\n\t  }\n\t  else {\n\t    throw new TypeError(\n\t      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n\t    );\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Walk over the tree of JS snippets in this node and its children. The\n\t * walking function is called once for each snippet of JS and is passed that\n\t * snippet and the its original associated source's line/column location.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n\t  var chunk;\n\t  for (var i = 0, len = this.children.length; i < len; i++) {\n\t    chunk = this.children[i];\n\t    if (chunk[isSourceNode]) {\n\t      chunk.walk(aFn);\n\t    }\n\t    else {\n\t      if (chunk !== '') {\n\t        aFn(chunk, { source: this.source,\n\t                     line: this.line,\n\t                     column: this.column,\n\t                     name: this.name });\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n\t * each of `this.children`.\n\t *\n\t * @param aSep The separator.\n\t */\n\tSourceNode.prototype.join = function SourceNode_join(aSep) {\n\t  var newChildren;\n\t  var i;\n\t  var len = this.children.length;\n\t  if (len > 0) {\n\t    newChildren = [];\n\t    for (i = 0; i < len-1; i++) {\n\t      newChildren.push(this.children[i]);\n\t      newChildren.push(aSep);\n\t    }\n\t    newChildren.push(this.children[i]);\n\t    this.children = newChildren;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Call String.prototype.replace on the very right-most source snippet. Useful\n\t * for trimming whitespace from the end of a source node, etc.\n\t *\n\t * @param aPattern The pattern to replace.\n\t * @param aReplacement The thing to replace the pattern with.\n\t */\n\tSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n\t  var lastChild = this.children[this.children.length - 1];\n\t  if (lastChild[isSourceNode]) {\n\t    lastChild.replaceRight(aPattern, aReplacement);\n\t  }\n\t  else if (typeof lastChild === 'string') {\n\t    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n\t  }\n\t  else {\n\t    this.children.push(''.replace(aPattern, aReplacement));\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the source content for a source file. This will be added to the SourceMapGenerator\n\t * in the sourcesContent field.\n\t *\n\t * @param aSourceFile The filename of the source file\n\t * @param aSourceContent The content of the source file\n\t */\n\tSourceNode.prototype.setSourceContent =\n\t  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n\t    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n\t  };\n\t\n\t/**\n\t * Walk over the tree of SourceNodes. The walking function is called for each\n\t * source file content and is passed the filename and source content.\n\t *\n\t * @param aFn The traversal function.\n\t */\n\tSourceNode.prototype.walkSourceContents =\n\t  function SourceNode_walkSourceContents(aFn) {\n\t    for (var i = 0, len = this.children.length; i < len; i++) {\n\t      if (this.children[i][isSourceNode]) {\n\t        this.children[i].walkSourceContents(aFn);\n\t      }\n\t    }\n\t\n\t    var sources = Object.keys(this.sourceContents);\n\t    for (var i = 0, len = sources.length; i < len; i++) {\n\t      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n\t    }\n\t  };\n\t\n\t/**\n\t * Return the string representation of this source node. Walks over the tree\n\t * and concatenates all the various snippets together to one string.\n\t */\n\tSourceNode.prototype.toString = function SourceNode_toString() {\n\t  var str = \"\";\n\t  this.walk(function (chunk) {\n\t    str += chunk;\n\t  });\n\t  return str;\n\t};\n\t\n\t/**\n\t * Returns the string representation of this source node along with a source\n\t * map.\n\t */\n\tSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n\t  var generated = {\n\t    code: \"\",\n\t    line: 1,\n\t    column: 0\n\t  };\n\t  var map = new SourceMapGenerator(aArgs);\n\t  var sourceMappingActive = false;\n\t  var lastOriginalSource = null;\n\t  var lastOriginalLine = null;\n\t  var lastOriginalColumn = null;\n\t  var lastOriginalName = null;\n\t  this.walk(function (chunk, original) {\n\t    generated.code += chunk;\n\t    if (original.source !== null\n\t        && original.line !== null\n\t        && original.column !== null) {\n\t      if(lastOriginalSource !== original.source\n\t         || lastOriginalLine !== original.line\n\t         || lastOriginalColumn !== original.column\n\t         || lastOriginalName !== original.name) {\n\t        map.addMapping({\n\t          source: original.source,\n\t          original: {\n\t            line: original.line,\n\t            column: original.column\n\t          },\n\t          generated: {\n\t            line: generated.line,\n\t            column: generated.column\n\t          },\n\t          name: original.name\n\t        });\n\t      }\n\t      lastOriginalSource = original.source;\n\t      lastOriginalLine = original.line;\n\t      lastOriginalColumn = original.column;\n\t      lastOriginalName = original.name;\n\t      sourceMappingActive = true;\n\t    } else if (sourceMappingActive) {\n\t      map.addMapping({\n\t        generated: {\n\t          line: generated.line,\n\t          column: generated.column\n\t        }\n\t      });\n\t      lastOriginalSource = null;\n\t      sourceMappingActive = false;\n\t    }\n\t    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n\t      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n\t        generated.line++;\n\t        generated.column = 0;\n\t        // Mappings end at eol\n\t        if (idx + 1 === length) {\n\t          lastOriginalSource = null;\n\t          sourceMappingActive = false;\n\t        } else if (sourceMappingActive) {\n\t          map.addMapping({\n\t            source: original.source,\n\t            original: {\n\t              line: original.line,\n\t              column: original.column\n\t            },\n\t            generated: {\n\t              line: generated.line,\n\t              column: generated.column\n\t            },\n\t            name: original.name\n\t          });\n\t        }\n\t      } else {\n\t        generated.column++;\n\t      }\n\t    }\n\t  });\n\t  this.walkSourceContents(function (sourceFile, sourceContent) {\n\t    map.setSourceContent(sourceFile, sourceContent);\n\t  });\n\t\n\t  return { code: generated.code, map: map };\n\t};\n\t\n\texports.SourceNode = SourceNode;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AbstractCategoryLogger_1 = __webpack_require__(1);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\t/**\n\t * Simple logger, that logs to the console. If the console is unavailable will throw an exception.\n\t */\n\tvar CategoryConsoleLoggerImpl = (function (_super) {\n\t    __extends(CategoryConsoleLoggerImpl, _super);\n\t    function CategoryConsoleLoggerImpl(rootCategory, runtimeSettings) {\n\t        return _super.call(this, rootCategory, runtimeSettings) || this;\n\t    }\n\t    CategoryConsoleLoggerImpl.prototype.doLog = function (msg) {\n\t        var fullMsg = this.createDefaultLogMessage(msg);\n\t        if (console !== undefined) {\n\t            var logged = false;\n\t            /* tslint:disable:no-console */\n\t            switch (msg.getLevel()) {\n\t                case LoggerOptions_1.LogLevel.Trace:\n\t                    if (console.trace) {\n\t                        console.trace(fullMsg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Debug:\n\t                    if (console.debug) {\n\t                        console.debug(fullMsg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Info:\n\t                    if (console.info) {\n\t                        console.info(fullMsg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Warn:\n\t                    if (console.warn) {\n\t                        console.warn(fullMsg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Error:\n\t                case LoggerOptions_1.LogLevel.Fatal:\n\t                    if (console.error) {\n\t                        console.error(fullMsg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                default:\n\t                    throw new Error(\"Unsupported level: \" + msg.getLevel());\n\t            }\n\t            if (!logged) {\n\t                console.log(fullMsg);\n\t            }\n\t        }\n\t        else {\n\t            throw new Error(\"Console is not defined, cannot log msg: \" + fullMsg);\n\t        }\n\t    };\n\t    return CategoryConsoleLoggerImpl;\n\t}(AbstractCategoryLogger_1.AbstractCategoryLogger));\n\texports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl;\n\t//# sourceMappingURL=CategoryConsoleLoggerImpl.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t/**\n\t * Delegate logger, delegates logging to given logger (constructor).\n\t */\n\tvar CategoryDelegateLoggerImpl = (function () {\n\t    function CategoryDelegateLoggerImpl(delegate) {\n\t        this._delegate = delegate;\n\t    }\n\t    Object.defineProperty(CategoryDelegateLoggerImpl.prototype, \"delegate\", {\n\t        get: function () {\n\t            return this._delegate;\n\t        },\n\t        set: function (value) {\n\t            this._delegate = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    CategoryDelegateLoggerImpl.prototype.trace = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).trace.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.debug = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).debug.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.info = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).info.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.warn = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).warn.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.error = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).error.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.fatal = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).fatal.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.resolved = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).resolved.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.log = function (level, msg, error) {\n\t        var categories = [];\n\t        for (var _i = 3; _i < arguments.length; _i++) {\n\t            categories[_i - 3] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).log.apply(_a, [level, msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.tracec = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).tracec.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.debugc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).debugc.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.infoc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).infoc.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.warnc = function (msg) {\n\t        var categories = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            categories[_i - 1] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).warnc.apply(_a, [msg].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.errorc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).errorc.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.fatalc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).fatalc.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.resolvedc = function (msg, error) {\n\t        var categories = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            categories[_i - 2] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).resolvedc.apply(_a, [msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    CategoryDelegateLoggerImpl.prototype.logc = function (level, msg, error) {\n\t        var categories = [];\n\t        for (var _i = 3; _i < arguments.length; _i++) {\n\t            categories[_i - 3] = arguments[_i];\n\t        }\n\t        (_a = this._delegate).logc.apply(_a, [level, msg, error].concat(categories));\n\t        var _a;\n\t    };\n\t    return CategoryDelegateLoggerImpl;\n\t}());\n\texports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl;\n\t//# sourceMappingURL=CategoryDelegateLoggerImpl.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar CategoryService_1 = __webpack_require__(25);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\t/**\n\t * Category for use with categorized logging.\n\t * At minimum you need one category, which will serve as the root category.\n\t * You can create child categories (like a tree). You can have multiple root\n\t * categories.\n\t */\n\tvar Category = (function () {\n\t    function Category(name, parent) {\n\t        if (parent === void 0) { parent = null; }\n\t        this._children = [];\n\t        this._logLevel = LoggerOptions_1.LogLevel.Error;\n\t        if (name.indexOf(\"#\") !== -1) {\n\t            throw new Error(\"Cannot use # in a name of a Category\");\n\t        }\n\t        this._id = Category.nextId();\n\t        this._name = name;\n\t        this._parent = parent;\n\t        if (this._parent != null) {\n\t            this._parent._children.push(this);\n\t        }\n\t        CategoryService_1.CategoryServiceImpl.getInstance().registerCategory(this);\n\t    }\n\t    Object.defineProperty(Category.prototype, \"name\", {\n\t        get: function () {\n\t            return this._name;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Category.prototype, \"parent\", {\n\t        get: function () {\n\t            return this._parent;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Category.prototype, \"children\", {\n\t        get: function () {\n\t            return this._children;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Category.prototype, \"logLevel\", {\n\t        get: function () {\n\t            return this._logLevel;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Category.prototype.getCategoryPath = function () {\n\t        var result = this.name;\n\t        var cat = this.parent;\n\t        while (cat != null) {\n\t            result = cat.name + \"#\" + result;\n\t            cat = cat.parent;\n\t        }\n\t        return result;\n\t    };\n\t    Object.defineProperty(Category.prototype, \"id\", {\n\t        /**\n\t         * Returns the id for this category (this\n\t         * is for internal purposes only).\n\t         * @returns {number} Id\n\t         */\n\t        get: function () {\n\t            return this._id;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Category.nextId = function () {\n\t        return Category.currentId++;\n\t    };\n\t    return Category;\n\t}());\n\texports.Category = Category;\n\tCategory.currentId = 1;\n\t//# sourceMappingURL=CategoryLogger.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar CategoryConsoleLoggerImpl_1 = __webpack_require__(22);\n\tvar CategoryDelegateLoggerImpl_1 = __webpack_require__(23);\n\tvar CategoryExtensionLoggerImpl_1 = __webpack_require__(26);\n\tvar CategoryMessageBufferImpl_1 = __webpack_require__(28);\n\tvar DataStructures_1 = __webpack_require__(2);\n\tvar ExtensionHelper_1 = __webpack_require__(27);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\t/**\n\t * RuntimeSettings for a category, at runtime these are associated to a category.\n\t */\n\tvar CategoryRuntimeSettings = (function () {\n\t    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger) {\n\t        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }\n\t        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n\t        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }\n\t        if (callBackLogger === void 0) { callBackLogger = null; }\n\t        this._category = category;\n\t        this._logLevel = logLevel;\n\t        this._loggerType = loggerType;\n\t        this._logFormat = logFormat;\n\t        this._callBackLogger = callBackLogger;\n\t    }\n\t    Object.defineProperty(CategoryRuntimeSettings.prototype, \"category\", {\n\t        get: function () {\n\t            return this._category;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryRuntimeSettings.prototype, \"logLevel\", {\n\t        get: function () {\n\t            return this._logLevel;\n\t        },\n\t        set: function (value) {\n\t            this._logLevel = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryRuntimeSettings.prototype, \"loggerType\", {\n\t        get: function () {\n\t            return this._loggerType;\n\t        },\n\t        set: function (value) {\n\t            this._loggerType = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryRuntimeSettings.prototype, \"logFormat\", {\n\t        get: function () {\n\t            return this._logFormat;\n\t        },\n\t        set: function (value) {\n\t            this._logFormat = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryRuntimeSettings.prototype, \"callBackLogger\", {\n\t        get: function () {\n\t            return this._callBackLogger;\n\t        },\n\t        set: function (value) {\n\t            this._callBackLogger = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return CategoryRuntimeSettings;\n\t}());\n\texports.CategoryRuntimeSettings = CategoryRuntimeSettings;\n\t/**\n\t * Default configuration, can be used to initially set a different default configuration\n\t * on the CategoryServiceFactory. This will be applied to all categories already registered (or\n\t * registered in the future).\n\t */\n\tvar CategoryDefaultConfiguration = (function () {\n\t    /**\n\t     * Create a new instance\n\t     * @param logLevel Log level for all loggers, default is LogLevel.Error\n\t     * @param loggerType Where to log, default is LoggerType.Console\n\t     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.\n\t     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.\n\t     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.\n\t     */\n\t    function CategoryDefaultConfiguration(logLevel, loggerType, logFormat, callBackLogger) {\n\t        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }\n\t        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n\t        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }\n\t        if (callBackLogger === void 0) { callBackLogger = null; }\n\t        this._logLevel = logLevel;\n\t        this._loggerType = loggerType;\n\t        this._logFormat = logFormat;\n\t        this._callBackLogger = callBackLogger;\n\t        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {\n\t            throw new Error(\"If you specify loggerType to be Custom, you must provide the callBackLogger argument\");\n\t        }\n\t    }\n\t    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"logLevel\", {\n\t        get: function () {\n\t            return this._logLevel;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"loggerType\", {\n\t        get: function () {\n\t            return this._loggerType;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"logFormat\", {\n\t        get: function () {\n\t            return this._logFormat;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"callBackLogger\", {\n\t        get: function () {\n\t            return this._callBackLogger;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return CategoryDefaultConfiguration;\n\t}());\n\texports.CategoryDefaultConfiguration = CategoryDefaultConfiguration;\n\t/**\n\t * The service (only available as singleton) for all category related stuff as\n\t * retrieving, registering a logger. You should normally NOT use this,\n\t * instead use CategoryLoggerFactory which is meant for end users.\n\t */\n\tvar CategoryServiceImpl = (function () {\n\t    function CategoryServiceImpl() {\n\t        this.defaultConfig = new CategoryDefaultConfiguration();\n\t        // All registered root categories\n\t        this.rootCategories = [];\n\t        // Key of map is path of category\n\t        this.categoryRuntimeSettings = new DataStructures_1.SimpleMap();\n\t        // Key is name of root logger.\n\t        this.rootLoggers = new DataStructures_1.SimpleMap();\n\t        // Allow extensions to talk with us.\n\t        ExtensionHelper_1.ExtensionHelper.register();\n\t    }\n\t    CategoryServiceImpl.getInstance = function () {\n\t        return CategoryServiceImpl.INSTANCE;\n\t    };\n\t    CategoryServiceImpl.prototype.getLogger = function (root) {\n\t        if (!this.rootCategoryExists(root)) {\n\t            throw new Error(\"Given category \" + root.name + \" is not registered as a root category. You must use the root category to retrieve a logger.\");\n\t        }\n\t        var pair = this.rootLoggers.get(root.name);\n\t        if (pair != null) {\n\t            return pair.y;\n\t        }\n\t        var logger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this.createRootLogger(root));\n\t        this.rootLoggers.put(root.name, new DataStructures_1.TuplePair(root, logger));\n\t        return logger;\n\t    };\n\t    /**\n\t     * Clears everything, including a default configuration you may have set.\n\t     * After this you need to re-register your categories etc.\n\t     */\n\t    CategoryServiceImpl.prototype.clear = function () {\n\t        this.rootCategories = [];\n\t        this.categoryRuntimeSettings.clear();\n\t        this.rootLoggers.clear();\n\t        this.setDefaultConfiguration(new CategoryDefaultConfiguration());\n\t    };\n\t    CategoryServiceImpl.prototype.getCategorySettings = function (category) {\n\t        return this.categoryRuntimeSettings.get(category.getCategoryPath());\n\t    };\n\t    /**\n\t     * Set the default configuration. New root loggers created get this\n\t     * applied. If you want to reset all current loggers to have this\n\t     * applied as well, pass in reset=true (the default is false). All\n\t     * categories will be reset then as well.\n\t     * @param config New config\n\t     * @param reset Defaults to false. Set to true to reset all loggers and current runtimesettings.\n\t     */\n\t    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {\n\t        var _this = this;\n\t        if (reset === void 0) { reset = false; }\n\t        this.defaultConfig = config;\n\t        if (reset) {\n\t            // Reset all runtimesettings (this will reset it for roots & children all at once).\n\t            var newRuntimeSettings_1 = new DataStructures_1.SimpleMap();\n\t            this.categoryRuntimeSettings.keys().forEach(function (key) {\n\t                var setting = _this.categoryRuntimeSettings.get(key);\n\t                if (setting != null) {\n\t                    var settings = new CategoryRuntimeSettings(setting.category, _this.defaultConfig.logLevel, _this.defaultConfig.loggerType, _this.defaultConfig.logFormat, _this.defaultConfig.callBackLogger);\n\t                    newRuntimeSettings_1.put(key, settings);\n\t                }\n\t                else {\n\t                    throw new Error(\"No setting associated with key=\" + key);\n\t                }\n\t            });\n\t            this.categoryRuntimeSettings.clear();\n\t            this.categoryRuntimeSettings = newRuntimeSettings_1;\n\t            // Now initialize a new logger and put it on the delegate. Loggers we give out\n\t            // are guaranteed to be wrapped inside the delegate logger.\n\t            this.rootLoggers.values().forEach(function (pair) {\n\t                // Set the new logger type\n\t                pair.y.delegate = _this.createRootLogger(pair.x);\n\t            });\n\t        }\n\t    };\n\t    /**\n\t     * Set new configuration settings for a category (and possibly its child categories)\n\t     * @param config Config\n\t     * @param category Category\n\t     * @param applyChildren True to apply to child categories, defaults to false.\n\t     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.\n\t     */\n\t    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {\n\t        var _this = this;\n\t        if (applyChildren === void 0) { applyChildren = false; }\n\t        if (resetRootLogger === void 0) { resetRootLogger = false; }\n\t        var categorySettings = this.getCategorySettings(category);\n\t        if (categorySettings === null) {\n\t            throw new Error(\"Given category is not registered: \" + category.name);\n\t        }\n\t        categorySettings.logLevel = config.logLevel;\n\t        categorySettings.loggerType = config.loggerType;\n\t        categorySettings.logFormat = config.logFormat;\n\t        categorySettings.callBackLogger = config.callBackLogger;\n\t        // Apply the settings to children recursive if requested\n\t        if (applyChildren) {\n\t            category.children.forEach(function (child) {\n\t                _this.setConfigurationCategory(config, child, applyChildren, resetRootLogger);\n\t            });\n\t        }\n\t        if (resetRootLogger && this.rootCategoryExists(category)) {\n\t            var tupleLogger = this.rootLoggers.get(category.name);\n\t            if (tupleLogger !== null) {\n\t                tupleLogger.y.delegate = this.createRootLogger(tupleLogger.x);\n\t            }\n\t        }\n\t    };\n\t    CategoryServiceImpl.prototype.registerCategory = function (category) {\n\t        if (category == null || category === undefined) {\n\t            throw new Error(\"Category CANNOT be null\");\n\t        }\n\t        var parent = category.parent;\n\t        if (parent == null) {\n\t            // Register the root category\n\t            for (var _i = 0, _a = this.rootCategories; _i < _a.length; _i++) {\n\t                var rootCategory = _a[_i];\n\t                if (rootCategory.name === category.name) {\n\t                    throw new Error(\"Cannot add this rootCategory with name: \" + category.name + \", another root category is already registered with that name.\");\n\t                }\n\t            }\n\t            this.rootCategories.push(category);\n\t        }\n\t        this.initializeRuntimeSettingsForCategory(category);\n\t    };\n\t    /**\n\t     * Used to enable integration with chrome extension. Do not use manually, the\n\t     * extension and the logger framework deal with this.\n\t     */\n\t    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {\n\t        var _this = this;\n\t        this.rootLoggers.values().forEach(function (pair) {\n\t            // Set the new logger type if needed.\n\t            var delegateLogger = pair.y;\n\t            if (!(delegateLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {\n\t                /* tslint:disable:no-console */\n\t                console.log(\"Reconfiguring root logger for root category: \" + pair.x.name);\n\t                /* tslint:enable:no-console */\n\t                pair.y.delegate = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(pair.x, _this);\n\t            }\n\t        });\n\t    };\n\t    /**\n\t     * Return all root categories currently registered.\n\t     */\n\t    CategoryServiceImpl.prototype.getRootCategories = function () {\n\t        return this.rootCategories.slice(0);\n\t    };\n\t    /**\n\t     * Return Category by id\n\t     * @param id The id of the category to find\n\t     * @returns {Category} or null if not found\n\t     */\n\t    CategoryServiceImpl.prototype.getCategoryById = function (id) {\n\t        var result = this.categoryRuntimeSettings.values().filter(function (cat) { return cat.category.id === id; })\n\t            .map(function (cat) { return cat.category; });\n\t        if (result.length === 1) {\n\t            return result[0];\n\t        }\n\t        return null;\n\t    };\n\t    CategoryServiceImpl.prototype.initializeRuntimeSettingsForCategory = function (category) {\n\t        var settings = this.categoryRuntimeSettings.get(category.getCategoryPath());\n\t        if (settings != null) {\n\t            throw new Error(\"Category with path: \" + category.getCategoryPath() + \" is already registered?\");\n\t        }\n\t        // Passing the callback is not really needed for child categories, but don't really care.\n\t        settings = new CategoryRuntimeSettings(category, this.defaultConfig.logLevel, this.defaultConfig.loggerType, this.defaultConfig.logFormat, this.defaultConfig.callBackLogger);\n\t        this.categoryRuntimeSettings.put(category.getCategoryPath(), settings);\n\t    };\n\t    CategoryServiceImpl.prototype.rootCategoryExists = function (rootCategory) {\n\t        if (rootCategory == null || rootCategory === undefined) {\n\t            throw new Error(\"Root category CANNOT be null\");\n\t        }\n\t        var parent = rootCategory.parent;\n\t        if (parent != null) {\n\t            throw new Error(\"Parent must be null for a root category\");\n\t        }\n\t        return this.rootCategories.indexOf(rootCategory) !== -1;\n\t    };\n\t    CategoryServiceImpl.prototype.createRootLogger = function (category) {\n\t        // Default is always a console logger\n\t        switch (this.defaultConfig.loggerType) {\n\t            case LoggerOptions_1.LoggerType.Console:\n\t                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);\n\t            case LoggerOptions_1.LoggerType.MessageBuffer:\n\t                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);\n\t            case LoggerOptions_1.LoggerType.Custom:\n\t                if (this.defaultConfig.callBackLogger == null) {\n\t                    throw new Error(\"Cannot create custom logger, custom callback is null\");\n\t                }\n\t                else {\n\t                    return this.defaultConfig.callBackLogger(category, this);\n\t                }\n\t            default:\n\t                throw new Error(\"Cannot create a Logger for LoggerType: \" + this.defaultConfig.loggerType);\n\t        }\n\t    };\n\t    return CategoryServiceImpl;\n\t}());\n\texports.CategoryServiceImpl = CategoryServiceImpl;\n\t// Singleton category service, used by CategoryServiceFactory as well as Categories.\n\tCategoryServiceImpl.INSTANCE = new CategoryServiceImpl();\n\t/**\n\t * Categorized service for logging, where logging is bound to categories which\n\t * can log horizontally through specific application logic (services, group(s) of components etc).\n\t * For the standard way of logging like most frameworks do these days, use LFService instead.\n\t * If you want fine grained control to divide sections of your application in\n\t * logical units to enable/disable logging for, this is the service you want to use instead.\n\t * Also for this type a browser plugin will be available.\n\t */\n\tvar CategoryServiceFactory = (function () {\n\t    function CategoryServiceFactory() {\n\t        // Private constructor.\n\t    }\n\t    /**\n\t     * Return a CategoryLogger for given ROOT category (thus has no parent).\n\t     * You can only retrieve loggers for their root, when logging\n\t     * you specify to log for what (child)categories.\n\t     * @param root Category root (has no parent)\n\t     * @returns {CategoryLogger}\n\t     */\n\t    CategoryServiceFactory.getLogger = function (root) {\n\t        return CategoryServiceImpl.getInstance().getLogger(root);\n\t    };\n\t    /**\n\t     * Clears everything, any registered (root)categories and loggers\n\t     * are discarded. Resets to default configuration.\n\t     */\n\t    CategoryServiceFactory.clear = function () {\n\t        return CategoryServiceImpl.getInstance().clear();\n\t    };\n\t    /**\n\t     * Set the default configuration. New root loggers created get this\n\t     * applied. If you want to reset all current loggers to have this\n\t     * applied as well, pass in reset=true (the default is false). All\n\t     * categories runtimesettings will be reset then as well.\n\t     * @param config The new default configuration\n\t     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these.\n\t     */\n\t    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {\n\t        if (reset === void 0) { reset = false; }\n\t        CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);\n\t    };\n\t    /**\n\t     * Set new configuration settings for a category (and possibly its child categories)\n\t     * @param config Config\n\t     * @param category Category\n\t     * @param applyChildren True to apply to child categories, defaults to false.\n\t     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.\n\t     */\n\t    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {\n\t        if (applyChildren === void 0) { applyChildren = false; }\n\t        if (resetRootLogger === void 0) { resetRootLogger = false; }\n\t        CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren, resetRootLogger);\n\t    };\n\t    /**\n\t     * Return RuntimeSettings to retrieve information about\n\t     * RuntimeSettings for categories.\n\t     * @returns {RuntimeSettings}\n\t     */\n\t    CategoryServiceFactory.getRuntimeSettings = function () {\n\t        return CategoryServiceImpl.getInstance();\n\t    };\n\t    return CategoryServiceFactory;\n\t}());\n\texports.CategoryServiceFactory = CategoryServiceFactory;\n\t//# sourceMappingURL=CategoryService.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AbstractCategoryLogger_1 = __webpack_require__(1);\n\tvar ExtensionHelper_1 = __webpack_require__(27);\n\t/**\n\t * This class should not be used directly, it is used for communication with the extension only.\n\t */\n\tvar CategoryExtensionLoggerImpl = (function (_super) {\n\t    __extends(CategoryExtensionLoggerImpl, _super);\n\t    function CategoryExtensionLoggerImpl(rootCategory, runtimeSettings) {\n\t        return _super.call(this, rootCategory, runtimeSettings) || this;\n\t    }\n\t    CategoryExtensionLoggerImpl.prototype.doLog = function (msg) {\n\t        if (typeof window !== \"undefined\") {\n\t            ExtensionHelper_1.ExtensionHelper.sendCategoryLogMessage(msg);\n\t        }\n\t        else {\n\t            /* tslint:disable:no-console */\n\t            console.log(\"window is not available, you must be running in a browser for this. Dropped message.\");\n\t        }\n\t    };\n\t    return CategoryExtensionLoggerImpl;\n\t}(AbstractCategoryLogger_1.AbstractCategoryLogger));\n\texports.CategoryExtensionLoggerImpl = CategoryExtensionLoggerImpl;\n\t//# sourceMappingURL=CategoryExtensionLoggerImpl.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar CategoryService_1 = __webpack_require__(25);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\tvar MessageUtils_1 = __webpack_require__(4);\n\tvar ExtensionHelper = (function () {\n\t    function ExtensionHelper() {\n\t        // Private constructor\n\t    }\n\t    /**\n\t     * Enables the window event listener to listen to messages (from extensions).\n\t     * Can be registered/enabled only once.\n\t     */\n\t    ExtensionHelper.register = function () {\n\t        if (!ExtensionHelper.registered) {\n\t            ExtensionHelper.registered = true;\n\t        }\n\t    };\n\t    /**\n\t     *  Extension framework will call this to enable the integration between two,\n\t     *  after this call the framework will respond with postMessage() messages.\n\t     */\n\t    ExtensionHelper.enableExtensionIntegration = function () {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        var instance = CategoryService_1.CategoryServiceImpl.getInstance();\n\t        instance.enableExtensionIntegration();\n\t        // Send over all categories\n\t        ExtensionHelper.sendRootCategoriesToExtension();\n\t        // Send over the current runtime levels\n\t        var cats = ExtensionHelper.getAllCategories();\n\t        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(cats);\n\t    };\n\t    ExtensionHelper.processMessageFromExtension = function (msg) {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        /* tslint:disable:no-console */\n\t        if (msg.from === \"tsl-extension\") {\n\t            var data = msg.data;\n\t            switch (data.type) {\n\t                case \"request-change-loglevel\":\n\t                    var valueRequest = data.value;\n\t                    var catsApplied = ExtensionHelper.applyLogLevel(valueRequest.categoryId, valueRequest.logLevel, valueRequest.recursive);\n\t                    if (catsApplied.length > 0) {\n\t                        // Send changes back\n\t                        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(catsApplied);\n\t                    }\n\t                    break;\n\t                default:\n\t                    console.log(\"Unknown command to process message from extension, command was: \" + data.type);\n\t                    break;\n\t            }\n\t        }\n\t        else {\n\t            console.log(\"Dropping message (not from tsl-extension): \" + msg.from);\n\t        }\n\t        /* tslint:enable:no-console */\n\t    };\n\t    ExtensionHelper.sendCategoryLogMessage = function (msg) {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        var categoryIds = msg.getCategories().map(function (cat) {\n\t            return cat.id;\n\t        });\n\t        var content = {\n\t            type: \"log-message\",\n\t            value: {\n\t                categories: categoryIds,\n\t                errorAsStack: msg.getErrorAsStack(),\n\t                formattedMessage: MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, false),\n\t                logLevel: LoggerOptions_1.LogLevel[msg.getLevel()].toString(),\n\t                message: msg.getMessage(),\n\t                resolvedErrorMessage: msg.isResolvedErrorMessage()\n\t            }\n\t        };\n\t        var message = {\n\t            data: content,\n\t            from: \"tsl-logging\",\n\t        };\n\t        ExtensionHelper.sendMessage(message);\n\t    };\n\t    ExtensionHelper.sendCategoriesRuntimeUpdateMessage = function (categories) {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        var service = CategoryService_1.CategoryServiceImpl.getInstance();\n\t        var catLevels = { categories: [{}] };\n\t        categories.forEach(function (cat) {\n\t            var catSettings = service.getCategorySettings(cat);\n\t            if (catSettings != null) {\n\t                catLevels.categories.push({ id: cat.id, logLevel: LoggerOptions_1.LogLevel[catSettings.logLevel].toString() });\n\t            }\n\t        });\n\t        var content = {\n\t            type: \"categories-rt-update\",\n\t            value: catLevels,\n\t        };\n\t        var message = {\n\t            data: content,\n\t            from: \"tsl-logging\"\n\t        };\n\t        ExtensionHelper.sendMessage(message);\n\t    };\n\t    ExtensionHelper.sendRootCategoriesToExtension = function () {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        var categories = CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().map(function (cat) {\n\t            return ExtensionHelper.getCategoryAsJSON(cat);\n\t        });\n\t        var content = {\n\t            type: \"root-categories-tree\",\n\t            value: categories\n\t        };\n\t        var message = {\n\t            data: content,\n\t            from: \"tsl-logging\"\n\t        };\n\t        ExtensionHelper.sendMessage(message);\n\t    };\n\t    /**\n\t     * If extension integration is enabled, will send the root categories over to the extension.\n\t     * Otherwise does nothing.\n\t     */\n\t    ExtensionHelper.getCategoryAsJSON = function (cat) {\n\t        var childCategories = cat.children.map(function (child) {\n\t            return ExtensionHelper.getCategoryAsJSON(child);\n\t        });\n\t        return {\n\t            children: childCategories,\n\t            id: cat.id,\n\t            logLevel: LoggerOptions_1.LogLevel[cat.logLevel].toString(),\n\t            name: cat.name,\n\t            parentId: (cat.parent != null ? cat.parent.id : null),\n\t        };\n\t    };\n\t    ExtensionHelper.applyLogLevel = function (categoryId, logLevel, recursive) {\n\t        var cats = [];\n\t        var category = CategoryService_1.CategoryServiceImpl.getInstance().getCategoryById(categoryId);\n\t        if (category != null) {\n\t            ExtensionHelper._applyLogLevelRecursive(category, LoggerOptions_1.LogLevel.fromString(logLevel), recursive, cats);\n\t        }\n\t        else {\n\t            /* tslint:disable:no-console */\n\t            console.log(\"Could not change log level, failed to find category with id: \" + categoryId);\n\t        }\n\t        return cats;\n\t    };\n\t    ExtensionHelper._applyLogLevelRecursive = function (category, logLevel, recursive, cats) {\n\t        var categorySettings = CategoryService_1.CategoryServiceImpl.getInstance().getCategorySettings(category);\n\t        if (categorySettings != null) {\n\t            categorySettings.logLevel = logLevel;\n\t            cats.push(category);\n\t            if (recursive) {\n\t                category.children.forEach(function (child) {\n\t                    ExtensionHelper._applyLogLevelRecursive(child, logLevel, recursive, cats);\n\t                });\n\t            }\n\t        }\n\t    };\n\t    ExtensionHelper.getAllCategories = function () {\n\t        var cats = [];\n\t        var addCats = function (cat, allCats) {\n\t            allCats.push(cat);\n\t            cat.children.forEach(function (catChild) {\n\t                addCats(catChild, allCats);\n\t            });\n\t        };\n\t        CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().forEach(function (cat) {\n\t            addCats(cat, cats);\n\t        });\n\t        return cats;\n\t    };\n\t    ExtensionHelper.sendMessage = function (msg) {\n\t        if (!ExtensionHelper.registered) {\n\t            return;\n\t        }\n\t        if (typeof window !== \"undefined\") {\n\t            /* tslint:disable:no-console */\n\t            console.log(\"Sending message to extension, message type: \" + msg.data.type);\n\t            /* tslint:enable:no-console */\n\t            window.postMessage(msg, \"*\");\n\t        }\n\t    };\n\t    return ExtensionHelper;\n\t}());\n\texports.ExtensionHelper = ExtensionHelper;\n\tExtensionHelper.registered = false;\n\t//# sourceMappingURL=ExtensionHelper.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar AbstractCategoryLogger_1 = __webpack_require__(1);\n\t/**\n\t * Logger which buffers all messages, use with care due to possible high memory footprint.\n\t * Can be convenient in some cases. Call toString() for full output, or cast to this class\n\t * and call getMessages() to do something with it yourself.\n\t */\n\tvar CategoryMessageBufferLoggerImpl = (function (_super) {\n\t    __extends(CategoryMessageBufferLoggerImpl, _super);\n\t    function CategoryMessageBufferLoggerImpl() {\n\t        var _this = _super.apply(this, arguments) || this;\n\t        _this.messages = [];\n\t        return _this;\n\t    }\n\t    CategoryMessageBufferLoggerImpl.prototype.getMessages = function () {\n\t        return this.messages;\n\t    };\n\t    CategoryMessageBufferLoggerImpl.prototype.toString = function () {\n\t        return this.messages.map(function (msg) {\n\t            return msg;\n\t        }).join(\"\\n\");\n\t    };\n\t    CategoryMessageBufferLoggerImpl.prototype.doLog = function (msg) {\n\t        var fullMsg = this.createDefaultLogMessage(msg);\n\t        this.messages.push(fullMsg);\n\t    };\n\t    return CategoryMessageBufferLoggerImpl;\n\t}(AbstractCategoryLogger_1.AbstractCategoryLogger));\n\texports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferLoggerImpl;\n\t//# sourceMappingURL=CategoryMessageBufferImpl.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar ExtensionHelper_1 = __webpack_require__(27);\n\tvar LoggerFactoryImpl_1 = __webpack_require__(30);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\t/**\n\t * Defines a LogGroupRule, this allows you to either have everything configured the same way\n\t * or for example loggers that start with name model. It allows you to group loggers together\n\t * to have a certain loglevel and other settings. You can configure this when creating the\n\t * LoggerFactory (which accepts multiple LogGroupRules).\n\t */\n\tvar LogGroupRule = (function () {\n\t    /**\n\t     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n\t     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n\t     * @param regExp Regular expression, what matches for your logger names for this group\n\t     * @param level LogLevel\n\t     * @param logFormat LogFormat\n\t     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n\t     * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n\t     */\n\t    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n\t        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }\n\t        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n\t        if (callBackLogger === void 0) { callBackLogger = null; }\n\t        this._regExp = regExp;\n\t        this._level = level;\n\t        this._logFormat = logFormat;\n\t        this._loggerType = loggerType;\n\t        this._callBackLogger = callBackLogger;\n\t    }\n\t    Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n\t        get: function () {\n\t            return this._regExp;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"level\", {\n\t        get: function () {\n\t            return this._level;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n\t        get: function () {\n\t            return this._loggerType;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n\t        get: function () {\n\t            return this._logFormat;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n\t        get: function () {\n\t            return this._callBackLogger;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LogGroupRule;\n\t}());\n\texports.LogGroupRule = LogGroupRule;\n\t/**\n\t * Options object you can use to configure the LoggerFactory you create at LFService.\n\t */\n\tvar LoggerFactoryOptions = (function () {\n\t    function LoggerFactoryOptions() {\n\t        this._logGroupRules = [];\n\t        this._enabled = true;\n\t    }\n\t    /**\n\t     * Add LogGroupRule, see {LogGroupRule) for details\n\t     * @param rule Rule to add\n\t     * @returns {LoggerFactoryOptions} returns itself\n\t     */\n\t    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {\n\t        this._logGroupRules.push(rule);\n\t        return this;\n\t    };\n\t    /**\n\t     * Enable or disable logging completely for the LoggerFactory.\n\t     * @param enabled True for enabled (default)\n\t     * @returns {LoggerFactoryOptions} returns itself\n\t     */\n\t    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {\n\t        this._enabled = enabled;\n\t        return this;\n\t    };\n\t    Object.defineProperty(LoggerFactoryOptions.prototype, \"logGroupRules\", {\n\t        get: function () {\n\t            return this._logGroupRules;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(LoggerFactoryOptions.prototype, \"enabled\", {\n\t        get: function () {\n\t            return this._enabled;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return LoggerFactoryOptions;\n\t}());\n\texports.LoggerFactoryOptions = LoggerFactoryOptions;\n\t/**\n\t * Create and configure your LoggerFactory from here.\n\t */\n\tvar LFService = (function () {\n\t    function LFService() {\n\t    }\n\t    /**\n\t     * Create a new LoggerFactory with given options (if any). If no options\n\t     * are specified, the LoggerFactory, will accept any named logger and will\n\t     * log on info level by default for, to the console.\n\t     * @param options Options, optional.\n\t     * @returns {LoggerFactory}\n\t     */\n\t    LFService.createLoggerFactory = function (options) {\n\t        var factory;\n\t        if (options !== undefined) {\n\t            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(options);\n\t        }\n\t        else {\n\t            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(this.createDefaultOptions());\n\t        }\n\t        LFService._loggerFactories.push(factory);\n\t        // Allow extensions to talk with us.\n\t        ExtensionHelper_1.ExtensionHelper.register();\n\t        return factory;\n\t    };\n\t    /**\n\t     * Closes all Loggers for LoggerFactories that were created.\n\t     * After this call, all previously fetched Loggers (from their\n\t     * factories) are unusable. The factories remain as they were.\n\t     */\n\t    LFService.closeLoggers = function () {\n\t        for (var _i = 0, _a = this._loggerFactories; _i < _a.length; _i++) {\n\t            var loggerFactory = _a[_i];\n\t            loggerFactory.closeLoggers();\n\t        }\n\t        this._loggerFactories = [];\n\t    };\n\t    LFService.createDefaultOptions = function () {\n\t        return new LoggerFactoryOptions().addLogGroupRule(new LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Info));\n\t    };\n\t    return LFService;\n\t}());\n\texports.LFService = LFService;\n\tLFService._loggerFactories = [];\n\t//# sourceMappingURL=LoggerFactoryService.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar LoggerImpl_1 = __webpack_require__(31);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\tvar LoggerFactoryImpl = (function () {\n\t    function LoggerFactoryImpl(options) {\n\t        this.loggers = {};\n\t        this.configure(options);\n\t    }\n\t    LoggerFactoryImpl.prototype.configure = function (options) {\n\t        this.options = options;\n\t        // Close any current open loggers.\n\t        this.closeLoggers();\n\t    };\n\t    LoggerFactoryImpl.prototype.getLogger = function (named) {\n\t        if (!this.options.enabled) {\n\t            throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n\t        }\n\t        var logger = this.loggers[named];\n\t        if (logger !== undefined) {\n\t            return logger;\n\t        }\n\t        // Initialize logger with appropriate level\n\t        logger = this.loadLogger(named);\n\t        this.loggers[named] = logger;\n\t        return logger;\n\t    };\n\t    LoggerFactoryImpl.prototype.isEnabled = function () {\n\t        return this.options.enabled;\n\t    };\n\t    LoggerFactoryImpl.prototype.closeLoggers = function () {\n\t        for (var key in this.loggers) {\n\t            if (this.loggers.hasOwnProperty(key)) {\n\t                this.loggers[key].close();\n\t            }\n\t        }\n\t        this.loggers = {};\n\t    };\n\t    LoggerFactoryImpl.prototype.loadLogger = function (named) {\n\t        var logGroupRules = this.options.logGroupRules;\n\t        for (var _i = 0, logGroupRules_1 = logGroupRules; _i < logGroupRules_1.length; _i++) {\n\t            var logGroupRule = logGroupRules_1[_i];\n\t            if (logGroupRule.regExp.test(named)) {\n\t                switch (logGroupRule.loggerType) {\n\t                    case LoggerOptions_1.LoggerType.Console:\n\t                        return new LoggerImpl_1.ConsoleLoggerImpl(named, logGroupRule);\n\t                    case LoggerOptions_1.LoggerType.MessageBuffer:\n\t                        return new LoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRule);\n\t                    case LoggerOptions_1.LoggerType.Custom:\n\t                        if (logGroupRule.callBackLogger != null) {\n\t                            return logGroupRule.callBackLogger(named, logGroupRule);\n\t                        }\n\t                        else {\n\t                            throw new Error(\"Cannot create a custom logger, custom callback is null\");\n\t                        }\n\t                    default:\n\t                        throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n\t                }\n\t            }\n\t        }\n\t        throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n\t    };\n\t    return LoggerFactoryImpl;\n\t}());\n\texports.LoggerFactoryImpl = LoggerFactoryImpl;\n\t//# sourceMappingURL=LoggerFactoryImpl.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar DataStructures_1 = __webpack_require__(2);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\tvar MessageUtils_1 = __webpack_require__(4);\n\tvar Message = (function () {\n\t    function Message(ready, message) {\n\t        if (message === void 0) { message = null; }\n\t        this._ready = ready;\n\t        this._message = message;\n\t    }\n\t    Object.defineProperty(Message.prototype, \"ready\", {\n\t        get: function () {\n\t            return this._ready;\n\t        },\n\t        set: function (value) {\n\t            this._ready = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Message.prototype, \"message\", {\n\t        get: function () {\n\t            return this._message;\n\t        },\n\t        set: function (value) {\n\t            this._message = value;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    return Message;\n\t}());\n\t/**\n\t * Abstract base logger, extend to easily implement a custom logger that\n\t * logs wherever you want. You only need to implement doLog(msg: string) and\n\t * log that somewhere (it will contain format and everything else).\n\t */\n\tvar AbstractLogger = (function () {\n\t    function AbstractLogger(name, rule) {\n\t        this.open = true;\n\t        this._allMessages = new DataStructures_1.LinkedList();\n\t        this.name = name;\n\t        this.rule = rule;\n\t        this.level = rule.level;\n\t    }\n\t    AbstractLogger.prototype.trace = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Trace, msg, error);\n\t    };\n\t    AbstractLogger.prototype.debug = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Debug, msg, error);\n\t    };\n\t    AbstractLogger.prototype.info = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Info, msg, error);\n\t    };\n\t    AbstractLogger.prototype.warn = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Warn, msg, error);\n\t    };\n\t    AbstractLogger.prototype.error = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Error, msg, error);\n\t    };\n\t    AbstractLogger.prototype.fatal = function (msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        this._log(LoggerOptions_1.LogLevel.Fatal, msg, error);\n\t    };\n\t    AbstractLogger.prototype.tracec = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Trace, msg, error);\n\t    };\n\t    AbstractLogger.prototype.debugc = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Debug, msg, error);\n\t    };\n\t    AbstractLogger.prototype.infoc = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Info, msg, error);\n\t    };\n\t    AbstractLogger.prototype.warnc = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Warn, msg, error);\n\t    };\n\t    AbstractLogger.prototype.errorc = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Error, msg, error);\n\t    };\n\t    AbstractLogger.prototype.fatalc = function (msg, error) {\n\t        this._logc(LoggerOptions_1.LogLevel.Fatal, msg, error);\n\t    };\n\t    AbstractLogger.prototype.isTraceEnabled = function () {\n\t        return this.level === LoggerOptions_1.LogLevel.Trace;\n\t    };\n\t    AbstractLogger.prototype.isDebugEnabled = function () {\n\t        return this.level <= LoggerOptions_1.LogLevel.Debug;\n\t    };\n\t    AbstractLogger.prototype.isInfoEnabled = function () {\n\t        return this.level <= LoggerOptions_1.LogLevel.Info;\n\t    };\n\t    AbstractLogger.prototype.isWarnEnabled = function () {\n\t        return this.level <= LoggerOptions_1.LogLevel.Warn;\n\t    };\n\t    AbstractLogger.prototype.isErrorEnabled = function () {\n\t        return this.level <= LoggerOptions_1.LogLevel.Error;\n\t    };\n\t    AbstractLogger.prototype.isFatalEnabled = function () {\n\t        return this.level <= LoggerOptions_1.LogLevel.Fatal;\n\t    };\n\t    AbstractLogger.prototype.getLogLevel = function () {\n\t        return this.level;\n\t    };\n\t    AbstractLogger.prototype.isOpen = function () {\n\t        return this.open;\n\t    };\n\t    AbstractLogger.prototype.close = function () {\n\t        this.open = false;\n\t        this._allMessages.clear();\n\t    };\n\t    AbstractLogger.prototype._log = function (level, msg, error) {\n\t        if (error === void 0) { error = null; }\n\t        if (this.open && this.level <= level) {\n\t            this._allMessages.addTail(this.createMessage(level, msg, new Date(), error));\n\t            this.processMessages();\n\t        }\n\t    };\n\t    AbstractLogger.prototype._logc = function (level, msg, error) {\n\t        if (this.open && this.level <= level) {\n\t            this._allMessages.addTail(this.createMessage(level, msg(), new Date(), error !== undefined && error != null ? error() : null));\n\t            this.processMessages();\n\t        }\n\t    };\n\t    AbstractLogger.prototype.createMessage = function (level, msg, date, error) {\n\t        var _this = this;\n\t        if (error === void 0) { error = null; }\n\t        var result = \"\";\n\t        if (this.rule.logFormat.showTimeStamp) {\n\t            result += MessageUtils_1.MessageFormatUtils.renderDate(date, this.rule.logFormat.dateFormat) + \" \";\n\t        }\n\t        result += LoggerOptions_1.LogLevel[level].toUpperCase() + \" \";\n\t        if (this.rule.logFormat.showLoggerName) {\n\t            result += \"[\" + this.name + \"]\";\n\t        }\n\t        result += \" \" + msg;\n\t        if (error != null) {\n\t            var message_1 = new Message(false);\n\t            MessageUtils_1.MessageFormatUtils.renderError(error).then(function (stackResult) {\n\t                result += \"\\n\" + stackResult;\n\t                message_1.message = result;\n\t                message_1.ready = true;\n\t                _this.processMessages();\n\t            });\n\t            return message_1;\n\t        }\n\t        return new Message(true, result);\n\t    };\n\t    AbstractLogger.prototype.processMessages = function () {\n\t        // Basically we wait until errors are resolved (those messages\n\t        // may not be ready).\n\t        var msgs = this._allMessages;\n\t        if (msgs.getSize() > 0) {\n\t            do {\n\t                var msg = msgs.getHead();\n\t                if (msg != null) {\n\t                    if (!msg.ready) {\n\t                        break;\n\t                    }\n\t                    msgs.removeHead();\n\t                    // This can never be null normally, but strict null checking ...\n\t                    if (msg.message != null) {\n\t                        this.doLog(msg.message);\n\t                    }\n\t                }\n\t            } while (msgs.getSize() > 0);\n\t        }\n\t    };\n\t    return AbstractLogger;\n\t}());\n\texports.AbstractLogger = AbstractLogger;\n\t/**\n\t * Simple logger, that logs to the console. If the console is unavailable will throw exception.\n\t */\n\tvar ConsoleLoggerImpl = (function (_super) {\n\t    __extends(ConsoleLoggerImpl, _super);\n\t    function ConsoleLoggerImpl(name, rule) {\n\t        return _super.call(this, name, rule) || this;\n\t    }\n\t    ConsoleLoggerImpl.prototype.doLog = function (msg, logLevel) {\n\t        if (console !== undefined) {\n\t            var logged = false;\n\t            /* tslint:disable:no-console */\n\t            switch (logLevel) {\n\t                case LoggerOptions_1.LogLevel.Trace:\n\t                    if (console.trace) {\n\t                        console.trace(msg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Debug:\n\t                    if (console.debug) {\n\t                        console.debug(msg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Info:\n\t                    if (console.info) {\n\t                        console.info(msg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Warn:\n\t                    if (console.warn) {\n\t                        console.warn(msg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                case LoggerOptions_1.LogLevel.Error:\n\t                case LoggerOptions_1.LogLevel.Fatal:\n\t                    if (console.error) {\n\t                        console.error(msg);\n\t                        logged = true;\n\t                    }\n\t                    break;\n\t                default:\n\t                    throw new Error(\"Log level not supported: \" + logLevel);\n\t            }\n\t        }\n\t        else {\n\t            throw new Error(\"Console is not defined, cannot log msg: \" + msg);\n\t        }\n\t    };\n\t    return ConsoleLoggerImpl;\n\t}(AbstractLogger));\n\texports.ConsoleLoggerImpl = ConsoleLoggerImpl;\n\t/**\n\t * Logger which buffers all messages, use with care due to possible high memory footprint.\n\t * Can be convenient in some cases. Call toString() for full output, or cast to this class\n\t * and call getMessages() to do something with it yourself.\n\t */\n\tvar MessageBufferLoggerImpl = (function (_super) {\n\t    __extends(MessageBufferLoggerImpl, _super);\n\t    function MessageBufferLoggerImpl(name, rule) {\n\t        var _this = _super.call(this, name, rule) || this;\n\t        _this.messages = [];\n\t        return _this;\n\t    }\n\t    MessageBufferLoggerImpl.prototype.close = function () {\n\t        this.messages = [];\n\t        _super.prototype.close.call(this);\n\t    };\n\t    MessageBufferLoggerImpl.prototype.getMessages = function () {\n\t        return this.messages;\n\t    };\n\t    MessageBufferLoggerImpl.prototype.toString = function () {\n\t        return this.messages.map(function (msg) {\n\t            return msg;\n\t        }).join(\"\\n\");\n\t    };\n\t    MessageBufferLoggerImpl.prototype.doLog = function (msg, logLevel) {\n\t        this.messages.push(msg);\n\t    };\n\t    return MessageBufferLoggerImpl;\n\t}(AbstractLogger));\n\texports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;\n\t//# sourceMappingURL=LoggerImpl.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar DataStructures_1 = __webpack_require__(2);\n\tvar LoggerOptions_1 = __webpack_require__(3);\n\tvar JSONTypeImpl = (function () {\n\t    function JSONTypeImpl(value) {\n\t        this._value = value;\n\t    }\n\t    JSONTypeImpl.prototype.getValue = function () {\n\t        return this._value;\n\t    };\n\t    JSONTypeImpl.prototype.toString = function () {\n\t        var value = this.getValue();\n\t        if (value != null) {\n\t            return value.toString();\n\t        }\n\t        return \"null\";\n\t    };\n\t    return JSONTypeImpl;\n\t}());\n\tvar JSONBooleanType = (function (_super) {\n\t    __extends(JSONBooleanType, _super);\n\t    function JSONBooleanType(value) {\n\t        return _super.call(this, value) || this;\n\t    }\n\t    return JSONBooleanType;\n\t}(JSONTypeImpl));\n\tvar JSONNumberType = (function (_super) {\n\t    __extends(JSONNumberType, _super);\n\t    function JSONNumberType(value) {\n\t        return _super.call(this, value) || this;\n\t    }\n\t    return JSONNumberType;\n\t}(JSONTypeImpl));\n\tvar JSONStringType = (function (_super) {\n\t    __extends(JSONStringType, _super);\n\t    function JSONStringType(value) {\n\t        return _super.call(this, value) || this;\n\t    }\n\t    JSONStringType.prototype.toString = function () {\n\t        var value = this.getValue();\n\t        if (value != null) {\n\t            return JSON.stringify(value.toString());\n\t        }\n\t        return \"null\";\n\t    };\n\t    return JSONStringType;\n\t}(JSONTypeImpl));\n\tvar JSONObjectType = (function (_super) {\n\t    __extends(JSONObjectType, _super);\n\t    function JSONObjectType(value) {\n\t        return _super.call(this, value) || this;\n\t    }\n\t    return JSONObjectType;\n\t}(JSONTypeImpl));\n\tvar JSONArrayType = (function (_super) {\n\t    __extends(JSONArrayType, _super);\n\t    function JSONArrayType(value) {\n\t        return _super.call(this, value) || this;\n\t    }\n\t    JSONArrayType.prototype.toString = function () {\n\t        var value = this.getValue();\n\t        if (value != null) {\n\t            return value.toString();\n\t        }\n\t        return \"null\";\n\t    };\n\t    return JSONArrayType;\n\t}(JSONTypeImpl));\n\tvar JSONNullType = (function (_super) {\n\t    __extends(JSONNullType, _super);\n\t    function JSONNullType() {\n\t        return _super.call(this, null) || this;\n\t    }\n\t    JSONNullType.prototype.toString = function () {\n\t        return \"null\";\n\t    };\n\t    return JSONNullType;\n\t}(JSONTypeImpl));\n\tvar JSONTypeConverter = (function () {\n\t    function JSONTypeConverter() {\n\t    }\n\t    JSONTypeConverter.toJSONType = function (value) {\n\t        if (value === null) {\n\t            return new JSONNullType();\n\t        }\n\t        if (typeof value === \"string\") {\n\t            return new JSONStringType(value);\n\t        }\n\t        if (typeof value === \"number\") {\n\t            return new JSONNumberType(value);\n\t        }\n\t        if (typeof value === \"boolean\") {\n\t            return new JSONBooleanType(value);\n\t        }\n\t        if (value instanceof JSONObject) {\n\t            return new JSONObjectType(value);\n\t        }\n\t        throw new Error(\"Type not supported for value: \" + value);\n\t    };\n\t    return JSONTypeConverter;\n\t}());\n\tvar JSONObject = (function () {\n\t    function JSONObject() {\n\t        this.values = new DataStructures_1.SimpleMap();\n\t    }\n\t    JSONObject.prototype.addBoolean = function (name, value) {\n\t        this.checkName(name);\n\t        JSONObject.checkValue(value);\n\t        this.values.put(name, new JSONBooleanType(value));\n\t        return this;\n\t    };\n\t    JSONObject.prototype.addNumber = function (name, value) {\n\t        this.checkName(name);\n\t        JSONObject.checkValue(value);\n\t        this.values.put(name, new JSONNumberType(value));\n\t        return this;\n\t    };\n\t    JSONObject.prototype.addString = function (name, value) {\n\t        this.checkName(name);\n\t        JSONObject.checkValue(value);\n\t        this.values.put(name, new JSONStringType(value));\n\t        return this;\n\t    };\n\t    JSONObject.prototype.addNull = function (name) {\n\t        this.checkName(name);\n\t        this.values.put(name, new JSONNullType());\n\t        return this;\n\t    };\n\t    JSONObject.prototype.addArray = function (name, array) {\n\t        this.checkName(name);\n\t        JSONObject.checkValue(array);\n\t        if (array == null) {\n\t            throw new Error(\"Cannot add array as null\");\n\t        }\n\t        this.values.put(name, new JSONArrayType(array));\n\t        return this;\n\t    };\n\t    JSONObject.prototype.addObject = function (name, object) {\n\t        this.checkName(name);\n\t        JSONObject.checkValue(object);\n\t        if (object == null) {\n\t            throw new Error(\"Cannot add object as null\");\n\t        }\n\t        this.values.put(name, new JSONObjectType(object));\n\t        return this;\n\t    };\n\t    JSONObject.prototype.toString = function (pretty) {\n\t        var _this = this;\n\t        if (pretty === void 0) { pretty = false; }\n\t        var comma = false;\n\t        var buffer = new DataStructures_1.StringBuilder();\n\t        buffer.append(\"{\");\n\t        this.values.keys().forEach(function (key) {\n\t            var value = _this.values.get(key);\n\t            if (value != null) {\n\t                if (comma) {\n\t                    buffer.append(\",\");\n\t                }\n\t                buffer.append('\"').append(key).append('\":').append(value.toString());\n\t                comma = true;\n\t            }\n\t        });\n\t        buffer.append(\"}\");\n\t        return buffer.toString();\n\t    };\n\t    JSONObject.prototype.checkName = function (name) {\n\t        if (name == null || name === undefined) {\n\t            throw new Error(\"Name is null or undefined\");\n\t        }\n\t        if (this.values.exists(name)) {\n\t            throw new Error(\"Name \" + name + \" is already present for this object\");\n\t        }\n\t    };\n\t    JSONObject.checkValue = function (value) {\n\t        if (value === undefined) {\n\t            throw new Error(\"Value is undefined\");\n\t        }\n\t    };\n\t    return JSONObject;\n\t}());\n\texports.JSONObject = JSONObject;\n\tvar JSONArray = (function () {\n\t    function JSONArray() {\n\t        this.objects = [];\n\t    }\n\t    JSONArray.prototype.add = function (object) {\n\t        if (object === undefined) {\n\t            throw new Error(\"Object is not allowed to be undefined\");\n\t        }\n\t        this.objects.push(JSONTypeConverter.toJSONType(object));\n\t        return this;\n\t    };\n\t    JSONArray.prototype.toString = function (pretty) {\n\t        if (pretty === void 0) { pretty = false; }\n\t        var buffer = new DataStructures_1.StringBuilder();\n\t        buffer.append(\"[\");\n\t        this.objects.forEach(function (value, index) {\n\t            if (index > 0) {\n\t                buffer.append(\",\");\n\t            }\n\t            buffer.append(value.toString());\n\t        });\n\t        buffer.append(\"]\");\n\t        return buffer.toString();\n\t    };\n\t    return JSONArray;\n\t}());\n\texports.JSONArray = JSONArray;\n\t/**\n\t * Utility class that helps us convert things to and from json (not for normal usage).\n\t */\n\tvar JSONHelper = (function () {\n\t    function JSONHelper() {\n\t    }\n\t    JSONHelper.categoryToJSON = function (cat, recursive) {\n\t        /*\n\t         {\n\t         \"categories\":\n\t         [\n\t         { id=1,\n\t         name: \"x\",\n\t         parent: null,\n\t         logLevel: \"Error\"\n\t         },\n\t         { id=2,\n\t         name: \"y\",\n\t         parent: 1,\n\t         logLevel: \"Error\"\n\t         }\n\t         ]\n\t         }\n\t         */\n\t        var arr = new JSONArray();\n\t        JSONHelper._categoryToJSON(cat, arr, recursive);\n\t        var object = new JSONObject();\n\t        object.addArray(\"categories\", arr);\n\t        return object;\n\t    };\n\t    JSONHelper._categoryToJSON = function (cat, arr, recursive) {\n\t        var object = new JSONObject();\n\t        object.addNumber(\"id\", cat.id);\n\t        object.addString(\"name\", cat.name);\n\t        object.addString(\"logLevel\", LoggerOptions_1.LogLevel[cat.logLevel].toString());\n\t        if (cat.parent != null) {\n\t            object.addNumber(\"parent\", cat.parent.id);\n\t        }\n\t        else {\n\t            object.addNull(\"parent\");\n\t        }\n\t        arr.add(object);\n\t        if (recursive) {\n\t            cat.children.forEach(function (child) {\n\t                JSONHelper._categoryToJSON(child, arr, recursive);\n\t            });\n\t        }\n\t    };\n\t    return JSONHelper;\n\t}());\n\texports.JSONHelper = JSONHelper;\n\t//# sourceMappingURL=JSONHelper.js.map\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// typescript-logging.bundle.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 25566c33c3497128f473","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar AbstractCategoryLogger_1 = require(\"./AbstractCategoryLogger\");\nexports.AbstractCategoryLogger = AbstractCategoryLogger_1.AbstractCategoryLogger;\nvar CategoryConsoleLoggerImpl_1 = require(\"./CategoryConsoleLoggerImpl\");\nexports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl;\nvar CategoryDelegateLoggerImpl_1 = require(\"./CategoryDelegateLoggerImpl\");\nexports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl;\nvar CategoryLogger_1 = require(\"./CategoryLogger\");\nexports.Category = CategoryLogger_1.Category;\nvar CategoryMessageBufferImpl_1 = require(\"./CategoryMessageBufferImpl\");\nexports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl;\nvar CategoryService_1 = require(\"./CategoryService\");\nexports.CategoryDefaultConfiguration = CategoryService_1.CategoryDefaultConfiguration;\nexports.CategoryRuntimeSettings = CategoryService_1.CategoryRuntimeSettings;\nexports.CategoryServiceFactory = CategoryService_1.CategoryServiceFactory;\nvar LoggerFactoryService_1 = require(\"./LoggerFactoryService\");\nexports.LoggerFactoryOptions = LoggerFactoryService_1.LoggerFactoryOptions;\nexports.LFService = LoggerFactoryService_1.LFService;\nexports.LogGroupRule = LoggerFactoryService_1.LogGroupRule;\nvar LoggerImpl_1 = require(\"./LoggerImpl\");\nexports.AbstractLogger = LoggerImpl_1.AbstractLogger;\nexports.ConsoleLoggerImpl = LoggerImpl_1.ConsoleLoggerImpl;\nexports.MessageBufferLoggerImpl = LoggerImpl_1.MessageBufferLoggerImpl;\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nexports.CategoryLogFormat = LoggerOptions_1.CategoryLogFormat;\nexports.DateFormat = LoggerOptions_1.DateFormat;\nexports.DateFormatEnum = LoggerOptions_1.DateFormatEnum;\nexports.LogFormat = LoggerOptions_1.LogFormat;\nexports.LoggerType = LoggerOptions_1.LoggerType;\nexports.LogLevel = LoggerOptions_1.LogLevel;\nvar MessageUtils_1 = require(\"./MessageUtils\");\nexports.MessageFormatUtils = MessageUtils_1.MessageFormatUtils;\nvar DataStructures_1 = require(\"./DataStructures\");\nexports.SimpleMap = DataStructures_1.SimpleMap;\nexports.LinkedList = DataStructures_1.LinkedList;\n__export(require(\"./JSONHelper\"));\nvar ExtensionHelper_1 = require(\"./ExtensionHelper\");\nexports.ExtensionHelper = ExtensionHelper_1.ExtensionHelper;\n//# sourceMappingURL=typescript-logging.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/typescript-logging.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nvar DataStructures_1 = require(\"./DataStructures\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nvar MessageUtils_1 = require(\"./MessageUtils\");\nvar CategoryLogMessageImpl = (function () {\n    function CategoryLogMessageImpl(message, error, categories, date, level, logFormat, ready) {\n        this._resolvedErrorMessage = false;\n        this.errorAsStack = null;\n        this.message = message;\n        this.error = error;\n        this.categories = categories;\n        this.date = date;\n        this.level = level;\n        this.logFormat = logFormat;\n        this.ready = ready;\n    }\n    CategoryLogMessageImpl.prototype.getMessage = function () {\n        return this.message;\n    };\n    CategoryLogMessageImpl.prototype.getErrorAsStack = function () {\n        return this.errorAsStack;\n    };\n    CategoryLogMessageImpl.prototype.setErrorAsStack = function (stack) {\n        this.errorAsStack = stack;\n    };\n    CategoryLogMessageImpl.prototype.getError = function () {\n        return this.error;\n    };\n    CategoryLogMessageImpl.prototype.getCategories = function () {\n        return this.categories;\n    };\n    CategoryLogMessageImpl.prototype.getDate = function () {\n        return this.date;\n    };\n    CategoryLogMessageImpl.prototype.getLevel = function () {\n        return this.level;\n    };\n    CategoryLogMessageImpl.prototype.getLogFormat = function () {\n        return this.logFormat;\n    };\n    CategoryLogMessageImpl.prototype.isReady = function () {\n        return this.ready;\n    };\n    CategoryLogMessageImpl.prototype.setReady = function (value) {\n        this.ready = value;\n    };\n    Object.defineProperty(CategoryLogMessageImpl.prototype, \"resolvedErrorMessage\", {\n        get: function () {\n            return this._resolvedErrorMessage;\n        },\n        set: function (value) {\n            this._resolvedErrorMessage = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CategoryLogMessageImpl.prototype.isResolvedErrorMessage = function () {\n        return this._resolvedErrorMessage;\n    };\n    return CategoryLogMessageImpl;\n}());\n/**\n * Abstract category logger, use as your base class for new type of loggers (it\n * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument\n * provides full access to anything related to the logging event.\n * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on\n * this class which will return you the formatted log message as string (e.g. the\n * default loggers all use this).\n */\nvar AbstractCategoryLogger = (function () {\n    function AbstractCategoryLogger(rootCategory, runtimeSettings) {\n        this.allMessages = new DataStructures_1.LinkedList();\n        this.rootCategory = rootCategory;\n        this.runtimeSettings = runtimeSettings;\n    }\n    AbstractCategoryLogger.prototype.trace = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, null, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.debug = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, null, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.info = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Info, msg, null, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.warn = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, null, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.error = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.fatal = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.resolved = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.log = function (level, msg, error) {\n        var categories = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            categories[_i - 3] = arguments[_i];\n        }\n        this._log.apply(this, [level, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.tracec = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, function () { return null; }, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.debugc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, function () { return null; }, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.infoc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Info, msg, function () { return null; }, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.warnc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, function () { return null; }, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.errorc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.fatalc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.resolvedc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        this._logc.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.logc = function (level, msg, error) {\n        var categories = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            categories[_i - 3] = arguments[_i];\n        }\n        this._logc.apply(this, [level, msg, error, false].concat(categories));\n    };\n    AbstractCategoryLogger.prototype.getRootCategory = function () {\n        return this.rootCategory;\n    };\n    AbstractCategoryLogger.prototype.createDefaultLogMessage = function (msg) {\n        return MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, true);\n    };\n    AbstractCategoryLogger.prototype._log = function (level, msg, error, resolved) {\n        if (error === void 0) { error = null; }\n        if (resolved === void 0) { resolved = false; }\n        var categories = [];\n        for (var _i = 4; _i < arguments.length; _i++) {\n            categories[_i - 4] = arguments[_i];\n        }\n        this._logInternal.apply(this, [level, function () { return msg; }, function () { return error; }, resolved].concat(categories));\n    };\n    AbstractCategoryLogger.prototype._logc = function (level, msg, error, resolved) {\n        if (resolved === void 0) { resolved = false; }\n        var categories = [];\n        for (var _i = 4; _i < arguments.length; _i++) {\n            categories[_i - 4] = arguments[_i];\n        }\n        this._logInternal.apply(this, [level, msg, error, resolved].concat(categories));\n    };\n    AbstractCategoryLogger.prototype._logInternal = function (level, msg, error, resolved) {\n        var _this = this;\n        var categories = [];\n        for (var _i = 4; _i < arguments.length; _i++) {\n            categories[_i - 4] = arguments[_i];\n        }\n        var logCateries;\n        // Log root category by default if none present\n        if (categories !== undefined && categories.length > 0) {\n            logCateries = categories;\n        }\n        else {\n            logCateries = [];\n            logCateries.push(this.rootCategory);\n        }\n        var _loop_1 = function (i) {\n            var category = logCateries[i];\n            if (category == null) {\n                throw new Error(\"Cannot have a null element within categories, at index=\" + i);\n            }\n            var settings = this_1.runtimeSettings.getCategorySettings(category);\n            if (settings == null) {\n                throw new Error(\"Category with path: \" + category.getCategoryPath() + \" is not registered with this logger, maybe \" +\n                    \"you registered it with a different root logger?\");\n            }\n            if (settings.logLevel <= level) {\n                var actualError = error != null ? error() : null;\n                if (actualError == null) {\n                    var logMessage = new CategoryLogMessageImpl(msg(), actualError, logCateries, new Date(), level, settings.logFormat, true);\n                    logMessage.resolvedErrorMessage = resolved;\n                    this_1.allMessages.addTail(logMessage);\n                    this_1.processMessages();\n                }\n                else {\n                    var logMessage_1 = new CategoryLogMessageImpl(msg(), actualError, logCateries, new Date(), level, settings.logFormat, false);\n                    logMessage_1.resolvedErrorMessage = resolved;\n                    this_1.allMessages.addTail(logMessage_1);\n                    MessageUtils_1.MessageFormatUtils.renderError(actualError).then(function (stack) {\n                        logMessage_1.setErrorAsStack(stack);\n                        logMessage_1.setReady(true);\n                        _this.processMessages();\n                    });\n                }\n                return \"break\";\n            }\n        };\n        var this_1 = this;\n        // Get the runtime levels for given categories. If their level is lower than given level, we log.\n        // In addition we pass along which category/categories we log this statement for.\n        for (var i = 0; i < logCateries.length; i++) {\n            var state_1 = _loop_1(i);\n            if (state_1 === \"break\")\n                break;\n        }\n    };\n    AbstractCategoryLogger.prototype.processMessages = function () {\n        // Basically we wait until errors are resolved (those messages\n        // may not be ready).\n        var msgs = this.allMessages;\n        if (msgs.getSize() > 0) {\n            do {\n                var msg = msgs.getHead();\n                if (msg != null) {\n                    if (!msg.isReady()) {\n                        break;\n                    }\n                    msgs.removeHead();\n                    this.doLog(msg);\n                }\n            } while (msgs.getSize() > 0);\n        }\n    };\n    return AbstractCategoryLogger;\n}());\nexports.AbstractCategoryLogger = AbstractCategoryLogger;\n//# sourceMappingURL=AbstractCategoryLogger.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/AbstractCategoryLogger.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nvar LinkedNode = (function () {\n    function LinkedNode(value) {\n        this._previous = null;\n        this._next = null;\n        this._value = value;\n    }\n    Object.defineProperty(LinkedNode.prototype, \"previous\", {\n        get: function () {\n            return this._previous;\n        },\n        set: function (value) {\n            this._previous = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedNode.prototype, \"next\", {\n        get: function () {\n            return this._next;\n        },\n        set: function (value) {\n            this._next = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LinkedNode.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LinkedNode;\n}());\n/**\n * Double linkedlist implementation.\n */\nvar LinkedList = (function () {\n    function LinkedList() {\n        this.head = null;\n        this.size = 0;\n    }\n    LinkedList.prototype.addHead = function (value) {\n        if (!this.createHeadIfNeeded(value)) {\n            if (this.head != null) {\n                var nextNode = this.head.next;\n                var newHeadNode = new LinkedNode(value);\n                if (nextNode != null) {\n                    nextNode.previous = newHeadNode;\n                    newHeadNode.next = nextNode;\n                }\n                this.head = newHeadNode;\n            }\n            else {\n                throw new Error(\"This should never happen, list implementation broken\");\n            }\n        }\n        this.size++;\n    };\n    LinkedList.prototype.addTail = function (value) {\n        if (!this.createHeadIfNeeded(value)) {\n            var oldTailNode = this.getTailNode();\n            if (oldTailNode != null) {\n                var newTailNode = new LinkedNode(value);\n                oldTailNode.next = newTailNode;\n                newTailNode.previous = oldTailNode;\n            }\n            else {\n                throw new Error(\"List implementation broken\");\n            }\n        }\n        this.size++;\n    };\n    LinkedList.prototype.clear = function () {\n        this.head = null;\n        this.size = 0;\n    };\n    LinkedList.prototype.getHead = function () {\n        if (this.head != null) {\n            return this.head.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.removeHead = function () {\n        if (this.head != null) {\n            var oldHead = this.head;\n            var value = oldHead.value;\n            this.head = oldHead.next;\n            this.size--;\n            return value;\n        }\n        return null;\n    };\n    LinkedList.prototype.getTail = function () {\n        var node = this.getTailNode();\n        if (node != null) {\n            return node.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.removeTail = function () {\n        var node = this.getTailNode();\n        if (node != null) {\n            if (node === this.head) {\n                this.head = null;\n            }\n            else {\n                var previousNode = node.previous;\n                if (previousNode != null) {\n                    previousNode.next = null;\n                }\n                else {\n                    throw new Error(\"List implementation is broken\");\n                }\n            }\n            this.size--;\n            return node.value;\n        }\n        return null;\n    };\n    LinkedList.prototype.getSize = function () {\n        return this.size;\n    };\n    LinkedList.prototype.filter = function (f) {\n        var recurse = function (fn, node, values) {\n            if (fn(node.value)) {\n                values.push(node.value);\n            }\n            var nextNode = node.next;\n            if (nextNode != null) {\n                recurse(fn, nextNode, values);\n            }\n        };\n        var result = [];\n        var node = this.head;\n        if (node != null) {\n            recurse(f, node, result);\n        }\n        return result;\n    };\n    LinkedList.prototype.createHeadIfNeeded = function (value) {\n        if (this.head == null) {\n            this.head = new LinkedNode(value);\n            return true;\n        }\n        return false;\n    };\n    LinkedList.prototype.getTailNode = function () {\n        if (this.head == null) {\n            return null;\n        }\n        var node = this.head;\n        while (node.next != null) {\n            node = node.next;\n        }\n        return node;\n    };\n    return LinkedList;\n}());\nexports.LinkedList = LinkedList;\n/**\n * Map implementation keyed by string (always). Note that the get/remove return either value or null.\n * This map does not support undefined in any fasion (on purpose).\n */\nvar SimpleMap = (function () {\n    function SimpleMap() {\n        this.array = {};\n    }\n    SimpleMap.prototype.put = function (key, value) {\n        if (value === undefined) {\n            throw new Error(\"Undefined value is not allowed, null is.\");\n        }\n        this.array[key] = value;\n    };\n    SimpleMap.prototype.get = function (key) {\n        var value = this.array[key];\n        if (value !== undefined) {\n            return value;\n        }\n        return null;\n    };\n    SimpleMap.prototype.exists = function (key) {\n        var value = this.array[key];\n        return value !== undefined;\n    };\n    SimpleMap.prototype.remove = function (key) {\n        var value = this.array[key];\n        if (value !== undefined) {\n            delete this.array[key];\n        }\n        return value;\n    };\n    SimpleMap.prototype.keys = function () {\n        var keys = [];\n        for (var key in this.array) {\n            // To prevent random stuff to appear\n            if (this.array.hasOwnProperty(key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    SimpleMap.prototype.values = function () {\n        var values = [];\n        for (var key in this.array) {\n            // To prevent random stuff to appear\n            if (this.array.hasOwnProperty(key)) {\n                values.push(this.get(key));\n            }\n        }\n        return values;\n    };\n    SimpleMap.prototype.size = function () {\n        return this.keys().length;\n    };\n    SimpleMap.prototype.isEmpty = function () {\n        return this.size() === 0;\n    };\n    SimpleMap.prototype.clear = function () {\n        this.array = {};\n    };\n    return SimpleMap;\n}());\nexports.SimpleMap = SimpleMap;\n/**\n * Tuple to hold two values.\n */\nvar TuplePair = (function () {\n    function TuplePair(x, y) {\n        this._x = x;\n        this._y = y;\n    }\n    Object.defineProperty(TuplePair.prototype, \"x\", {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            this._x = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TuplePair.prototype, \"y\", {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            this._y = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return TuplePair;\n}());\nexports.TuplePair = TuplePair;\n/**\n * Utility class to build up a string.\n */\nvar StringBuilder = (function () {\n    function StringBuilder() {\n        this.data = [];\n    }\n    StringBuilder.prototype.append = function (line) {\n        if (line === undefined || line == null) {\n            throw new Error(\"String must be set, cannot append null or undefined\");\n        }\n        this.data.push(line);\n        return this;\n    };\n    StringBuilder.prototype.appendLine = function (line) {\n        this.data.push(line + \"\\n\");\n        return this;\n    };\n    StringBuilder.prototype.isEmpty = function () {\n        return this.data.length === 0;\n    };\n    StringBuilder.prototype.clear = function () {\n        this.data = [];\n    };\n    StringBuilder.prototype.toString = function (separator) {\n        if (separator === void 0) { separator = \"\"; }\n        return this.data.join(separator);\n    };\n    return StringBuilder;\n}());\nexports.StringBuilder = StringBuilder;\n//# sourceMappingURL=DataStructures.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/DataStructures.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n/**\n * Log level for a logger.\n */\n(function (LogLevel) {\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n})(exports.LogLevel || (exports.LogLevel = {}));\nvar LogLevel = exports.LogLevel;\n/* tslint:disable:no-namespace */\n(function (LogLevel) {\n    /**\n     * Returns LogLevel based on string representation\n     * @param val Value\n     * @returns {LogLevel}, Error is thrown if invalid.\n     */\n    function fromString(val) {\n        if (val == null) {\n            throw new Error(\"Argument must be set\");\n        }\n        switch (val.toLowerCase()) {\n            case \"trace\":\n                return LogLevel.Trace;\n            case \"debug\":\n                return LogLevel.Debug;\n            case \"info\":\n                return LogLevel.Info;\n            case \"warn\":\n                return LogLevel.Warn;\n            case \"error\":\n                return LogLevel.Error;\n            case \"fatal\":\n                return LogLevel.Fatal;\n            default:\n                throw new Error(\"Unsupported value for conversion: \" + val);\n        }\n    }\n    LogLevel.fromString = fromString;\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n/* tslint:disable:enable-namespace */\n/**\n * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)\n * where this comes into play.\n */\n(function (LoggerType) {\n    LoggerType[LoggerType[\"Console\"] = 0] = \"Console\";\n    LoggerType[LoggerType[\"MessageBuffer\"] = 1] = \"MessageBuffer\";\n    LoggerType[LoggerType[\"Custom\"] = 2] = \"Custom\";\n})(exports.LoggerType || (exports.LoggerType = {}));\nvar LoggerType = exports.LoggerType;\n/**\n * Defines several date enums used for formatting a date.\n */\n(function (DateFormatEnum) {\n    /**\n     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"Default\"] = 0] = \"Default\";\n    /**\n     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearMonthDayTime\"] = 1] = \"YearMonthDayTime\";\n    /**\n     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearDayMonthWithFullTime\"] = 2] = \"YearDayMonthWithFullTime\";\n    /**\n     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59\n     * Note the date separator can be set separately.\n     */\n    DateFormatEnum[DateFormatEnum[\"YearDayMonthTime\"] = 3] = \"YearDayMonthTime\";\n})(exports.DateFormatEnum || (exports.DateFormatEnum = {}));\nvar DateFormatEnum = exports.DateFormatEnum;\n/**\n * DateFormat class, stores data on how to format a date.\n */\nvar DateFormat = (function () {\n    /**\n     * Constructor to define the dateformat used for logging, can be called empty as it uses defaults.\n     * @param formatEnum DateFormatEnum, use one of the constants from the enum. Defaults to DateFormatEnum.Default\n     * @param dateSeparator Separator used between dates, defaults to -\n     */\n    function DateFormat(formatEnum, dateSeparator) {\n        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }\n        if (dateSeparator === void 0) { dateSeparator = \"-\"; }\n        this._formatEnum = formatEnum;\n        this._dateSeparator = dateSeparator;\n    }\n    Object.defineProperty(DateFormat.prototype, \"formatEnum\", {\n        get: function () {\n            return this._formatEnum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DateFormat.prototype, \"dateSeparator\", {\n        get: function () {\n            return this._dateSeparator;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return DateFormat;\n}());\nexports.DateFormat = DateFormat;\n/**\n * Information about the log format, what will a log line look like?\n */\nvar LogFormat = (function () {\n    /**\n     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.\n     * @param dateFormat DateFormat (what needs the date look like in the log line)\n     * @param showTimeStamp Show date timestamp at all?\n     * @param showLoggerName Show the logger name?\n     */\n    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {\n        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n        if (showTimeStamp === void 0) { showTimeStamp = true; }\n        if (showLoggerName === void 0) { showLoggerName = true; }\n        this._showTimeStamp = true;\n        this._showLoggerName = true;\n        this._dateFormat = dateFormat;\n        this._showTimeStamp = showTimeStamp;\n        this._showLoggerName = showLoggerName;\n    }\n    Object.defineProperty(LogFormat.prototype, \"dateFormat\", {\n        get: function () {\n            return this._dateFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogFormat.prototype, \"showTimeStamp\", {\n        get: function () {\n            return this._showTimeStamp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogFormat.prototype, \"showLoggerName\", {\n        get: function () {\n            return this._showLoggerName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LogFormat;\n}());\nexports.LogFormat = LogFormat;\n/**\n * Information about the log format, what will a log line look like?\n */\nvar CategoryLogFormat = (function () {\n    /**\n     * Create an instance defining the category log format used.\n     * @param dateFormat Date format (uses default), for details see DateFormat class.\n     * @param showTimeStamp True to show timestamp in the logging, defaults to true.\n     * @param showCategoryName True to show category name in the logging, defaults to true.\n     */\n    function CategoryLogFormat(dateFormat, showTimeStamp, showCategoryName) {\n        if (dateFormat === void 0) { dateFormat = new DateFormat(); }\n        if (showTimeStamp === void 0) { showTimeStamp = true; }\n        if (showCategoryName === void 0) { showCategoryName = true; }\n        this._dateFormat = dateFormat;\n        this._showTimeStamp = showTimeStamp;\n        this._showCategoryName = showCategoryName;\n    }\n    Object.defineProperty(CategoryLogFormat.prototype, \"dateFormat\", {\n        get: function () {\n            return this._dateFormat;\n        },\n        set: function (value) {\n            this._dateFormat = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryLogFormat.prototype, \"showTimeStamp\", {\n        get: function () {\n            return this._showTimeStamp;\n        },\n        set: function (value) {\n            this._showTimeStamp = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryLogFormat.prototype, \"showCategoryName\", {\n        get: function () {\n            return this._showCategoryName;\n        },\n        set: function (value) {\n            this._showCategoryName = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CategoryLogFormat;\n}());\nexports.CategoryLogFormat = CategoryLogFormat;\n//# sourceMappingURL=LoggerOptions.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/LoggerOptions.js\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar ST = require(\"stacktrace-js\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\n/**\n * Some utilities to format messages.\n */\nvar MessageFormatUtils = (function () {\n    function MessageFormatUtils() {\n    }\n    /**\n     * Render given date in given DateFormat and return as String.\n     * @param date Date\n     * @param dateFormat Format\n     * @returns {string} Formatted date\n     */\n    MessageFormatUtils.renderDate = function (date, dateFormat) {\n        var lpad = function (value, chars, padWith) {\n            var howMany = chars - value.length;\n            if (howMany > 0) {\n                var res = \"\";\n                for (var i = 0; i < howMany; i++) {\n                    res += padWith;\n                }\n                res += value;\n                return res;\n            }\n            return value;\n        };\n        var fullYear = function (d) {\n            return lpad(d.getFullYear().toString(), 4, \"0\");\n        };\n        var month = function (d) {\n            return lpad((d.getMonth() + 1).toString(), 2, \"0\");\n        };\n        var day = function (d) {\n            return lpad(d.getDate().toString(), 2, \"0\");\n        };\n        var hours = function (d) {\n            return lpad(d.getHours().toString(), 2, \"0\");\n        };\n        var minutes = function (d) {\n            return lpad(d.getMinutes().toString(), 2, \"0\");\n        };\n        var seconds = function (d) {\n            return lpad(d.getSeconds().toString(), 2, \"0\");\n        };\n        var millis = function (d) {\n            return lpad(d.getMilliseconds().toString(), 3, \"0\");\n        };\n        var dateSeparator = dateFormat.dateSeparator;\n        var ds = \"\";\n        switch (dateFormat.formatEnum) {\n            case LoggerOptions_1.DateFormatEnum.Default:\n                // yyyy-mm-dd hh:mm:ss,m\n                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + \" \" +\n                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n                break;\n            case LoggerOptions_1.DateFormatEnum.YearMonthDayTime:\n                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + \" \" +\n                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date);\n                break;\n            case LoggerOptions_1.DateFormatEnum.YearDayMonthWithFullTime:\n                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + \" \" +\n                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date) + \",\" + millis(date);\n                break;\n            case LoggerOptions_1.DateFormatEnum.YearDayMonthTime:\n                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + \" \" +\n                    hours(date) + \":\" + minutes(date) + \":\" + seconds(date);\n                break;\n            default:\n                throw new Error(\"Unsupported date format enum: \" + dateFormat.formatEnum);\n        }\n        return ds;\n    };\n    /**\n     * Renders given category log message\n     * @param msg Message to format\n     * @param addStack If true adds the stack to the output, otherwise skips it\n     * @returns {string} Formatted message\n     */\n    MessageFormatUtils.renderDefaultMessage = function (msg, addStack) {\n        var result = \"\";\n        var logFormat = msg.getLogFormat();\n        if (logFormat.showTimeStamp) {\n            result += MessageFormatUtils.renderDate(msg.getDate(), logFormat.dateFormat) + \" \";\n        }\n        result += LoggerOptions_1.LogLevel[msg.getLevel()].toUpperCase();\n        if (msg.isResolvedErrorMessage()) {\n            result += \" (resolved)\";\n        }\n        result += \" \";\n        if (logFormat.showCategoryName) {\n            result += \"[\";\n            msg.getCategories().forEach(function (value, idx) {\n                if (idx > 0) {\n                    result += \", \";\n                }\n                result += value.name;\n            });\n            result += \"]\";\n        }\n        result += \" \" + msg.getMessage();\n        if (addStack && msg.getErrorAsStack() != null) {\n            result += \"\\n\" + msg.getErrorAsStack();\n        }\n        return result;\n    };\n    /**\n     * Render error as stack\n     * @param error Return error as Promise\n     * @returns {Promise<string>|Promise} Promise for stack\n     */\n    MessageFormatUtils.renderError = function (error) {\n        var result = error.name + \": \" + error.message + \"\\n@\";\n        return new Promise(function (resolve) {\n            // This one has a promise too\n            ST.fromError(error, { offline: true }).then(function (frames) {\n                var stackStr = (frames.map(function (frame) {\n                    return frame.toString();\n                })).join(\"\\n  \");\n                result += \"\\n\" + stackStr;\n                // This resolves our returned promise\n                resolve(result);\n            });\n        });\n    };\n    return MessageFormatUtils;\n}());\nexports.MessageFormatUtils = MessageFormatUtils;\n//# sourceMappingURL=MessageUtils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/MessageUtils.js\n// module id = 4\n// module chunks = 0","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function(stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        },\n        sourceCache: {}\n    };\n\n    var _generateError = function StackTrace$$GenerateError() {\n        try {\n            // Error must be thrown to get stack in IE\n            throw new Error();\n        } catch (err) {\n            return err;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     *\n     * @param {Object} first base object\n     * @param {Object} second overrides\n     * @returns {Object} merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function(obj) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    function _filtered(stackframes, filter) {\n        if (typeof filter === 'function') {\n            return stackframes.filter(filter);\n        }\n        return stackframes;\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        get: function StackTrace$$get(opts) {\n            var err = _generateError();\n            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n        },\n\n        /**\n         * Get a backtrace from invocation point.\n         * IMPORTANT: Does not handle source maps or guess function names!\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        getSync: function StackTrace$$getSync(opts) {\n            opts = _merge(_options, opts);\n            var err = _generateError();\n            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n            return _filtered(stack, opts.filter);\n        },\n\n        /**\n         * Given an error object, parse it.\n         *\n         * @param {Error} error object\n         * @param {Object} opts\n         * @returns {Promise} for Array[StackFrame}\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            var gps = new StackTraceGPS(opts);\n            return new Promise(function(resolve) {\n                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                resolve(Promise.all(stackframes.map(function(sf) {\n                    return new Promise(function(resolve) {\n                        function resolveOriginal() {\n                            resolve(sf);\n                        }\n\n                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         *\n         * @param {Object} opts\n         * @returns {Promise} of Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    return fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param {Function} fn to de-instrument\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        },\n\n        /**\n         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n         *\n         * @param {Array} stackframes\n         * @param {String} url\n         * @param {String} errorMsg\n         */\n        report: function StackTrace$$report(stackframes, url, errorMsg) {\n            return new Promise(function(resolve, reject) {\n                var req = new XMLHttpRequest();\n                req.onerror = reject;\n                req.onreadystatechange = function onreadystatechange() {\n                    if (req.readyState === 4) {\n                        if (req.status >= 200 && req.status < 400) {\n                            resolve(req.responseText);\n                        } else {\n                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                        }\n                    }\n                };\n                req.open('post', url);\n                req.setRequestHeader('Content-Type', 'application/json');\n\n                var reportPayload = {stack: stackframes};\n                if (errorMsg !== undefined) {\n                    reportPayload.message = errorMsg;\n                }\n\n                req.send(JSON.stringify(reportPayload));\n            });\n        }\n    };\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stacktrace-js/stacktrace.js\n// module id = 5\n// module chunks = 0","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    function _map(array, fn, thisArg) {\n        if (typeof Array.prototype.map === 'function') {\n            return array.map(fn, thisArg);\n        } else {\n            var output = new Array(array.length);\n            for (var i = 0; i < array.length; i++) {\n                output[i] = fn.call(thisArg, array[i]);\n            }\n            return output;\n        }\n    }\n\n    function _filter(array, fn, thisArg) {\n        if (typeof Array.prototype.filter === 'function') {\n            return array.filter(fn, thisArg);\n        } else {\n            var output = [];\n            for (var i = 0; i < array.length; i++) {\n                if (fn.call(thisArg, array[i])) {\n                    output.push(array[i]);\n                }\n            }\n            return output;\n        }\n    }\n\n    function _indexOf(array, target) {\n        if (typeof Array.prototype.indexOf === 'function') {\n            return array.indexOf(target);\n        } else {\n            for (var i = 0; i < array.length; i++) {\n                if (array[i] === target) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return _map(filtered, function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame(line);\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n                    return new StackFrame(functionName,\n                        undefined,\n                        locationParts[0],\n                        locationParts[1],\n                        locationParts[2],\n                        line);\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame(\n                            match[3] || undefined,\n                            undefined,\n                            match[2],\n                            match[1],\n                            undefined,\n                            lines[i]\n                        )\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = _filter(error.stack.split('\\n'), function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return _map(filtered, function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n                return new StackFrame(\n                    functionName,\n                    args,\n                    locationParts[0],\n                    locationParts[1],\n                    locationParts[2],\n                    line);\n            }, this);\n        }\n    };\n}));\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/error-stack-parser/error-stack-parser.js\n// module id = 6\n// module chunks = 0","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n        if (functionName !== undefined) {\n            this.setFunctionName(functionName);\n        }\n        if (args !== undefined) {\n            this.setArgs(args);\n        }\n        if (fileName !== undefined) {\n            this.setFileName(fileName);\n        }\n        if (lineNumber !== undefined) {\n            this.setLineNumber(lineNumber);\n        }\n        if (columnNumber !== undefined) {\n            this.setColumnNumber(columnNumber);\n        }\n        if (source !== undefined) {\n            this.setSource(source);\n        }\n    }\n\n    StackFrame.prototype = {\n        getFunctionName: function () {\n            return this.functionName;\n        },\n        setFunctionName: function (v) {\n            this.functionName = String(v);\n        },\n\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        // NOTE: Property name may be misleading as it includes the path,\n        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n        getFileName: function () {\n            return this.fileName;\n        },\n        setFileName: function (v) {\n            this.fileName = String(v);\n        },\n\n        getLineNumber: function () {\n            return this.lineNumber;\n        },\n        setLineNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Line Number must be a Number');\n            }\n            this.lineNumber = Number(v);\n        },\n\n        getColumnNumber: function () {\n            return this.columnNumber;\n        },\n        setColumnNumber: function (v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Column Number must be a Number');\n            }\n            this.columnNumber = Number(v);\n        },\n\n        getSource: function () {\n            return this.source;\n        },\n        setSource: function (v) {\n            this.source = String(v);\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    return StackFrame;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stackframe/stackframe.js\n// module id = 7\n// module chunks = 0","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stack-generator', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.StackGenerator = factory(root.StackFrame);\n    }\n}(this, function (StackFrame) {\n    return {\n        backtrace: function StackGenerator$$backtrace(opts) {\n            var stack = [];\n            var maxStackSize = 10;\n\n            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n                maxStackSize = opts.maxStackSize;\n            }\n\n            var curr = arguments.callee;\n            while (curr && stack.length < maxStackSize) {\n                // Allow V8 optimizations\n                var args = new Array(curr['arguments'].length);\n                for(var i = 0; i < args.length; ++i) {\n                    args[i] = curr['arguments'][i];\n                }\n                if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));\n                } else {\n                    stack.push(new StackFrame({args: args}));\n                }\n\n                try {\n                    curr = curr.caller;\n                } catch (e) {\n                    break;\n                }\n            }\n            return stack;\n        }\n    };\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stack-generator/stack-generator.js\n// module id = 8\n// module chunks = 0","(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function () {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str[0].toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function () {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            var props = booleanProps.concat(numericProps.concat(stringProps.concat(arrayProps)));\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function () {\n            return this.args;\n        },\n        setArgs: function (v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function () {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function (v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function () {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function (p) {\n            return function (v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function (p) {\n            return function (v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function (p) {\n            return function (v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stack-generator/~/stackframe/stackframe.js\n// module id = 9\n// module chunks = 0","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if (req.status >= 200 && req.status < 300) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        // function {name}({args}) m[1]=name m[2]=args\n        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n        // {name} = function ({args}) TODO args capture\n        var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\n        // {name} = eval()\n        var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        var m;\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                m = reFunctionExpression.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionDeclaration.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionEvaluation.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var m = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/.exec(source);\n        if (m && m[1]) {\n            return m[1];\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);\n\n            var loc = mapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                var mappedSource = mapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n                resolve(\n                    new StackFrame(\n                        loc.name || stackframe.functionName,\n                        stackframe.args,\n                        loc.source,\n                        loc.line,\n                        loc.column));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame(guessedFunctionName,\n                            stackframe.args,\n                            stackframe.fileName,\n                            lineNumber,\n                            columnNumber));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = base + sourceMappingURL;\n                    }\n\n                    this._get(sourceMappingURL).then(function(sourceMap) {\n                        if (typeof sourceMap === 'string') {\n                            sourceMap = _parseJson(sourceMap.replace(/^\\)\\]\\}'/, ''));\n                        }\n                        if (typeof sourceMap.sourceRoot === 'undefined') {\n                            sourceMap.sourceRoot = base;\n                        }\n\n                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)\n                            .then(resolve)['catch'](function() {\n                            resolve(stackframe);\n                        });\n                    }, reject)['catch'](reject);\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stacktrace-gps/stacktrace-gps.js\n// module id = 10\n// module chunks = 0","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/source-map.js\n// module id = 11\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/source-map-generator.js\n// module id = 12\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/base64-vlq.js\n// module id = 13\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/base64.js\n// module id = 14\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/util.js\n// module id = 15\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/array-set.js\n// module id = 16\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/mapping-list.js\n// module id = 17\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/source-map-consumer.js\n// module id = 18\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/binary-search.js\n// module id = 19\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/quick-sort.js\n// module id = 20\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/source-map/lib/source-node.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractCategoryLogger_1 = require(\"./AbstractCategoryLogger\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\n/**\n * Simple logger, that logs to the console. If the console is unavailable will throw an exception.\n */\nvar CategoryConsoleLoggerImpl = (function (_super) {\n    __extends(CategoryConsoleLoggerImpl, _super);\n    function CategoryConsoleLoggerImpl(rootCategory, runtimeSettings) {\n        return _super.call(this, rootCategory, runtimeSettings) || this;\n    }\n    CategoryConsoleLoggerImpl.prototype.doLog = function (msg) {\n        var fullMsg = this.createDefaultLogMessage(msg);\n        if (console !== undefined) {\n            var logged = false;\n            /* tslint:disable:no-console */\n            switch (msg.getLevel()) {\n                case LoggerOptions_1.LogLevel.Trace:\n                    if (console.trace) {\n                        console.trace(fullMsg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Debug:\n                    if (console.debug) {\n                        console.debug(fullMsg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Info:\n                    if (console.info) {\n                        console.info(fullMsg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Warn:\n                    if (console.warn) {\n                        console.warn(fullMsg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Error:\n                case LoggerOptions_1.LogLevel.Fatal:\n                    if (console.error) {\n                        console.error(fullMsg);\n                        logged = true;\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unsupported level: \" + msg.getLevel());\n            }\n            if (!logged) {\n                console.log(fullMsg);\n            }\n        }\n        else {\n            throw new Error(\"Console is not defined, cannot log msg: \" + fullMsg);\n        }\n    };\n    return CategoryConsoleLoggerImpl;\n}(AbstractCategoryLogger_1.AbstractCategoryLogger));\nexports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl;\n//# sourceMappingURL=CategoryConsoleLoggerImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryConsoleLoggerImpl.js\n// module id = 22\n// module chunks = 0","\"use strict\";\n/**\n * Delegate logger, delegates logging to given logger (constructor).\n */\nvar CategoryDelegateLoggerImpl = (function () {\n    function CategoryDelegateLoggerImpl(delegate) {\n        this._delegate = delegate;\n    }\n    Object.defineProperty(CategoryDelegateLoggerImpl.prototype, \"delegate\", {\n        get: function () {\n            return this._delegate;\n        },\n        set: function (value) {\n            this._delegate = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CategoryDelegateLoggerImpl.prototype.trace = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).trace.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.debug = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).debug.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.info = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).info.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.warn = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).warn.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.error = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).error.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.fatal = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).fatal.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.resolved = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).resolved.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.log = function (level, msg, error) {\n        var categories = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            categories[_i - 3] = arguments[_i];\n        }\n        (_a = this._delegate).log.apply(_a, [level, msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.tracec = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).tracec.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.debugc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).debugc.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.infoc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).infoc.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.warnc = function (msg) {\n        var categories = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            categories[_i - 1] = arguments[_i];\n        }\n        (_a = this._delegate).warnc.apply(_a, [msg].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.errorc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).errorc.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.fatalc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).fatalc.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.resolvedc = function (msg, error) {\n        var categories = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            categories[_i - 2] = arguments[_i];\n        }\n        (_a = this._delegate).resolvedc.apply(_a, [msg, error].concat(categories));\n        var _a;\n    };\n    CategoryDelegateLoggerImpl.prototype.logc = function (level, msg, error) {\n        var categories = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            categories[_i - 3] = arguments[_i];\n        }\n        (_a = this._delegate).logc.apply(_a, [level, msg, error].concat(categories));\n        var _a;\n    };\n    return CategoryDelegateLoggerImpl;\n}());\nexports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl;\n//# sourceMappingURL=CategoryDelegateLoggerImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryDelegateLoggerImpl.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar CategoryService_1 = require(\"./CategoryService\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\n/**\n * Category for use with categorized logging.\n * At minimum you need one category, which will serve as the root category.\n * You can create child categories (like a tree). You can have multiple root\n * categories.\n */\nvar Category = (function () {\n    function Category(name, parent) {\n        if (parent === void 0) { parent = null; }\n        this._children = [];\n        this._logLevel = LoggerOptions_1.LogLevel.Error;\n        if (name.indexOf(\"#\") !== -1) {\n            throw new Error(\"Cannot use # in a name of a Category\");\n        }\n        this._id = Category.nextId();\n        this._name = name;\n        this._parent = parent;\n        if (this._parent != null) {\n            this._parent._children.push(this);\n        }\n        CategoryService_1.CategoryServiceImpl.getInstance().registerCategory(this);\n    }\n    Object.defineProperty(Category.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Category.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Category.prototype, \"children\", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Category.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Category.prototype.getCategoryPath = function () {\n        var result = this.name;\n        var cat = this.parent;\n        while (cat != null) {\n            result = cat.name + \"#\" + result;\n            cat = cat.parent;\n        }\n        return result;\n    };\n    Object.defineProperty(Category.prototype, \"id\", {\n        /**\n         * Returns the id for this category (this\n         * is for internal purposes only).\n         * @returns {number} Id\n         */\n        get: function () {\n            return this._id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Category.nextId = function () {\n        return Category.currentId++;\n    };\n    return Category;\n}());\nexports.Category = Category;\nCategory.currentId = 1;\n//# sourceMappingURL=CategoryLogger.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryLogger.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nvar CategoryConsoleLoggerImpl_1 = require(\"./CategoryConsoleLoggerImpl\");\nvar CategoryDelegateLoggerImpl_1 = require(\"./CategoryDelegateLoggerImpl\");\nvar CategoryExtensionLoggerImpl_1 = require(\"./CategoryExtensionLoggerImpl\");\nvar CategoryMessageBufferImpl_1 = require(\"./CategoryMessageBufferImpl\");\nvar DataStructures_1 = require(\"./DataStructures\");\nvar ExtensionHelper_1 = require(\"./ExtensionHelper\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\n/**\n * RuntimeSettings for a category, at runtime these are associated to a category.\n */\nvar CategoryRuntimeSettings = (function () {\n    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger) {\n        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }\n        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }\n        if (callBackLogger === void 0) { callBackLogger = null; }\n        this._category = category;\n        this._logLevel = logLevel;\n        this._loggerType = loggerType;\n        this._logFormat = logFormat;\n        this._callBackLogger = callBackLogger;\n    }\n    Object.defineProperty(CategoryRuntimeSettings.prototype, \"category\", {\n        get: function () {\n            return this._category;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryRuntimeSettings.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        set: function (value) {\n            this._logLevel = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryRuntimeSettings.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        set: function (value) {\n            this._loggerType = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryRuntimeSettings.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        set: function (value) {\n            this._logFormat = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryRuntimeSettings.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        set: function (value) {\n            this._callBackLogger = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CategoryRuntimeSettings;\n}());\nexports.CategoryRuntimeSettings = CategoryRuntimeSettings;\n/**\n * Default configuration, can be used to initially set a different default configuration\n * on the CategoryServiceFactory. This will be applied to all categories already registered (or\n * registered in the future).\n */\nvar CategoryDefaultConfiguration = (function () {\n    /**\n     * Create a new instance\n     * @param logLevel Log level for all loggers, default is LogLevel.Error\n     * @param loggerType Where to log, default is LoggerType.Console\n     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.\n     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.\n     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.\n     */\n    function CategoryDefaultConfiguration(logLevel, loggerType, logFormat, callBackLogger) {\n        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }\n        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }\n        if (callBackLogger === void 0) { callBackLogger = null; }\n        this._logLevel = logLevel;\n        this._loggerType = loggerType;\n        this._logFormat = logFormat;\n        this._callBackLogger = callBackLogger;\n        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {\n            throw new Error(\"If you specify loggerType to be Custom, you must provide the callBackLogger argument\");\n        }\n    }\n    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CategoryDefaultConfiguration.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CategoryDefaultConfiguration;\n}());\nexports.CategoryDefaultConfiguration = CategoryDefaultConfiguration;\n/**\n * The service (only available as singleton) for all category related stuff as\n * retrieving, registering a logger. You should normally NOT use this,\n * instead use CategoryLoggerFactory which is meant for end users.\n */\nvar CategoryServiceImpl = (function () {\n    function CategoryServiceImpl() {\n        this.defaultConfig = new CategoryDefaultConfiguration();\n        // All registered root categories\n        this.rootCategories = [];\n        // Key of map is path of category\n        this.categoryRuntimeSettings = new DataStructures_1.SimpleMap();\n        // Key is name of root logger.\n        this.rootLoggers = new DataStructures_1.SimpleMap();\n        // Allow extensions to talk with us.\n        ExtensionHelper_1.ExtensionHelper.register();\n    }\n    CategoryServiceImpl.getInstance = function () {\n        return CategoryServiceImpl.INSTANCE;\n    };\n    CategoryServiceImpl.prototype.getLogger = function (root) {\n        if (!this.rootCategoryExists(root)) {\n            throw new Error(\"Given category \" + root.name + \" is not registered as a root category. You must use the root category to retrieve a logger.\");\n        }\n        var pair = this.rootLoggers.get(root.name);\n        if (pair != null) {\n            return pair.y;\n        }\n        var logger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this.createRootLogger(root));\n        this.rootLoggers.put(root.name, new DataStructures_1.TuplePair(root, logger));\n        return logger;\n    };\n    /**\n     * Clears everything, including a default configuration you may have set.\n     * After this you need to re-register your categories etc.\n     */\n    CategoryServiceImpl.prototype.clear = function () {\n        this.rootCategories = [];\n        this.categoryRuntimeSettings.clear();\n        this.rootLoggers.clear();\n        this.setDefaultConfiguration(new CategoryDefaultConfiguration());\n    };\n    CategoryServiceImpl.prototype.getCategorySettings = function (category) {\n        return this.categoryRuntimeSettings.get(category.getCategoryPath());\n    };\n    /**\n     * Set the default configuration. New root loggers created get this\n     * applied. If you want to reset all current loggers to have this\n     * applied as well, pass in reset=true (the default is false). All\n     * categories will be reset then as well.\n     * @param config New config\n     * @param reset Defaults to false. Set to true to reset all loggers and current runtimesettings.\n     */\n    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {\n        var _this = this;\n        if (reset === void 0) { reset = false; }\n        this.defaultConfig = config;\n        if (reset) {\n            // Reset all runtimesettings (this will reset it for roots & children all at once).\n            var newRuntimeSettings_1 = new DataStructures_1.SimpleMap();\n            this.categoryRuntimeSettings.keys().forEach(function (key) {\n                var setting = _this.categoryRuntimeSettings.get(key);\n                if (setting != null) {\n                    var settings = new CategoryRuntimeSettings(setting.category, _this.defaultConfig.logLevel, _this.defaultConfig.loggerType, _this.defaultConfig.logFormat, _this.defaultConfig.callBackLogger);\n                    newRuntimeSettings_1.put(key, settings);\n                }\n                else {\n                    throw new Error(\"No setting associated with key=\" + key);\n                }\n            });\n            this.categoryRuntimeSettings.clear();\n            this.categoryRuntimeSettings = newRuntimeSettings_1;\n            // Now initialize a new logger and put it on the delegate. Loggers we give out\n            // are guaranteed to be wrapped inside the delegate logger.\n            this.rootLoggers.values().forEach(function (pair) {\n                // Set the new logger type\n                pair.y.delegate = _this.createRootLogger(pair.x);\n            });\n        }\n    };\n    /**\n     * Set new configuration settings for a category (and possibly its child categories)\n     * @param config Config\n     * @param category Category\n     * @param applyChildren True to apply to child categories, defaults to false.\n     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.\n     */\n    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {\n        var _this = this;\n        if (applyChildren === void 0) { applyChildren = false; }\n        if (resetRootLogger === void 0) { resetRootLogger = false; }\n        var categorySettings = this.getCategorySettings(category);\n        if (categorySettings === null) {\n            throw new Error(\"Given category is not registered: \" + category.name);\n        }\n        categorySettings.logLevel = config.logLevel;\n        categorySettings.loggerType = config.loggerType;\n        categorySettings.logFormat = config.logFormat;\n        categorySettings.callBackLogger = config.callBackLogger;\n        // Apply the settings to children recursive if requested\n        if (applyChildren) {\n            category.children.forEach(function (child) {\n                _this.setConfigurationCategory(config, child, applyChildren, resetRootLogger);\n            });\n        }\n        if (resetRootLogger && this.rootCategoryExists(category)) {\n            var tupleLogger = this.rootLoggers.get(category.name);\n            if (tupleLogger !== null) {\n                tupleLogger.y.delegate = this.createRootLogger(tupleLogger.x);\n            }\n        }\n    };\n    CategoryServiceImpl.prototype.registerCategory = function (category) {\n        if (category == null || category === undefined) {\n            throw new Error(\"Category CANNOT be null\");\n        }\n        var parent = category.parent;\n        if (parent == null) {\n            // Register the root category\n            for (var _i = 0, _a = this.rootCategories; _i < _a.length; _i++) {\n                var rootCategory = _a[_i];\n                if (rootCategory.name === category.name) {\n                    throw new Error(\"Cannot add this rootCategory with name: \" + category.name + \", another root category is already registered with that name.\");\n                }\n            }\n            this.rootCategories.push(category);\n        }\n        this.initializeRuntimeSettingsForCategory(category);\n    };\n    /**\n     * Used to enable integration with chrome extension. Do not use manually, the\n     * extension and the logger framework deal with this.\n     */\n    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {\n        var _this = this;\n        this.rootLoggers.values().forEach(function (pair) {\n            // Set the new logger type if needed.\n            var delegateLogger = pair.y;\n            if (!(delegateLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {\n                /* tslint:disable:no-console */\n                console.log(\"Reconfiguring root logger for root category: \" + pair.x.name);\n                /* tslint:enable:no-console */\n                pair.y.delegate = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(pair.x, _this);\n            }\n        });\n    };\n    /**\n     * Return all root categories currently registered.\n     */\n    CategoryServiceImpl.prototype.getRootCategories = function () {\n        return this.rootCategories.slice(0);\n    };\n    /**\n     * Return Category by id\n     * @param id The id of the category to find\n     * @returns {Category} or null if not found\n     */\n    CategoryServiceImpl.prototype.getCategoryById = function (id) {\n        var result = this.categoryRuntimeSettings.values().filter(function (cat) { return cat.category.id === id; })\n            .map(function (cat) { return cat.category; });\n        if (result.length === 1) {\n            return result[0];\n        }\n        return null;\n    };\n    CategoryServiceImpl.prototype.initializeRuntimeSettingsForCategory = function (category) {\n        var settings = this.categoryRuntimeSettings.get(category.getCategoryPath());\n        if (settings != null) {\n            throw new Error(\"Category with path: \" + category.getCategoryPath() + \" is already registered?\");\n        }\n        // Passing the callback is not really needed for child categories, but don't really care.\n        settings = new CategoryRuntimeSettings(category, this.defaultConfig.logLevel, this.defaultConfig.loggerType, this.defaultConfig.logFormat, this.defaultConfig.callBackLogger);\n        this.categoryRuntimeSettings.put(category.getCategoryPath(), settings);\n    };\n    CategoryServiceImpl.prototype.rootCategoryExists = function (rootCategory) {\n        if (rootCategory == null || rootCategory === undefined) {\n            throw new Error(\"Root category CANNOT be null\");\n        }\n        var parent = rootCategory.parent;\n        if (parent != null) {\n            throw new Error(\"Parent must be null for a root category\");\n        }\n        return this.rootCategories.indexOf(rootCategory) !== -1;\n    };\n    CategoryServiceImpl.prototype.createRootLogger = function (category) {\n        // Default is always a console logger\n        switch (this.defaultConfig.loggerType) {\n            case LoggerOptions_1.LoggerType.Console:\n                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);\n            case LoggerOptions_1.LoggerType.MessageBuffer:\n                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);\n            case LoggerOptions_1.LoggerType.Custom:\n                if (this.defaultConfig.callBackLogger == null) {\n                    throw new Error(\"Cannot create custom logger, custom callback is null\");\n                }\n                else {\n                    return this.defaultConfig.callBackLogger(category, this);\n                }\n            default:\n                throw new Error(\"Cannot create a Logger for LoggerType: \" + this.defaultConfig.loggerType);\n        }\n    };\n    return CategoryServiceImpl;\n}());\nexports.CategoryServiceImpl = CategoryServiceImpl;\n// Singleton category service, used by CategoryServiceFactory as well as Categories.\nCategoryServiceImpl.INSTANCE = new CategoryServiceImpl();\n/**\n * Categorized service for logging, where logging is bound to categories which\n * can log horizontally through specific application logic (services, group(s) of components etc).\n * For the standard way of logging like most frameworks do these days, use LFService instead.\n * If you want fine grained control to divide sections of your application in\n * logical units to enable/disable logging for, this is the service you want to use instead.\n * Also for this type a browser plugin will be available.\n */\nvar CategoryServiceFactory = (function () {\n    function CategoryServiceFactory() {\n        // Private constructor.\n    }\n    /**\n     * Return a CategoryLogger for given ROOT category (thus has no parent).\n     * You can only retrieve loggers for their root, when logging\n     * you specify to log for what (child)categories.\n     * @param root Category root (has no parent)\n     * @returns {CategoryLogger}\n     */\n    CategoryServiceFactory.getLogger = function (root) {\n        return CategoryServiceImpl.getInstance().getLogger(root);\n    };\n    /**\n     * Clears everything, any registered (root)categories and loggers\n     * are discarded. Resets to default configuration.\n     */\n    CategoryServiceFactory.clear = function () {\n        return CategoryServiceImpl.getInstance().clear();\n    };\n    /**\n     * Set the default configuration. New root loggers created get this\n     * applied. If you want to reset all current loggers to have this\n     * applied as well, pass in reset=true (the default is false). All\n     * categories runtimesettings will be reset then as well.\n     * @param config The new default configuration\n     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these.\n     */\n    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {\n        if (reset === void 0) { reset = false; }\n        CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);\n    };\n    /**\n     * Set new configuration settings for a category (and possibly its child categories)\n     * @param config Config\n     * @param category Category\n     * @param applyChildren True to apply to child categories, defaults to false.\n     * @param resetRootLogger Defaults to false. If set to true and if category is a root category it will reset the root logger.\n     */\n    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren, resetRootLogger) {\n        if (applyChildren === void 0) { applyChildren = false; }\n        if (resetRootLogger === void 0) { resetRootLogger = false; }\n        CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren, resetRootLogger);\n    };\n    /**\n     * Return RuntimeSettings to retrieve information about\n     * RuntimeSettings for categories.\n     * @returns {RuntimeSettings}\n     */\n    CategoryServiceFactory.getRuntimeSettings = function () {\n        return CategoryServiceImpl.getInstance();\n    };\n    return CategoryServiceFactory;\n}());\nexports.CategoryServiceFactory = CategoryServiceFactory;\n//# sourceMappingURL=CategoryService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryService.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractCategoryLogger_1 = require(\"./AbstractCategoryLogger\");\nvar ExtensionHelper_1 = require(\"./ExtensionHelper\");\n/**\n * This class should not be used directly, it is used for communication with the extension only.\n */\nvar CategoryExtensionLoggerImpl = (function (_super) {\n    __extends(CategoryExtensionLoggerImpl, _super);\n    function CategoryExtensionLoggerImpl(rootCategory, runtimeSettings) {\n        return _super.call(this, rootCategory, runtimeSettings) || this;\n    }\n    CategoryExtensionLoggerImpl.prototype.doLog = function (msg) {\n        if (typeof window !== \"undefined\") {\n            ExtensionHelper_1.ExtensionHelper.sendCategoryLogMessage(msg);\n        }\n        else {\n            /* tslint:disable:no-console */\n            console.log(\"window is not available, you must be running in a browser for this. Dropped message.\");\n        }\n    };\n    return CategoryExtensionLoggerImpl;\n}(AbstractCategoryLogger_1.AbstractCategoryLogger));\nexports.CategoryExtensionLoggerImpl = CategoryExtensionLoggerImpl;\n//# sourceMappingURL=CategoryExtensionLoggerImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryExtensionLoggerImpl.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar CategoryService_1 = require(\"./CategoryService\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nvar MessageUtils_1 = require(\"./MessageUtils\");\nvar ExtensionHelper = (function () {\n    function ExtensionHelper() {\n        // Private constructor\n    }\n    /**\n     * Enables the window event listener to listen to messages (from extensions).\n     * Can be registered/enabled only once.\n     */\n    ExtensionHelper.register = function () {\n        if (!ExtensionHelper.registered) {\n            ExtensionHelper.registered = true;\n        }\n    };\n    /**\n     *  Extension framework will call this to enable the integration between two,\n     *  after this call the framework will respond with postMessage() messages.\n     */\n    ExtensionHelper.enableExtensionIntegration = function () {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        var instance = CategoryService_1.CategoryServiceImpl.getInstance();\n        instance.enableExtensionIntegration();\n        // Send over all categories\n        ExtensionHelper.sendRootCategoriesToExtension();\n        // Send over the current runtime levels\n        var cats = ExtensionHelper.getAllCategories();\n        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(cats);\n    };\n    ExtensionHelper.processMessageFromExtension = function (msg) {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        /* tslint:disable:no-console */\n        if (msg.from === \"tsl-extension\") {\n            var data = msg.data;\n            switch (data.type) {\n                case \"request-change-loglevel\":\n                    var valueRequest = data.value;\n                    var catsApplied = ExtensionHelper.applyLogLevel(valueRequest.categoryId, valueRequest.logLevel, valueRequest.recursive);\n                    if (catsApplied.length > 0) {\n                        // Send changes back\n                        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(catsApplied);\n                    }\n                    break;\n                default:\n                    console.log(\"Unknown command to process message from extension, command was: \" + data.type);\n                    break;\n            }\n        }\n        else {\n            console.log(\"Dropping message (not from tsl-extension): \" + msg.from);\n        }\n        /* tslint:enable:no-console */\n    };\n    ExtensionHelper.sendCategoryLogMessage = function (msg) {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        var categoryIds = msg.getCategories().map(function (cat) {\n            return cat.id;\n        });\n        var content = {\n            type: \"log-message\",\n            value: {\n                categories: categoryIds,\n                errorAsStack: msg.getErrorAsStack(),\n                formattedMessage: MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, false),\n                logLevel: LoggerOptions_1.LogLevel[msg.getLevel()].toString(),\n                message: msg.getMessage(),\n                resolvedErrorMessage: msg.isResolvedErrorMessage()\n            }\n        };\n        var message = {\n            data: content,\n            from: \"tsl-logging\",\n        };\n        ExtensionHelper.sendMessage(message);\n    };\n    ExtensionHelper.sendCategoriesRuntimeUpdateMessage = function (categories) {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        var service = CategoryService_1.CategoryServiceImpl.getInstance();\n        var catLevels = { categories: [{}] };\n        categories.forEach(function (cat) {\n            var catSettings = service.getCategorySettings(cat);\n            if (catSettings != null) {\n                catLevels.categories.push({ id: cat.id, logLevel: LoggerOptions_1.LogLevel[catSettings.logLevel].toString() });\n            }\n        });\n        var content = {\n            type: \"categories-rt-update\",\n            value: catLevels,\n        };\n        var message = {\n            data: content,\n            from: \"tsl-logging\"\n        };\n        ExtensionHelper.sendMessage(message);\n    };\n    ExtensionHelper.sendRootCategoriesToExtension = function () {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        var categories = CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().map(function (cat) {\n            return ExtensionHelper.getCategoryAsJSON(cat);\n        });\n        var content = {\n            type: \"root-categories-tree\",\n            value: categories\n        };\n        var message = {\n            data: content,\n            from: \"tsl-logging\"\n        };\n        ExtensionHelper.sendMessage(message);\n    };\n    /**\n     * If extension integration is enabled, will send the root categories over to the extension.\n     * Otherwise does nothing.\n     */\n    ExtensionHelper.getCategoryAsJSON = function (cat) {\n        var childCategories = cat.children.map(function (child) {\n            return ExtensionHelper.getCategoryAsJSON(child);\n        });\n        return {\n            children: childCategories,\n            id: cat.id,\n            logLevel: LoggerOptions_1.LogLevel[cat.logLevel].toString(),\n            name: cat.name,\n            parentId: (cat.parent != null ? cat.parent.id : null),\n        };\n    };\n    ExtensionHelper.applyLogLevel = function (categoryId, logLevel, recursive) {\n        var cats = [];\n        var category = CategoryService_1.CategoryServiceImpl.getInstance().getCategoryById(categoryId);\n        if (category != null) {\n            ExtensionHelper._applyLogLevelRecursive(category, LoggerOptions_1.LogLevel.fromString(logLevel), recursive, cats);\n        }\n        else {\n            /* tslint:disable:no-console */\n            console.log(\"Could not change log level, failed to find category with id: \" + categoryId);\n        }\n        return cats;\n    };\n    ExtensionHelper._applyLogLevelRecursive = function (category, logLevel, recursive, cats) {\n        var categorySettings = CategoryService_1.CategoryServiceImpl.getInstance().getCategorySettings(category);\n        if (categorySettings != null) {\n            categorySettings.logLevel = logLevel;\n            cats.push(category);\n            if (recursive) {\n                category.children.forEach(function (child) {\n                    ExtensionHelper._applyLogLevelRecursive(child, logLevel, recursive, cats);\n                });\n            }\n        }\n    };\n    ExtensionHelper.getAllCategories = function () {\n        var cats = [];\n        var addCats = function (cat, allCats) {\n            allCats.push(cat);\n            cat.children.forEach(function (catChild) {\n                addCats(catChild, allCats);\n            });\n        };\n        CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().forEach(function (cat) {\n            addCats(cat, cats);\n        });\n        return cats;\n    };\n    ExtensionHelper.sendMessage = function (msg) {\n        if (!ExtensionHelper.registered) {\n            return;\n        }\n        if (typeof window !== \"undefined\") {\n            /* tslint:disable:no-console */\n            console.log(\"Sending message to extension, message type: \" + msg.data.type);\n            /* tslint:enable:no-console */\n            window.postMessage(msg, \"*\");\n        }\n    };\n    return ExtensionHelper;\n}());\nexports.ExtensionHelper = ExtensionHelper;\nExtensionHelper.registered = false;\n//# sourceMappingURL=ExtensionHelper.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/ExtensionHelper.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractCategoryLogger_1 = require(\"./AbstractCategoryLogger\");\n/**\n * Logger which buffers all messages, use with care due to possible high memory footprint.\n * Can be convenient in some cases. Call toString() for full output, or cast to this class\n * and call getMessages() to do something with it yourself.\n */\nvar CategoryMessageBufferLoggerImpl = (function (_super) {\n    __extends(CategoryMessageBufferLoggerImpl, _super);\n    function CategoryMessageBufferLoggerImpl() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.messages = [];\n        return _this;\n    }\n    CategoryMessageBufferLoggerImpl.prototype.getMessages = function () {\n        return this.messages;\n    };\n    CategoryMessageBufferLoggerImpl.prototype.toString = function () {\n        return this.messages.map(function (msg) {\n            return msg;\n        }).join(\"\\n\");\n    };\n    CategoryMessageBufferLoggerImpl.prototype.doLog = function (msg) {\n        var fullMsg = this.createDefaultLogMessage(msg);\n        this.messages.push(fullMsg);\n    };\n    return CategoryMessageBufferLoggerImpl;\n}(AbstractCategoryLogger_1.AbstractCategoryLogger));\nexports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferLoggerImpl;\n//# sourceMappingURL=CategoryMessageBufferImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/CategoryMessageBufferImpl.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nvar ExtensionHelper_1 = require(\"./ExtensionHelper\");\nvar LoggerFactoryImpl_1 = require(\"./LoggerFactoryImpl\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\n/**\n * Defines a LogGroupRule, this allows you to either have everything configured the same way\n * or for example loggers that start with name model. It allows you to group loggers together\n * to have a certain loglevel and other settings. You can configure this when creating the\n * LoggerFactory (which accepts multiple LogGroupRules).\n */\nvar LogGroupRule = (function () {\n    /**\n     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)\n     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.\n     * @param regExp Regular expression, what matches for your logger names for this group\n     * @param level LogLevel\n     * @param logFormat LogFormat\n     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.\n     * @param callBackLogger Callback function to return a new clean custom logger (yours!)\n     */\n    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {\n        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }\n        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }\n        if (callBackLogger === void 0) { callBackLogger = null; }\n        this._regExp = regExp;\n        this._level = level;\n        this._logFormat = logFormat;\n        this._loggerType = loggerType;\n        this._callBackLogger = callBackLogger;\n    }\n    Object.defineProperty(LogGroupRule.prototype, \"regExp\", {\n        get: function () {\n            return this._regExp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"level\", {\n        get: function () {\n            return this._level;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"loggerType\", {\n        get: function () {\n            return this._loggerType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"logFormat\", {\n        get: function () {\n            return this._logFormat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LogGroupRule.prototype, \"callBackLogger\", {\n        get: function () {\n            return this._callBackLogger;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LogGroupRule;\n}());\nexports.LogGroupRule = LogGroupRule;\n/**\n * Options object you can use to configure the LoggerFactory you create at LFService.\n */\nvar LoggerFactoryOptions = (function () {\n    function LoggerFactoryOptions() {\n        this._logGroupRules = [];\n        this._enabled = true;\n    }\n    /**\n     * Add LogGroupRule, see {LogGroupRule) for details\n     * @param rule Rule to add\n     * @returns {LoggerFactoryOptions} returns itself\n     */\n    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {\n        this._logGroupRules.push(rule);\n        return this;\n    };\n    /**\n     * Enable or disable logging completely for the LoggerFactory.\n     * @param enabled True for enabled (default)\n     * @returns {LoggerFactoryOptions} returns itself\n     */\n    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {\n        this._enabled = enabled;\n        return this;\n    };\n    Object.defineProperty(LoggerFactoryOptions.prototype, \"logGroupRules\", {\n        get: function () {\n            return this._logGroupRules;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LoggerFactoryOptions.prototype, \"enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return LoggerFactoryOptions;\n}());\nexports.LoggerFactoryOptions = LoggerFactoryOptions;\n/**\n * Create and configure your LoggerFactory from here.\n */\nvar LFService = (function () {\n    function LFService() {\n    }\n    /**\n     * Create a new LoggerFactory with given options (if any). If no options\n     * are specified, the LoggerFactory, will accept any named logger and will\n     * log on info level by default for, to the console.\n     * @param options Options, optional.\n     * @returns {LoggerFactory}\n     */\n    LFService.createLoggerFactory = function (options) {\n        var factory;\n        if (options !== undefined) {\n            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(options);\n        }\n        else {\n            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(this.createDefaultOptions());\n        }\n        LFService._loggerFactories.push(factory);\n        // Allow extensions to talk with us.\n        ExtensionHelper_1.ExtensionHelper.register();\n        return factory;\n    };\n    /**\n     * Closes all Loggers for LoggerFactories that were created.\n     * After this call, all previously fetched Loggers (from their\n     * factories) are unusable. The factories remain as they were.\n     */\n    LFService.closeLoggers = function () {\n        for (var _i = 0, _a = this._loggerFactories; _i < _a.length; _i++) {\n            var loggerFactory = _a[_i];\n            loggerFactory.closeLoggers();\n        }\n        this._loggerFactories = [];\n    };\n    LFService.createDefaultOptions = function () {\n        return new LoggerFactoryOptions().addLogGroupRule(new LogGroupRule(new RegExp(\".+\"), LoggerOptions_1.LogLevel.Info));\n    };\n    return LFService;\n}());\nexports.LFService = LFService;\nLFService._loggerFactories = [];\n//# sourceMappingURL=LoggerFactoryService.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/LoggerFactoryService.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nvar LoggerImpl_1 = require(\"./LoggerImpl\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nvar LoggerFactoryImpl = (function () {\n    function LoggerFactoryImpl(options) {\n        this.loggers = {};\n        this.configure(options);\n    }\n    LoggerFactoryImpl.prototype.configure = function (options) {\n        this.options = options;\n        // Close any current open loggers.\n        this.closeLoggers();\n    };\n    LoggerFactoryImpl.prototype.getLogger = function (named) {\n        if (!this.options.enabled) {\n            throw new Error(\"LoggerFactory is not enabled, please check your options passed in\");\n        }\n        var logger = this.loggers[named];\n        if (logger !== undefined) {\n            return logger;\n        }\n        // Initialize logger with appropriate level\n        logger = this.loadLogger(named);\n        this.loggers[named] = logger;\n        return logger;\n    };\n    LoggerFactoryImpl.prototype.isEnabled = function () {\n        return this.options.enabled;\n    };\n    LoggerFactoryImpl.prototype.closeLoggers = function () {\n        for (var key in this.loggers) {\n            if (this.loggers.hasOwnProperty(key)) {\n                this.loggers[key].close();\n            }\n        }\n        this.loggers = {};\n    };\n    LoggerFactoryImpl.prototype.loadLogger = function (named) {\n        var logGroupRules = this.options.logGroupRules;\n        for (var _i = 0, logGroupRules_1 = logGroupRules; _i < logGroupRules_1.length; _i++) {\n            var logGroupRule = logGroupRules_1[_i];\n            if (logGroupRule.regExp.test(named)) {\n                switch (logGroupRule.loggerType) {\n                    case LoggerOptions_1.LoggerType.Console:\n                        return new LoggerImpl_1.ConsoleLoggerImpl(named, logGroupRule);\n                    case LoggerOptions_1.LoggerType.MessageBuffer:\n                        return new LoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRule);\n                    case LoggerOptions_1.LoggerType.Custom:\n                        if (logGroupRule.callBackLogger != null) {\n                            return logGroupRule.callBackLogger(named, logGroupRule);\n                        }\n                        else {\n                            throw new Error(\"Cannot create a custom logger, custom callback is null\");\n                        }\n                    default:\n                        throw new Error(\"Cannot create a Logger for LoggerType: \" + logGroupRule.loggerType);\n                }\n            }\n        }\n        throw new Error(\"Failed to find a match to create a Logger for: \" + named);\n    };\n    return LoggerFactoryImpl;\n}());\nexports.LoggerFactoryImpl = LoggerFactoryImpl;\n//# sourceMappingURL=LoggerFactoryImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/LoggerFactoryImpl.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DataStructures_1 = require(\"./DataStructures\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nvar MessageUtils_1 = require(\"./MessageUtils\");\nvar Message = (function () {\n    function Message(ready, message) {\n        if (message === void 0) { message = null; }\n        this._ready = ready;\n        this._message = message;\n    }\n    Object.defineProperty(Message.prototype, \"ready\", {\n        get: function () {\n            return this._ready;\n        },\n        set: function (value) {\n            this._ready = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Message.prototype, \"message\", {\n        get: function () {\n            return this._message;\n        },\n        set: function (value) {\n            this._message = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Message;\n}());\n/**\n * Abstract base logger, extend to easily implement a custom logger that\n * logs wherever you want. You only need to implement doLog(msg: string) and\n * log that somewhere (it will contain format and everything else).\n */\nvar AbstractLogger = (function () {\n    function AbstractLogger(name, rule) {\n        this.open = true;\n        this._allMessages = new DataStructures_1.LinkedList();\n        this.name = name;\n        this.rule = rule;\n        this.level = rule.level;\n    }\n    AbstractLogger.prototype.trace = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Trace, msg, error);\n    };\n    AbstractLogger.prototype.debug = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Debug, msg, error);\n    };\n    AbstractLogger.prototype.info = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Info, msg, error);\n    };\n    AbstractLogger.prototype.warn = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Warn, msg, error);\n    };\n    AbstractLogger.prototype.error = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Error, msg, error);\n    };\n    AbstractLogger.prototype.fatal = function (msg, error) {\n        if (error === void 0) { error = null; }\n        this._log(LoggerOptions_1.LogLevel.Fatal, msg, error);\n    };\n    AbstractLogger.prototype.tracec = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Trace, msg, error);\n    };\n    AbstractLogger.prototype.debugc = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Debug, msg, error);\n    };\n    AbstractLogger.prototype.infoc = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Info, msg, error);\n    };\n    AbstractLogger.prototype.warnc = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Warn, msg, error);\n    };\n    AbstractLogger.prototype.errorc = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Error, msg, error);\n    };\n    AbstractLogger.prototype.fatalc = function (msg, error) {\n        this._logc(LoggerOptions_1.LogLevel.Fatal, msg, error);\n    };\n    AbstractLogger.prototype.isTraceEnabled = function () {\n        return this.level === LoggerOptions_1.LogLevel.Trace;\n    };\n    AbstractLogger.prototype.isDebugEnabled = function () {\n        return this.level <= LoggerOptions_1.LogLevel.Debug;\n    };\n    AbstractLogger.prototype.isInfoEnabled = function () {\n        return this.level <= LoggerOptions_1.LogLevel.Info;\n    };\n    AbstractLogger.prototype.isWarnEnabled = function () {\n        return this.level <= LoggerOptions_1.LogLevel.Warn;\n    };\n    AbstractLogger.prototype.isErrorEnabled = function () {\n        return this.level <= LoggerOptions_1.LogLevel.Error;\n    };\n    AbstractLogger.prototype.isFatalEnabled = function () {\n        return this.level <= LoggerOptions_1.LogLevel.Fatal;\n    };\n    AbstractLogger.prototype.getLogLevel = function () {\n        return this.level;\n    };\n    AbstractLogger.prototype.isOpen = function () {\n        return this.open;\n    };\n    AbstractLogger.prototype.close = function () {\n        this.open = false;\n        this._allMessages.clear();\n    };\n    AbstractLogger.prototype._log = function (level, msg, error) {\n        if (error === void 0) { error = null; }\n        if (this.open && this.level <= level) {\n            this._allMessages.addTail(this.createMessage(level, msg, new Date(), error));\n            this.processMessages();\n        }\n    };\n    AbstractLogger.prototype._logc = function (level, msg, error) {\n        if (this.open && this.level <= level) {\n            this._allMessages.addTail(this.createMessage(level, msg(), new Date(), error !== undefined && error != null ? error() : null));\n            this.processMessages();\n        }\n    };\n    AbstractLogger.prototype.createMessage = function (level, msg, date, error) {\n        var _this = this;\n        if (error === void 0) { error = null; }\n        var result = \"\";\n        if (this.rule.logFormat.showTimeStamp) {\n            result += MessageUtils_1.MessageFormatUtils.renderDate(date, this.rule.logFormat.dateFormat) + \" \";\n        }\n        result += LoggerOptions_1.LogLevel[level].toUpperCase() + \" \";\n        if (this.rule.logFormat.showLoggerName) {\n            result += \"[\" + this.name + \"]\";\n        }\n        result += \" \" + msg;\n        if (error != null) {\n            var message_1 = new Message(false);\n            MessageUtils_1.MessageFormatUtils.renderError(error).then(function (stackResult) {\n                result += \"\\n\" + stackResult;\n                message_1.message = result;\n                message_1.ready = true;\n                _this.processMessages();\n            });\n            return message_1;\n        }\n        return new Message(true, result);\n    };\n    AbstractLogger.prototype.processMessages = function () {\n        // Basically we wait until errors are resolved (those messages\n        // may not be ready).\n        var msgs = this._allMessages;\n        if (msgs.getSize() > 0) {\n            do {\n                var msg = msgs.getHead();\n                if (msg != null) {\n                    if (!msg.ready) {\n                        break;\n                    }\n                    msgs.removeHead();\n                    // This can never be null normally, but strict null checking ...\n                    if (msg.message != null) {\n                        this.doLog(msg.message);\n                    }\n                }\n            } while (msgs.getSize() > 0);\n        }\n    };\n    return AbstractLogger;\n}());\nexports.AbstractLogger = AbstractLogger;\n/**\n * Simple logger, that logs to the console. If the console is unavailable will throw exception.\n */\nvar ConsoleLoggerImpl = (function (_super) {\n    __extends(ConsoleLoggerImpl, _super);\n    function ConsoleLoggerImpl(name, rule) {\n        return _super.call(this, name, rule) || this;\n    }\n    ConsoleLoggerImpl.prototype.doLog = function (msg, logLevel) {\n        if (console !== undefined) {\n            var logged = false;\n            /* tslint:disable:no-console */\n            switch (logLevel) {\n                case LoggerOptions_1.LogLevel.Trace:\n                    if (console.trace) {\n                        console.trace(msg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Debug:\n                    if (console.debug) {\n                        console.debug(msg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Info:\n                    if (console.info) {\n                        console.info(msg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Warn:\n                    if (console.warn) {\n                        console.warn(msg);\n                        logged = true;\n                    }\n                    break;\n                case LoggerOptions_1.LogLevel.Error:\n                case LoggerOptions_1.LogLevel.Fatal:\n                    if (console.error) {\n                        console.error(msg);\n                        logged = true;\n                    }\n                    break;\n                default:\n                    throw new Error(\"Log level not supported: \" + logLevel);\n            }\n        }\n        else {\n            throw new Error(\"Console is not defined, cannot log msg: \" + msg);\n        }\n    };\n    return ConsoleLoggerImpl;\n}(AbstractLogger));\nexports.ConsoleLoggerImpl = ConsoleLoggerImpl;\n/**\n * Logger which buffers all messages, use with care due to possible high memory footprint.\n * Can be convenient in some cases. Call toString() for full output, or cast to this class\n * and call getMessages() to do something with it yourself.\n */\nvar MessageBufferLoggerImpl = (function (_super) {\n    __extends(MessageBufferLoggerImpl, _super);\n    function MessageBufferLoggerImpl(name, rule) {\n        var _this = _super.call(this, name, rule) || this;\n        _this.messages = [];\n        return _this;\n    }\n    MessageBufferLoggerImpl.prototype.close = function () {\n        this.messages = [];\n        _super.prototype.close.call(this);\n    };\n    MessageBufferLoggerImpl.prototype.getMessages = function () {\n        return this.messages;\n    };\n    MessageBufferLoggerImpl.prototype.toString = function () {\n        return this.messages.map(function (msg) {\n            return msg;\n        }).join(\"\\n\");\n    };\n    MessageBufferLoggerImpl.prototype.doLog = function (msg, logLevel) {\n        this.messages.push(msg);\n    };\n    return MessageBufferLoggerImpl;\n}(AbstractLogger));\nexports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;\n//# sourceMappingURL=LoggerImpl.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/LoggerImpl.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DataStructures_1 = require(\"./DataStructures\");\nvar LoggerOptions_1 = require(\"./LoggerOptions\");\nvar JSONTypeImpl = (function () {\n    function JSONTypeImpl(value) {\n        this._value = value;\n    }\n    JSONTypeImpl.prototype.getValue = function () {\n        return this._value;\n    };\n    JSONTypeImpl.prototype.toString = function () {\n        var value = this.getValue();\n        if (value != null) {\n            return value.toString();\n        }\n        return \"null\";\n    };\n    return JSONTypeImpl;\n}());\nvar JSONBooleanType = (function (_super) {\n    __extends(JSONBooleanType, _super);\n    function JSONBooleanType(value) {\n        return _super.call(this, value) || this;\n    }\n    return JSONBooleanType;\n}(JSONTypeImpl));\nvar JSONNumberType = (function (_super) {\n    __extends(JSONNumberType, _super);\n    function JSONNumberType(value) {\n        return _super.call(this, value) || this;\n    }\n    return JSONNumberType;\n}(JSONTypeImpl));\nvar JSONStringType = (function (_super) {\n    __extends(JSONStringType, _super);\n    function JSONStringType(value) {\n        return _super.call(this, value) || this;\n    }\n    JSONStringType.prototype.toString = function () {\n        var value = this.getValue();\n        if (value != null) {\n            return JSON.stringify(value.toString());\n        }\n        return \"null\";\n    };\n    return JSONStringType;\n}(JSONTypeImpl));\nvar JSONObjectType = (function (_super) {\n    __extends(JSONObjectType, _super);\n    function JSONObjectType(value) {\n        return _super.call(this, value) || this;\n    }\n    return JSONObjectType;\n}(JSONTypeImpl));\nvar JSONArrayType = (function (_super) {\n    __extends(JSONArrayType, _super);\n    function JSONArrayType(value) {\n        return _super.call(this, value) || this;\n    }\n    JSONArrayType.prototype.toString = function () {\n        var value = this.getValue();\n        if (value != null) {\n            return value.toString();\n        }\n        return \"null\";\n    };\n    return JSONArrayType;\n}(JSONTypeImpl));\nvar JSONNullType = (function (_super) {\n    __extends(JSONNullType, _super);\n    function JSONNullType() {\n        return _super.call(this, null) || this;\n    }\n    JSONNullType.prototype.toString = function () {\n        return \"null\";\n    };\n    return JSONNullType;\n}(JSONTypeImpl));\nvar JSONTypeConverter = (function () {\n    function JSONTypeConverter() {\n    }\n    JSONTypeConverter.toJSONType = function (value) {\n        if (value === null) {\n            return new JSONNullType();\n        }\n        if (typeof value === \"string\") {\n            return new JSONStringType(value);\n        }\n        if (typeof value === \"number\") {\n            return new JSONNumberType(value);\n        }\n        if (typeof value === \"boolean\") {\n            return new JSONBooleanType(value);\n        }\n        if (value instanceof JSONObject) {\n            return new JSONObjectType(value);\n        }\n        throw new Error(\"Type not supported for value: \" + value);\n    };\n    return JSONTypeConverter;\n}());\nvar JSONObject = (function () {\n    function JSONObject() {\n        this.values = new DataStructures_1.SimpleMap();\n    }\n    JSONObject.prototype.addBoolean = function (name, value) {\n        this.checkName(name);\n        JSONObject.checkValue(value);\n        this.values.put(name, new JSONBooleanType(value));\n        return this;\n    };\n    JSONObject.prototype.addNumber = function (name, value) {\n        this.checkName(name);\n        JSONObject.checkValue(value);\n        this.values.put(name, new JSONNumberType(value));\n        return this;\n    };\n    JSONObject.prototype.addString = function (name, value) {\n        this.checkName(name);\n        JSONObject.checkValue(value);\n        this.values.put(name, new JSONStringType(value));\n        return this;\n    };\n    JSONObject.prototype.addNull = function (name) {\n        this.checkName(name);\n        this.values.put(name, new JSONNullType());\n        return this;\n    };\n    JSONObject.prototype.addArray = function (name, array) {\n        this.checkName(name);\n        JSONObject.checkValue(array);\n        if (array == null) {\n            throw new Error(\"Cannot add array as null\");\n        }\n        this.values.put(name, new JSONArrayType(array));\n        return this;\n    };\n    JSONObject.prototype.addObject = function (name, object) {\n        this.checkName(name);\n        JSONObject.checkValue(object);\n        if (object == null) {\n            throw new Error(\"Cannot add object as null\");\n        }\n        this.values.put(name, new JSONObjectType(object));\n        return this;\n    };\n    JSONObject.prototype.toString = function (pretty) {\n        var _this = this;\n        if (pretty === void 0) { pretty = false; }\n        var comma = false;\n        var buffer = new DataStructures_1.StringBuilder();\n        buffer.append(\"{\");\n        this.values.keys().forEach(function (key) {\n            var value = _this.values.get(key);\n            if (value != null) {\n                if (comma) {\n                    buffer.append(\",\");\n                }\n                buffer.append('\"').append(key).append('\":').append(value.toString());\n                comma = true;\n            }\n        });\n        buffer.append(\"}\");\n        return buffer.toString();\n    };\n    JSONObject.prototype.checkName = function (name) {\n        if (name == null || name === undefined) {\n            throw new Error(\"Name is null or undefined\");\n        }\n        if (this.values.exists(name)) {\n            throw new Error(\"Name \" + name + \" is already present for this object\");\n        }\n    };\n    JSONObject.checkValue = function (value) {\n        if (value === undefined) {\n            throw new Error(\"Value is undefined\");\n        }\n    };\n    return JSONObject;\n}());\nexports.JSONObject = JSONObject;\nvar JSONArray = (function () {\n    function JSONArray() {\n        this.objects = [];\n    }\n    JSONArray.prototype.add = function (object) {\n        if (object === undefined) {\n            throw new Error(\"Object is not allowed to be undefined\");\n        }\n        this.objects.push(JSONTypeConverter.toJSONType(object));\n        return this;\n    };\n    JSONArray.prototype.toString = function (pretty) {\n        if (pretty === void 0) { pretty = false; }\n        var buffer = new DataStructures_1.StringBuilder();\n        buffer.append(\"[\");\n        this.objects.forEach(function (value, index) {\n            if (index > 0) {\n                buffer.append(\",\");\n            }\n            buffer.append(value.toString());\n        });\n        buffer.append(\"]\");\n        return buffer.toString();\n    };\n    return JSONArray;\n}());\nexports.JSONArray = JSONArray;\n/**\n * Utility class that helps us convert things to and from json (not for normal usage).\n */\nvar JSONHelper = (function () {\n    function JSONHelper() {\n    }\n    JSONHelper.categoryToJSON = function (cat, recursive) {\n        /*\n         {\n         \"categories\":\n         [\n         { id=1,\n         name: \"x\",\n         parent: null,\n         logLevel: \"Error\"\n         },\n         { id=2,\n         name: \"y\",\n         parent: 1,\n         logLevel: \"Error\"\n         }\n         ]\n         }\n         */\n        var arr = new JSONArray();\n        JSONHelper._categoryToJSON(cat, arr, recursive);\n        var object = new JSONObject();\n        object.addArray(\"categories\", arr);\n        return object;\n    };\n    JSONHelper._categoryToJSON = function (cat, arr, recursive) {\n        var object = new JSONObject();\n        object.addNumber(\"id\", cat.id);\n        object.addString(\"name\", cat.name);\n        object.addString(\"logLevel\", LoggerOptions_1.LogLevel[cat.logLevel].toString());\n        if (cat.parent != null) {\n            object.addNumber(\"parent\", cat.parent.id);\n        }\n        else {\n            object.addNull(\"parent\");\n        }\n        arr.add(object);\n        if (recursive) {\n            cat.children.forEach(function (child) {\n                JSONHelper._categoryToJSON(child, arr, recursive);\n            });\n        }\n    };\n    return JSONHelper;\n}());\nexports.JSONHelper = JSONHelper;\n//# sourceMappingURL=JSONHelper.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/commonjs/JSONHelper.js\n// module id = 32\n// module chunks = 0"],"sourceRoot":""}